{
    "data": "9/10/2024\n1\nPreview\n\uf070System Calls vs. Library Functions\n\uf070File Descriptors for a process\n\uf070System Call for Managing Files\n\uf06ewrite()\n\uf06eread()\n\uf06eopen()\n\uf06eclose()\n\uf06elseek()\n\uf06epwrite(), pread();\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n1\nSystem Calls vs. Library Functions\n\uf070A system call is a request for the \noperating system to do something on \nbehalf of the user's program.\n\uf070The system calls are functions used in the \nkernel itself.  \n\uf070To the programmer, the system call \nappears as a normal C function call. \n\uf070When a system call, control change from \nuser\u2019s mode to kernel\u2019s mode.\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n2\nSystem Calls vs. Library Functions\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n3\nHardware\nKernel\nSystem Calls\nLibrary Functions\nShell\nApplication Software\nSystem Calls vs. Library Functions\n\uf070System calls is the layer of software interface to the kernel. \n\uf070It is controlled by kernel (unbuffered I/O)\n\uf070Library functions are built on top of system call (Buffered \nI/O). It is called and controlled by a process.\n\uf070Linux system calls are used to process management, file \nsystem management, and inter-process communication. \n\uf070The Linux system interface consist of about 80 system \ncalls.\n\uf070To access and control file, need system call to open, read, \nwrite, close file.\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n4\nSystem Calls vs. Library Functions\n\uf070A system call is very expensive routine\n\uf06eChange a mode from user\u2019s mode to kernel\u2019s mode.\n\uf06eSave all parameters for user\u2019s program for later \nexecution (save snapshot of CPU) \n\uf06eLoad all necessary parameters for system call routine to \nCPU .\n\uf06eExecute the system call routine.\n\uf06eAfter system call routine, load all saved parameters for \nuser\u2019s program to CPU.\n\uf06eChange mode from kernel\u2019s mode to user\u2019s mode.\n\uf06eContinue execution of user\u2019s program.\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n5\nSystem Calls vs. Library Functions\n\uf070To reduce the overhead of system calls, \nsystem such as Unix or Linux provide \nlibrary functions use buffers.\n\uf070For example, I/O function library that \nprovide buffered output. \n\uf070With these library functions, system call \nroutine need execute when size of buffer \nbecomes full.\n\uf070This dramatically reduce the system call \noverhead.\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n69/10/2024\n2\nSystem Calls vs. Library Functions\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n7\nUser Program\nLibraries\nSystem Calls\nKernel\nDevice Drivers\nUser\u2019s space\nKernel\u2019s space\nFile Descriptors for a Process\n\uf070To the kernel, all open files are referred to \nby file descriptors. \n\uf070A file descriptor is a non-negative integer.\n\uf070When we open an existing file or create a \nnew file, the kernel returns a file \ndescriptor to the process.\n\uf070We can read or write a file with the file \ndescriptor which was return by system \ncalls open() or create().\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n8\nFile Descriptors for a Process\n\uf070A process has a number of the descriptors \nassociated it. \n\uf070When a process is created, it has three \ndescriptors which can be used for input, \noutput  and error.\n\uf06e0: Standard input (from keyboard by default)\n\uf06e1: Standard output (to screen by default)\n\uf06e2: Standard error (to screen by default)\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n9\nSystem Calls  for Managing Files\n(write())\n\uf070The write() system call attempts to write nbyte\nbytes from the buffer pointed to by buf to the file \nassociated with the open file descriptor, fildes.\n\uf070It returns the number of bytes actually write.\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n10\n#include <unistd.h> \nssize_t write(int fildes, const void *buf, size_t nbyte);\nReturns: number of bytes written, or -1 on error\nSystem Calls  for Managing Files\n(write())\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n11\n//write.c\n#include <unistd.h>\n#include <stdlib.h>\nint main()\n{\nif ((write (1, \"Hear is some data\\n\", 18)) != 18)\nwrite (2, \"error on file descriptor 1\\n\", 46);\nexit (0);\n}\nSystem Calls  for Managing Files\n(write())\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n12\n#include <unistd.h>\n#include <stdlib.h>\nint main()\n{\nchar Buffer[]=\"Hear is some data\\n\";\nif ((write (1, Buffer, 18)) != 18)\nwrite (2, \"error on file descriptor 1\\n\", 46);\nexit (0);\n}9/10/2024\n3\nSystem Calls  for Managing Files\n(read())\n\uf070The read()  system call function attempts to read \nnbyte bytes from the buffer pointed to by buf to \nthe file associated with the open file descriptor, \nfildes.\n\uf070It returns the number of bytes actually read.\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n13\n#include <unistd.h> \nssize_t read(int fildes, const void *buf, size_t nbyte);\nReturns: size of byte read, 0 if end of file, -1 on error\n/* read_buffer.c \n/* prepare 128 bytes buffer and read a string upto 128 bytes*/\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\nint main()\n{\nchar buffer[128];\nint nread;\n/* can read up to 128 character from stdin */\nnread = read(0, buffer, 128); \nif (nread ==-1)\nwrite (2, \"A read error\\n\", 12);\n/* write content of buffer to stdout */\nif ((write (1, buffer, nread))!= nread)\nwrite (2, \"A write Error!\\n\", 14);\nexit (0);\n}\nSystem Calls  for Managing Files\n(read())\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n14\n/* read_buffer1.c */\n/* read and write byte by byte until empty (Ctr-D)*/\n#include <stdio.h>\n#include <unistd.h>\nint main()\n{\nchar b[1];\nint nread;\n/* read character by character from stdin */\nwhile ((nread =read(0, b, 1) > 0))\nwrite (1, b, nread); /* write char by char to stdout */\nreturn 0;\n}\nSystem Calls  for Managing Files\n(read())\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n15\nSystem Calls for Managing Files\n\uf070Only using read and write system call, we \ncan copy standard input to standard \noutput.\n\uf070This assume that these have been set up \nby the shell before this program is \nexecuted.\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n16\nSystem Calls for Managing Files\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n17\n/* copystdio.c copy standard input to standard output */\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h> /*STDIN_FILENO, STDOUT_FILENO*/\n/* buffer size effect the efficiency of the program */\n#define BUFFER_SIZE 2\nvoid err_sys(char *str)\n{\nprintf (\"%s\",str);\nexit (1);\n}\nint main()\n{\nint nbyte;\nchar buffer[BUFFER_SIZE];\nwhile ((nbyte = read(STDIN_FILENO, buffer, BUFFER_SIZE)) >0)\nif (write (STDOUT_FILENO, buffer, nbyte) != nbyte)\nerr_sys (\"Write Error\");\nif (nbyte <0)\nerr_sys(\"read Error\");\nexit (0);\n}\nSystem Calls  for Managing Files\n(open())\n\uf070open() lets you open a file for reading, writing, or reading \nand writing.\n\uf070It returns a file descriptor.\n\uf070The prototype for the open() system call is:\n\uf070The third argument mode is used only when a new file is \nbeing created.\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n18\n#include <fcntl.h>\nint open(const char *fname, int flags )\nint open (const char *fname, int flags, mode_t mode);\nReturns: file descriptor or -1 on error9/10/2024\n4\nSystem Calls  for Managing Files\n(open())\n\uf070\nThe allowable flags as defined in \"/usr/include/fcntl.h\" are:\n\uf070\n#define  O_RDONLY     0        /* Open the file for reading only */\n\uf070\n#define  O_WRONLY    1        /* Open the file for writing only */\n\uf070\n#define  O_RDWR        2     /* Open the file for both reading and writing*/\n\uf070\n#define  O_NDELAY    04       /* Non-blocking I/O */\n\uf070\n#define  O_APPEND  010      /* append (writes guaranteed at the end) */\n\uf070\n#define  O_CREAT 00400  /*open with file create (uses third open arg) */\n\uf070\n#define  O_TRUNC  01000    /* open with truncation */\n\uf070\n#define  O_EXCL   02000    /* exclusive open */\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n19\nSystem Calls  for Managing Files\n(open())\n\uf070\nThe allowable mode_type as defined in a header sys/stat.h\" are:\n\uf06eS_IRUSR Read permission, owner. \n\uf06eS_IWUSR Write permission, owner. \n\uf06eS_IXUSR Execute/search permission, owner. \n\uf06eS_IRGRP Read permission, group. \n\uf06eS_IWGRP Write permission, group. \n\uf06eS_IXGRP Execute/search permission, group. \n\uf06eS_IROTH Read permission, others. \n\uf06eS_IWOTH Write permission, others. \n\uf06eS_IXOTH Execute/search permission, others.\n\uf070Or we can use octal number numerical form\n\uf06e0777, 0755, 0555, \u2026. \nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n20\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n21\n/*  open.c demonstrate open file */\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n/* defines options flags */\nstatic char message[] = \"Hello, world\";\n#define FILE_MODE (S_IRUSR | S_IWUSR | S_IRGRP| S_IWGRP| S_IROTH| S_IWOTH)\nint main()\n{  \nint fd;\nchar buffer[80];\n/* open for rw and create exclusive open, ceate as rw-rw-rw */\numask(0); /* clear the mask to be able to creat a file with a mode */\nfd = open(\"datafile.dat\",O_RDWR | O_CREAT | O_EXCL, FILE_MODE);\nprintf (\"fd = %d\\n\",fd);\nif (fd != -1)\n{     \nprintf(\"datafile.dat opened for read/write access\\n\");\nwrite(fd, message, sizeof(message));\nlseek(fd, 0, SEEK_SET);/* go back to the beginning of the file */\nif (read(fd, buffer, sizeof(message)) == sizeof(message))             \nprintf(\"\\\"%s\\\" was written to datafile.dat\\n\", buffer);\nelse\nprintf(\"*** error reading datafile.dat ***\\n\");          \nclose (fd);\n}      \nelse\nprintf(\"*** datafile.dat already exists ***\\n\");             \nreturn 0;\n}\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n22\n/*  open1.c demonstrate open file */\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n/* defines options flags */\nstatic char message[] = \"Hello, world\";\nint main()\n{  \nint fd;\nchar buffer[80];\numask(0); /* clear the mask to be able to creat a file with a mode */\n/* open for rw and create exclusive open, ceate as rw-rw-rw */\nfd = open(\"datafile.dat\",O_RDWR | O_CREAT | O_EXCL, 0666);\nprintf (\"fd = %d\\n\",fd);\nif (fd != -1)\n{     \nprintf(\"datafile.dat opened for read/write access\\n\");\nwrite(fd, message, sizeof(message));\nlseek(fd, 0, SEEK_SET);/* go back to the beginning of the file */\nif (read(fd, buffer, sizeof(message)) == sizeof(message))             \nprintf(\"\\\"%s\\\" was written to datafile.dat\\n\", buffer);\nelse\nprintf(\"*** error reading datafile.dat ***\\n\");          \nclose (fd);\n}      \nelse\nprintf(\"*** datafile.dat already exists ***\\n\");             \nreturn 0;\n}\nSystem Calls  for Managing Files\n(creat())\n\uf070A new file can also be created by calling the \ncreate system call.\n\uf070One deficiency with creat() is that the file is \nopened only for writing.\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n23\n#include <fcntl.h>\nint creat(const char *fname, mode_t mode);\nReturn: file descriptor, or -1 on error\nSystem Calls  for Managing Files\n(close())\n\uf070Any opened file is closed by a system call close.\n\uf070Closing a file releases any record that the process \nmay have on the fileSystem Calls  for Managing Files\n(close())\n\uf070Any opened file is closed by a system call close.\n\uf070Closing a file releases any record that the process \nmay have on the file\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n24\n#include <fcntl.h>\nint close (int filedes);\nReturns: 0 if OK, -1 on error9/10/2024\n5\nSystem Calls  for Managing Files\n(lseek())\n\uf070Every open file has an associated with current file \noffset.\n\uf070It is non negative integer that measures the \nnumber of bytes from the beginning of the file.\n\uf070When a file is opened, offset is set to 0.\n\uf070Read/write operation start at current file offset \nand cause the offset to be incremented by the \nnumber of bytes read or write.\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n25\nSystem Calls  for Managing Files\n(lseek())\n\uf070An open file offset can be explicitly positioned by \ncalling lseek system call.\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n26\n#include <unistd.h>\noff_t lseek(int filedes, off_t offset int whence);\nReturns: new file offset or -1 on error\nSystem Calls  for Managing Files\n(lseek())\n\uf070The interpretation of the offset depends \non the value of the whence argument.\n\uf06eSEEK_SET: offset is set to offset bytes from \nthe beginning of the file\n\uf06eSEEK_CUR: offset is set to its current value \nplus the offset.\n\uf06eSEEK_END: set to the size of the file plus the \noffset\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n27\nSystem Calls  for Managing Files\n(lseek())\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n28\n/*  program testlseek.c */\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#define FILE_MODE (S_IRUSR | S_IWUSR|S_IRGRP|S_IROTH)\n/* err_sys display error message and exit  */\nvoid err_sys(char *);\nint main()\n{\nint filedes, offset;\nif ((filedes = open(\"testlseek.txt\", FILE_MODE)) <0)\nerr_sys(\"Creat File Open Error\");\nif ((offset = lseek (filedes, 0, SEEK_END))== -1)\nerr_sys(\"Creat seekl Error\");\nprintf(\"offset = %d\", offset);\nreturn 0;\n}\nvoid err_sys(char *str)\n{\nprintf (\"%s\",str);\nexit (1);\n}\nSystem Calls  for Managing Files\n(lseek())\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n29\n/* lseek.c this program test its standard input to see whether\nit is capable of seeking or not */\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\nint main()\n{\nint offset;\nif (offset =lseek(STDIN_FILENO, 0, SEEK_END))== -1)                      \nprintf(\"cannot seek.\\n\");\nelse\nprintf(\"Seek OK. \\n\");\nexit (0);\n}\nSystem Calls  for Managing Files\n(lseek())\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n30\n/* lseek1.c this program display size of input file with input \nredirection */\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\nint main()\n{\nint offset;\nif (offset =lseek(STDIN_FILENO, 0, SEEK_END))== -1)\nprintf(\"cannot seek.\\n\");\nelse\nprintf(\"file size is %d bytes.\\n\", offset);\nexit (0);\n}9/10/2024\n6\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n31\n/*  program creathole.c creat a file with a hole in it */\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <sys/stat.h>\nchar buf1[]=\"abcdefghij\";\nchar buf2[]=\"ABCDEFGHIJ\";\nvoid err_sys(char *str)\n#define FILE_MODE (S_IRUSR | S_IWUSR|S_IRGRP|S_IROTH)\nint main()\n{\nint filedes;\nif ((filedes = open(\"filehole.txt\", FILE_MODE)) <0)\nerr_sys(\"Creat File Open Error\");\nif (write (filedes, buf1, 10) != 10)\nerr_sys(\"Creat Write Error\"); /*now offset = 10*/\nif (lseek (filedes, 40, SEEK_SET)== -1)\nerr_sys(\"Creat seekl Error\");/*now offset =40 */\nif (write(filedes, buf2, 10) != 10)\nerr_sys(\"Creat write Error\"); /*now offset = 50 */\nreturn 0;\n}\n/* err_sys display error message and exit  */\nvoid err_sys(char *str)\n{\nprintf (\"%s\",str);\nexit (1);\n}\npread() and pwrite() system call\n\uf070Calling pread() (pwrite()) is equivalent to calling lseek() \nfollowed by a call to read() (write()) with following \nexceptions.\n\uf06e\nThere is no way to interrupt the two operations that occur when we \ncall pread() (pwrite())\n\uf06e\nThe current file offset is not updated\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n32\n#include <unistd.h> \nssize_t pread(int fildes, void *buf, size_t nbyte, off_t offset);\nReturns: size of byte read, 0 if end of file, -1 on error\nssize_t pwriteint fildes, void *buf, size_t nbyte, off_t offset); \nReturns: size of byte write 0 if end of file, -1 on error\npread() and pwrite() system call\n//pwrite.c shows example for pread() and pwrite()\n#include <fcntl.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\nint main()\n{\nint fd, nr, nr2, nw, nw2;\nchar buf_wr[]={\"This is First message to write\"};\nchar buf_wr2[]={\"This is second message to write\"};\nchar buf_rd[120];\n//open file\nfd = open(\"out.txt\", O_RDWR|O_CREAT, 0666);\n// write first message to the file\nnw = pwrite(fd, &buf_wr, strlen(buf_wr), 0);\n// write the second message just after the first message to the file\nnw2= pwrite(fd, &buf_wr2, strlen(buf_wr2), strlen(buf_wr)+1);\n// read the second message from the file\nnr = pread(fd, &buf_rd, sizeof(buf_rd), strlen(buf_wr)+1);\nprintf(\"read from file: %s\",buf_rd);\nclose(fd);\nreturn 0;\n}\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n33\nsync(), fsync() and fdatasync() System calls\n\uf070Traditional Unix system maintains a buffer cache (or page \ncache) in the kernel\u2019s space.\n\uf070When we write data to a file, the data is normally copied \ninto the buffer cache and queued for writing to disk at some \nlater time. (delayed write). The kernel eventually writes all \nthe delayed-write blocks to disk, normally when it needs to \nreuse the buffer for some other disk block. \n\uf070sync(), fsync(), and fdatasync() system calls are provided \nto ensure consistence of file system on disk with the \ncontents of buffer cache.\n\uf070The function sync()is normally called periodically (usually \nevery 30 seconds) from a system daemon, often called \nupdate. This guarantees regular flushing of the kernel\u2019s \nblock buffers.\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n34\nsync(), fsync() and fdatasync() System calls\n\uf070The fsync() refers only to a single file, specified by the file \ndescriptor filedes, and waits for the disk writes to complete \nbefore returning.\n\uf070This function is used when an application, such as a \ndatabase, needs to be sure that the modified blocks have \nbeen written to the disk.\n\uf070The fdatasync()  is similar to fsync(), but it affects only the \ndata portions of a file. With fsync(), the file\u2019s attributes are \nalso updated synchronously\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n35\n#include <unistd.h> \nint fsync(int fildes);\nint fdatasync (int filedes);\nvoid sync (void); \nReturns: 0 if ok, -1 on error\nsync(), fsync() and fdatasync() System callsDr. Sang-Eon Park\n35\n#include <unistd.h> \nint fsync(int fildes);\nint fdatasync (int filedes);\nvoid sync (void); \nReturns: 0 if ok, -1 on error\nsync(), fsync() and fdatasync() System calls\n#include <stdio.h>\n#include <fcntl.h>\nint main()\n{\nchar wbuffer[] = \"1234567890\";\nchar rbuffer[100];\nint fd;\n/* Open the file */\nfd = open (\"test.txt\", O_RDWR | O_CREAT | O_TRUNC);\n/* Write 10 bytes of data */\nwrite (fd, (void *) wbuffer, 10);\n/* and make sure it's written */\nfsync (fd);\n/* Seek the beginning of the file */\nlseek (fd, 0, SEEK_SET);\n/* Read 10 bytes of data */\nread (fd, (void *) rbuffer, 10);\n/* Terminate the data we've read with a null character */\nrbuffer[10] = '\\0';\nprintf (\"String read = %s.\\n\", rbuffer);\nclose (fd);\nreturn 0;\n}\nCOSC350 System Software, Fall 2024                              \nDr. Sang-Eon Park\n36"
}