2024-12-12 14:23:14 - INFO - Static files mounted
2024-12-12 14:23:14 - INFO - toLetter filter added to Jinja2 environment
2024-12-12 14:23:19 - INFO - POST request received for /generate
2024-12-12 14:23:19 - INFO - Form data: title='Operating Systems Test 1' course='Operating Systems' professor='Dr. Park' number_of_written_questions=1 number_of_mcq_questions=2 number_of_TF_questions=2 level='Normal' school_type='Undergraduate' difficulty='Extreme' testing_philosophy='Fail all students please :)' url_1=None url_2=None subject_material=[UploadFile(filename='450Slides10.pdf', size=166799, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides10.pdf"', 'content-type': 'application/pdf'}))]
2024-12-12 14:23:19 - INFO - Starting run function
2024-12-12 14:23:19 - INFO - Form data accessed
2024-12-12 14:23:19 - INFO - Form Title: Operating Systems Test 1
2024-12-12 14:23:19 - INFO - Form Course: Operating Systems
2024-12-12 14:23:19 - INFO - Form Professor: Dr. Park
2024-12-12 14:23:19 - INFO - Form Number of MCQ Questions: 2
2024-12-12 14:23:19 - INFO - Form Number of TF Questions: 2
2024-12-12 14:23:19 - INFO - Form Number of Written Questions: 1
2024-12-12 14:23:19 - INFO - Form School Type: Undergraduate
2024-12-12 14:23:19 - INFO - Form Difficulty: Extreme
2024-12-12 14:23:19 - INFO - Form Testing Philosophy: Fail all students please :)
2024-12-12 14:23:19 - INFO - Moving to files...
2024-12-12 14:23:19 - INFO - Starting to process files
2024-12-12 14:23:19 - INFO - Processing file: 450Slides10.pdf
2024-12-12 14:23:19 - INFO - Getting loader for file: UploadFile(filename='450Slides10.pdf', size=166799, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides10.pdf"', 'content-type': 'application/pdf'}))
2024-12-12 14:23:19 - INFO - File extension: .pdf
2024-12-12 14:23:19 - INFO - Processing PDF file: 450Slides10.pdf
2024-12-12 14:23:19 - INFO - Using loader type: PyMuPDFLoader for UploadFile(filename='450Slides10.pdf', size=166799, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides10.pdf"', 'content-type': 'application/pdf'}))
2024-12-12 14:23:19 - INFO - URLs: []
2024-12-12 14:23:19 - INFO - Processing 1 files and 0 URLs
2024-12-12 14:23:19 - INFO - Processing 450Slides10.pdf
2024-12-12 14:23:19 - INFO - Using loader type: PyMuPDFLoader for 450Slides10.pdf
2024-12-12 14:23:19 - INFO - Processing 450Slides10.pdf as a regular document using PyMuPDFLoader
2024-12-12 14:23:19 - INFO - Successfully loaded 5 documents from: 450Slides10.pdf
2024-12-12 14:23:19 - INFO - Docs: [Document(metadata={'source': '/tmp/tmp6trtu4ti', 'file_path': '/tmp/tmp6trtu4ti', 'page': 0, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n1\nPreview\nInter-Process Communication\n\ue007Race Condition\n\ue007Critical Section (or region)\n\ue007Solutions for Mutual Exclusion in a Critical Section\n◼With Busy Waiting\n\ue007Disabling Interrupts –non-preemptive kernel\n\ue007Lock Variables –violating the first necessary condition (mutual exclusion )\n\ue007Strict Alternation –violating the second necessary condition ( block by a process outside critical section)\n\ue007Peterson’s Solution\n\ue007Hardware Solution\n▪\nTest and Set Lock –\n▪\nMemory Barriers\n▪\nAtomic Variable\n\ue007Priority Inversion problems with busy waiting\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n1\nInterprocess Communication\n\ue007\nThree issues in interprocess communication\n1.\nHow one process can pass information to another (communication\nbetween processes) – with IPCS (shared memory, message queue,\nFIFO, PIPE, socket, …)\n2.\nHow to make sure two or more processes do not get into the\ncritical section (mutual exclusion)- with mutex, semaphore\n3.\nProper sequencing (Synchronization) when dependencies are\npresent (ex. A create outputs, B consume the outputs)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n2\nInterprocess Communication\n(Race Condition)\n\ue007Race Condition\n◼A situation where two or more processes are reading or writing some shared\ndata and the final result depends on who runs precisely when, are called race\ncondition.\n\ue007Critical section (critical region)\n◼The part of program where the shared memory is accessed.\n\ue007Mutual Exclusion in a critical section can avoid races condition:\n◼If we could arrange matters such that no two processes were ever in their\ncritical regions at the same time, we can avoid races condition.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n3\nInterprocess Communication\n(Race Condition)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n4\nSlots for file names\n• When a process want\nto print a file, it enter a\nfile name in a special\nspooler directory in\nprinter\n• Printer daemon\nperiodically check\nspooler directory any file\nneed to be printed.\nShared variable\nInterprocess Communication\n(Race Condition)\n\ue007\nProcess A tried to send a job to\nspooler, Process A read in = 7,\nprocess A time out and go to ready\nstate before updating in = in + 1.\n\ue007\nProcess B tried to send a job to\nspooler. Process B read in = 7, load\nits job name in slot 7, update i = i +\n1 = 8 and then go to block state for\nwaiting for job.\n\ue007\nProcess A is rescheduled by\nscheduler. Process A already read in\n= 7, Process A load its job name in\nslot 7, update i = i + 1 = 9 and then\ngo to blocked state waiting for this\njob finish.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n5\nInterprocess Communication\n(Race Condition)\n\ue007How to avoid race condition?\nMutual exclusion – some way of making sure that if one process is using a\nshared variable or file, the other processes will be excluded from doing the same\nthing.\n\ue007The choice of the algorithm for achieving mutual exclusion is a\nmajor design issue in any operating system.\n\ue007A solution for the race condition should have following four\nconditions\n1.\nNo two processes may be simultaneously inside their critical regions – mutual\nexclusion\n2.\nNo process running outside its critical region may block other processes\n3.\nNo process should have to wait forever to enter critical region\n4.\nNo assumptions may be made about speeds or the number of CPUs.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n6\n'), Document(metadata={'source': '/tmp/tmp6trtu4ti', 'file_path': '/tmp/tmp6trtu4ti', 'page': 1, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n2\nInterprocess Communication\n(Race Condition)\n\ue007Two approaches for mutual exclusion solutions.\n◼Busy wait – A process will wait until resource become available\nor CPU time term expired.\n◼Sleep and Wakeup – A process check a resource, if not available\ngo to sleep. When the resource become available, the process\nwill be waked up by system or the process release the resource.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n7\nMutual Exclusion with Busy Waiting\n\ue007Each process has time term. A process keep checking the\npossibility to get into critical section.\n\ue007Mutual Exclusion with Busy Waiting\n◼Disabling Interrupts –non-preemptive kernel\n◼Lock Variables\n◼Strict Alternation\n◼Peterson’s Solution\n◼Hardware Solutions\n\ue007Test and Set Lock\n\ue007Memory Barriers\n\ue007Atomic Variable\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n8\nMutual Exclusion with Busy Waiting\n(Disabling Interrupt – Nonprimitive Kernel)\nDisabling Interrupt\n\ue007Once a process get into the critical section, interrupts set to disable.\n\ue007Other process cannot get CPU time until the process finish its job in\nthe critical section.\n\ue007Since each user process has power to control interrupt, it might\ncause the end of system.\n\ue007We can build a simple program which can disable entire system\nsince user has control system interrupt. (vulnerable system)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n9\nMutual Exclusion with Busy Waiting\n(Disabling Interrupt – Nonprimitive Kernel)\nEx) End of the system with Disabling interrupt\n1. A process get into the critical section.\n2. It make disable all the interrupts – which means all\nother process are sleeping until the job is done in the\ncritical section.\n3. The process has blocked outside critical section just\nbefore make enable all the interrupts and never return\nagain, cause end of the system.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n10\nMutual Exclusion with Busy Waiting\n(Using Lock Variable)\n\ue007There are variable called “Lock”\n◼A process can enter in its critical section when Lock = 0.\n◼Lock =0 means no process is currently running in the critical\nsection, set Lock =1 and enter in the critical section.\n◼Once a process finish its job in critical section, set Lock = 0 and\nlet other process in the critical section\n◼Lock = 1 means there is a process running in the critical section,\na process do busy waiting until Lock become 0.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n11\nMutual Exclusion with Busy Waiting\n(Using Lock Variable)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n12\nstatic int lock = 0; //lock variable is initially 0\nrepeat\nwhile lock \ue0060do\n; (no-operation) // Busy waiting\nlock = 1;\nlock = 0;\nuntil false\nCritical Section\nRemainder Section\n'), Document(metadata={'source': '/tmp/tmp6trtu4ti', 'file_path': '/tmp/tmp6trtu4ti', 'page': 2, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n3\nMutual Exclusion with Busy Waiting\n(Using Lock Variable)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n13\nstatic int lock = 0; //lock is initially 0\nrepeat\nwhile lock \ue0060 do\n; (no-operation) //busy waiting\nlock = 1;\nlock = 0;\nuntil false\nCritical Section\nRemainder Section\nScenario)\n1.\nInitially lock = 0.\n2.\nA process P1 tries get into critical section.\nThe process P1 check lock value = 0.\n3.\nProcess P1 CPU time is over and go to\nready state, before updating lock = 1.\n4.\nProcess P2 tries get into critical section.\nP2 check lock value lock = 0\n5.\nP2 set lock = 1 and go to critical section.\n6.\nP2 CPU time is over and P1 is rescheduled.\n7.\nP1 already read lock = 0, P1 set lock = 1\nand go to Critical section. Now P1 and P2\nare in the critical section at the same\ntime\nViolating condition #1: mutual exclusion\nMutual Exclusion with Busy Waiting\n(Strict Alternation)\n\ue007Variable turn can be i or j.\n\ue007if turn = i, process Pi can go to the\ncritical section.\n\ue007Once Pi finish its job in critical\nsection, Pi set turn = j, let process\nPj enter critical section\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n14\nCritical Section\nRemainder Section\nturn is i or j\nrepeat\nwhile turn \ue006i do\n; (no-operation)\nturn = j;\nuntil false\nMutual Exclusion with Busy Waiting\n(Strict Alternation)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n15\nCritical Section\nRemainder Section\nturn is i or j\nrepeat\nwhile turn \ue006i do\n; (no-operation)\nturn = j;\nuntil false\nLet assume initially turn = 0\n1.\nP0 is in CS while P1 is in remaining\nsection.\n2.\nP0 done C.S. and set turn = 1, P1 is\nstill in remaining section.\n3.\nP0 done remaining section and want\nto go to C.S. but turn= 1.\n4.\nP1 has fatal error in remainder\nsection and trapped out by OS.\n5.\nP0 is waiting forever to enter the C.S.\nViolating #2 and #3 condition\n2.\nNo process running outside its critical\nregion may block other processes\n3.\nNo process should have to wait forever to\nenter critical region\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\n\ue007Peterson’s solution provides a good algorithmic description of\nsolving the critical-section problem and illustrates some of the\ncomplexities involved in designing software that addresses the\nrequirements of mutual exclusion, progress, and bounded waiting.\n\ue007Peterson’s solution is restricted to two processes that alternate\nexecution between their critical sections and remainder sections.\n\ue007The processes are numbered P0 and P1.\n\ue007For convenience, when presenting Pi, we use Pj to denote the other\nprocess; that is, j equals 1 −i.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n16\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n17\n#define false 0\n#define true 1\n#define n 2\nint turn\nint interested[n]\nvoid enter_region(int process);\n{\nint other;\nother = 1 – process\ninterested[process] = true\nturn = process;\nwhile (turn ==process && interest[other]==true)\n; /*no operation –busy waiting*/\n}\nvoid leave_region(int process)\n{\ninterest[process] = false;\n}\nvoid main()\n{\nrepeat\nenter_region (int i)\nCritical Section\nleave_resion (int i)\nRemainder Section\nuntil false\n}\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\n1.\nInitially, neither process is in the critical section\n2.\nA process P0 call enter_region (0)\na)\nSet interested[0] = true;\nb)\nSet turn = 0\n3.\ngo to critical section\n4.\nthe process P1 call enter_region(1) to get into its critical section\na)\nset interested[1] = true;\nb)\nset turn = 1;\n5.\nsince interested[0] = true, it is keep looping for interest [0] =\nfalse\n6.\nfinally process P0 finish its critical section and call leave_region(0)\n1.\nset interested[0] = false\n7.\nnow P1 find out interest[0] = false, P1 goes to its critical section\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n18\n'), Document(metadata={'source': '/tmp/tmp6trtu4ti', 'file_path': '/tmp/tmp6trtu4ti', 'page': 3, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n4\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\nProve for Peterson’s Solution)\n\ue007\nLets consider the case both P0 and P1 call enter_region(0) and enter_region(1) almost\nsimultaneously.\n\ue007\nLets interest[0]= true and interest[1] = true at the same time\n\ue007\nBut turn can be only turn = 0 or turn = 1 which ever store is done last is the one that\ncounts!!\nCase 1) turn = 0\nInside enter_region(0)\n◼\nSince turn =0 and interest [1] = ture, P0 keep looping in no-operation until P1 set interested[1] =\nfalse.\nInside enter_region(1)\n◼\nSince turn = 0 and interest[0] = true, P1 goes to its critical section.\nCase 2) turn = 1\nInside enter_region(0)\n◼\nSince turn =1 and interest [1] = ture,. P0 goes to its critical section\nInside enter_region(1)\n◼\nSince turn = 1 and interest[0] = true, P1 keep looping in no-operation until P0 set interested[0] =\nfalse.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n19\nMutual Exclusion with Busy Waiting\n(Test and Set Lock – hardware solution)\n\ue007\nSince TSL instruction is a hardware instruction. The operations of reading the\nlock and storing into register are guaranteed to be indivisible.\n\ue007\nInstruction test and set lock\nTSL RX, LOCK\n1. Read the content at the memory address of LOCK into register RX.\n2. Store a non-zero value at the memory address of LOCK\n\ue007\nThe operations of reading the content of LOCK and storing into it are guaranteed\nto be indivisible.\n\ue007\nHow to use Test and Set Lock instruction for solving race condition?\n◼\nWhen LOCK = 0, any process may set LOCK = 1 by using TSL instruction and go to\nits critical section.\n◼\nWhen the process finish its critical section, set LOCK = 0 using the original move\ninstruction.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n20\nMutual Exclusion with Busy Waiting\n(Test and Set Lock – hardware solution)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n21\nEnter_region\nTSL Register, LOCK\nCMP Register, #0\nJNE Enter_region\nSet LOCK, #1\nRET\nLeave_region\nMOVE LOCK, #0\nRET\nRepeat\nEnter_region\nLeave_region\nuntil false\nCritical Section\nRemainder Section\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\n\ue007Two general memory models\n◼Strongly ordered Memory –a memory modification on one processor is\nimmediately visible to all other processors\n◼Weakly ordered Memory – a memory modification on one processor may not\nbe immediately visible to other processors.\n\ue007With Strongly ordered memory, computer architectures provide\ninstructions that can force any changes in memory to be\npropagated to all other processors, thereby ensuring that memory\nmodifications are visible to threads (or processes) running on other\nprocessors.\n\ue007Such instructions are known as memory barriers or memory\nfences.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n22\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\n\ue007A memory barrier is a type of barrier instruction that causes a\ncentral processing unit (CPU) or compiler to enforce an ordering\nconstraint on memory operations issued before and after the\nbarrier instruction.\n\ue007This typically means that operations issued prior to the barrier are\nguaranteed to be performed before operations issued after the\nbarrier.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n23\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\nEx)\n\ue007Lets assume two threads (or processes) are running on different\npart of program by sharing two variables. (bool flag = false; int x=0;)\n\ue007Thread 1 might print 0 or 100 depends on the order of execution.\n\ue007By using memory barrier instruction Thread1 always print 100.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n24\nwhile (!flag)\nprint x;\nx = 100\nflag = true;\nThread 1\nThread 2\n'), Document(metadata={'source': '/tmp/tmp6trtu4ti', 'file_path': '/tmp/tmp6trtu4ti', 'page': 4, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content="9/17/2024\n5\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\n\ue007Now it is guarantee that the value of flag is loaded before the value of x\n\ue007Also it is guarantee that assignment to x occurs before the assignment to flag.\n\ue007So Thread 1 always print 100\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n25\nwhile (!flag)\nmemory_barrier();\nprint x;\nx = 100;\nmemory_barrier();\nflag = true;\nThread 1\nThread 2\nMutual Exclusion with Busy Waiting\n(Atomic Variables– hardware solution)\n\ue007We can avoid mutual exclusion by using atomic operations.\n\ue007When a thread (or process) performs an atomic operation, the\nother threads (or process) see it as happening instantaneously.\n\ue007The advantage of atomic operations is that they are relatively quick\ncompared to locks, and do not suffer from deadlock and convoying.\n\ue007The disadvantage is that they only do a limited set of operations,\nand often these are not enough to synthesize more complicated\noperations efficiently.\n\ue007But nonetheless you should not pass up an opportunity to use an\natomic operation in place of mutual exclusion.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n26\nMutual Exclusion with Busy Waiting\n(Priority Inversion Problem)\n\ue007Peterson's solution, test and set lock, Memory Barrier, Atomic variable method –\nbusy waiting – (wasting CPU time)\nPriority Inversion problem with busy waiting method\n\ue007A computer with two processes PH with high priorities, and PL with low priorities.\n\ue007The scheduling rules are such that PH get CPU time whenever it is in ready state.\n(preemptive priority scheduling)\n1. At a time T0: PL is in critical section, and PH is in block state.\n2. At a time T1: PH change sate from block to ready state and try to enter the critical\nsection. PL still in critical section.\n3. Based on scheduling rule, short-term scheduler select PH, PH hold CPU and try to enter\ninto critical section.\n4. Since PL is in critical section, PH run busy waiting outside critical section forever since\nPL does not have a chance to get CPU time to finish its critical section.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n27\nMutual Exclusion with Busy Waiting\n(Priority Inversion Problem)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n28\nBlock\nRunning\nReady\nT0 :\nPL: running state in critical section\nPH: block state\nPH\nPL\nBlock\nRunning\nReady\nPH\nPL\nT1 : PH become ready state\nPL: ready state in critical section\nPH: ready state\nCPU scheduler will select higher\npriority process\nBlock\nRunning\nReady\nPH\nPL\nTi>1\nPL: ready state in critical section\nPH: busy waiting in running state\nPH become ready state\nScheduler keep selecting\nPH since higher priority\nThe scheduling rules : CPU scheduler will always select higher priority process.\n")] for 450Slides10.pdf using PyMuPDFLoader
2024-12-12 14:23:19 - INFO - Document 1 (450Slides10.pdf) of 5
2024-12-12 14:23:19 - INFO - Starting clean_files_chain
2024-12-12 14:23:19 - INFO - Document: page_content='9/17/2024
1
Preview
Inter-Process Communication
Race Condition
Critical Section (or region)
Solutions for Mutual Exclusion in a Critical Section
◼With Busy Waiting
Disabling Interrupts –non-preemptive kernel
Lock Variables –violating the first necessary condition (mutual exclusion )
Strict Alternation –violating the second necessary condition ( block by a process outside critical section)
Peterson’s Solution
Hardware Solution
▪
Test and Set Lock –
▪
Memory Barriers
▪
Atomic Variable
Priority Inversion problems with busy waiting
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
1
Interprocess Communication

Three issues in interprocess communication
1.
How one process can pass information to another (communication
between processes) – with IPCS (shared memory, message queue,
FIFO, PIPE, socket, …)
2.
How to make sure two or more processes do not get into the
critical section (mutual exclusion)- with mutex, semaphore
3.
Proper sequencing (Synchronization) when dependencies are
present (ex. A create outputs, B consume the outputs)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
2
Interprocess Communication
(Race Condition)
Race Condition
◼A situation where two or more processes are reading or writing some shared
data and the final result depends on who runs precisely when, are called race
condition.
Critical section (critical region)
◼The part of program where the shared memory is accessed.
Mutual Exclusion in a critical section can avoid races condition:
◼If we could arrange matters such that no two processes were ever in their
critical regions at the same time, we can avoid races condition.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
3
Interprocess Communication
(Race Condition)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
4
Slots for file names
• When a process want
to print a file, it enter a
file name in a special
spooler directory in
printer
• Printer daemon
periodically check
spooler directory any file
need to be printed.
Shared variable
Interprocess Communication
(Race Condition)

Process A tried to send a job to
spooler, Process A read in = 7,
process A time out and go to ready
state before updating in = in + 1.

Process B tried to send a job to
spooler. Process B read in = 7, load
its job name in slot 7, update i = i +
1 = 8 and then go to block state for
waiting for job.

Process A is rescheduled by
scheduler. Process A already read in
= 7, Process A load its job name in
slot 7, update i = i + 1 = 9 and then
go to blocked state waiting for this
job finish.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
5
Interprocess Communication
(Race Condition)
How to avoid race condition?
Mutual exclusion – some way of making sure that if one process is using a
shared variable or file, the other processes will be excluded from doing the same
thing.
The choice of the algorithm for achieving mutual exclusion is a
major design issue in any operating system.
A solution for the race condition should have following four
conditions
1.
No two processes may be simultaneously inside their critical regions – mutual
exclusion
2.
No process running outside its critical region may block other processes
3.
No process should have to wait forever to enter critical region
4.
No assumptions may be made about speeds or the number of CPUs.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
6
' metadata={'source': '/tmp/tmp6trtu4ti', 'file_path': '/tmp/tmp6trtu4ti', 'page': 0, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-12 14:23:19 - INFO - Invoking chain
2024-12-12 14:23:26 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-12 14:23:26 - INFO - Response: {'cleaned_content': '9/17/2024\n\nInter-Process Communication\n\n- Race Condition\n- Critical Section (or region)\n- Solutions for Mutual Exclusion in a Critical Section\n  - With Busy Waiting\n    - Disabling Interrupts – non-preemptive kernel\n    - Lock Variables – violating the first necessary condition (mutual exclusion)\n    - Strict Alternation – violating the second necessary condition (block by a process outside critical section)\n    - Peterson’s Solution\n    - Hardware Solution\n      - Test and Set Lock\n      - Memory Barriers\n      - Atomic Variable\n  - Priority Inversion problems with busy waiting\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nInterprocess Communication\n\nThree issues in interprocess communication:\n1. How one process can pass information to another (communication between processes) – with IPCS (shared memory, message queue, FIFO, PIPE, socket, …)\n2. How to make sure two or more processes do not get into the critical section (mutual exclusion) - with mutex, semaphore\n3. Proper sequencing (Synchronization) when dependencies are present (e.g., A creates outputs, B consumes the outputs)\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nRace Condition\n\nA race condition is a situation where two or more processes are reading or writing some shared data, and the final result depends on the precise timing of their execution.\n\nCritical Section (Critical Region)\n\nThe critical section is the part of the program where shared memory is accessed.\n\nTo avoid race conditions in a critical section, we can ensure that no two processes are ever in their critical regions at the same time.\n\nSlots for File Names\n\nWhen a process wants to print a file, it enters a file name in a special spooler directory for the printer. The printer daemon periodically checks the spooler directory for any files that need to be printed.\n\nShared Variable Example\n\nProcess A tries to send a job to the spooler. Process A reads in = 7, but before updating in to in + 1, it times out and goes to the ready state.\n\nProcess B also tries to send a job to the spooler. Process B reads in = 7, loads its job name into slot 7, updates i to i + 1 = 8, and then goes to the blocked state while waiting for the job.\n\nProcess A is rescheduled by the scheduler. Process A has already read in = 7, loads its job name into slot 7, updates i to i + 1 = 9, and then goes to the blocked state while waiting for this job to finish.\n\nHow to Avoid Race Condition?\n\nMutual exclusion is a way to ensure that if one process is using a shared variable or file, other processes will be excluded from doing the same thing.\n\nThe choice of algorithm for achieving mutual exclusion is a major design issue in any operating system.\n\nA solution for the race condition should meet the following four conditions:\n1. No two processes may be simultaneously inside their critical regions – mutual exclusion.\n2. No process running outside its critical region may block other processes.\n3. No process should have to wait forever to enter the critical region.\n4. No assumptions may be made about speeds or the number of CPUs.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park'}
2024-12-12 14:23:26 - INFO - Finished clean_files_chain
2024-12-12 14:23:26 - INFO - Successfully cleaned document 1 from 450Slides10.pdf
2024-12-12 14:23:26 - INFO - Document 2 (450Slides10.pdf) of 5
2024-12-12 14:23:26 - INFO - Starting clean_files_chain
2024-12-12 14:23:26 - INFO - Document: page_content='9/17/2024
2
Interprocess Communication
(Race Condition)
Two approaches for mutual exclusion solutions.
◼Busy wait – A process will wait until resource become available
or CPU time term expired.
◼Sleep and Wakeup – A process check a resource, if not available
go to sleep. When the resource become available, the process
will be waked up by system or the process release the resource.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
7
Mutual Exclusion with Busy Waiting
Each process has time term. A process keep checking the
possibility to get into critical section.
Mutual Exclusion with Busy Waiting
◼Disabling Interrupts –non-preemptive kernel
◼Lock Variables
◼Strict Alternation
◼Peterson’s Solution
◼Hardware Solutions
Test and Set Lock
Memory Barriers
Atomic Variable
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
8
Mutual Exclusion with Busy Waiting
(Disabling Interrupt – Nonprimitive Kernel)
Disabling Interrupt
Once a process get into the critical section, interrupts set to disable.
Other process cannot get CPU time until the process finish its job in
the critical section.
Since each user process has power to control interrupt, it might
cause the end of system.
We can build a simple program which can disable entire system
since user has control system interrupt. (vulnerable system)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
9
Mutual Exclusion with Busy Waiting
(Disabling Interrupt – Nonprimitive Kernel)
Ex) End of the system with Disabling interrupt
1. A process get into the critical section.
2. It make disable all the interrupts – which means all
other process are sleeping until the job is done in the
critical section.
3. The process has blocked outside critical section just
before make enable all the interrupts and never return
again, cause end of the system.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
10
Mutual Exclusion with Busy Waiting
(Using Lock Variable)
There are variable called “Lock”
◼A process can enter in its critical section when Lock = 0.
◼Lock =0 means no process is currently running in the critical
section, set Lock =1 and enter in the critical section.
◼Once a process finish its job in critical section, set Lock = 0 and
let other process in the critical section
◼Lock = 1 means there is a process running in the critical section,
a process do busy waiting until Lock become 0.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
11
Mutual Exclusion with Busy Waiting
(Using Lock Variable)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
12
static int lock = 0; //lock variable is initially 0
repeat
while lock 0do
; (no-operation) // Busy waiting
lock = 1;
lock = 0;
until false
Critical Section
Remainder Section
' metadata={'source': '/tmp/tmp6trtu4ti', 'file_path': '/tmp/tmp6trtu4ti', 'page': 1, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-12 14:23:26 - INFO - Invoking chain
2024-12-12 14:23:35 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-12 14:23:35 - INFO - Response: {'cleaned_content': '9/17/2024\n\nInterprocess Communication (Race Condition)\n\nTwo approaches for mutual exclusion solutions:\n1. Busy wait – A process will wait until the resource becomes available or the CPU time term expires.\n2. Sleep and Wakeup – A process checks a resource; if it is not available, it goes to sleep. When the resource becomes available, the process is woken up by the system or the process releases the resource.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting\n\nEach process has a time term. A process keeps checking the possibility to enter the critical section.\n\nMutual Exclusion with Busy Waiting includes:\n- Disabling Interrupts – non-preemptive kernel\n- Lock Variables\n- Strict Alternation\n- Peterson’s Solution\n- Hardware Solutions\n  - Test and Set Lock\n  - Memory Barriers\n  - Atomic Variable\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Disabling Interrupt – Nonprimitive Kernel)\n\nDisabling Interrupt:\n- Once a process enters the critical section, interrupts are set to disable.\n- Other processes cannot get CPU time until the process finishes its job in the critical section.\n- Since each user process has the power to control interrupts, it might cause the end of the system.\n- We can build a simple program that can disable the entire system since the user has control over system interrupts (vulnerable system).\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Disabling Interrupt – Nonprimitive Kernel)\nExample: End of the system with Disabling Interrupt\n1. A process enters the critical section.\n2. It disables all the interrupts, which means all other processes are sleeping until the job is done in the critical section.\n3. The process is blocked outside the critical section just before enabling all the interrupts and never returns again, causing the end of the system.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Using Lock Variable)\n\nThere is a variable called "Lock":\n- A process can enter its critical section when Lock = 0.\n- Lock = 0 means no process is currently running in the critical section; set Lock = 1 and enter the critical section.\n- Once a process finishes its job in the critical section, it sets Lock = 0 to let other processes into the critical section.\n- Lock = 1 means there is a process running in the critical section, so a process will do busy waiting until Lock becomes 0.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Using Lock Variable)\n\nstatic int lock = 0; // lock variable is initially 0\nrepeat\n  while lock == 0 do\n    ; // (no-operation) // Busy waiting\n  lock = 1;\n  lock = 0;\nuntil false\n\nCritical Section\nRemainder Section'}
2024-12-12 14:23:35 - INFO - Finished clean_files_chain
2024-12-12 14:23:35 - INFO - Successfully cleaned document 2 from 450Slides10.pdf
2024-12-12 14:23:35 - INFO - Document 3 (450Slides10.pdf) of 5
2024-12-12 14:23:35 - INFO - Starting clean_files_chain
2024-12-12 14:23:35 - INFO - Document: page_content='9/17/2024
3
Mutual Exclusion with Busy Waiting
(Using Lock Variable)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
13
static int lock = 0; //lock is initially 0
repeat
while lock 0 do
; (no-operation) //busy waiting
lock = 1;
lock = 0;
until false
Critical Section
Remainder Section
Scenario)
1.
Initially lock = 0.
2.
A process P1 tries get into critical section.
The process P1 check lock value = 0.
3.
Process P1 CPU time is over and go to
ready state, before updating lock = 1.
4.
Process P2 tries get into critical section.
P2 check lock value lock = 0
5.
P2 set lock = 1 and go to critical section.
6.
P2 CPU time is over and P1 is rescheduled.
7.
P1 already read lock = 0, P1 set lock = 1
and go to Critical section. Now P1 and P2
are in the critical section at the same
time
Violating condition #1: mutual exclusion
Mutual Exclusion with Busy Waiting
(Strict Alternation)
Variable turn can be i or j.
if turn = i, process Pi can go to the
critical section.
Once Pi finish its job in critical
section, Pi set turn = j, let process
Pj enter critical section
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
14
Critical Section
Remainder Section
turn is i or j
repeat
while turn i do
; (no-operation)
turn = j;
until false
Mutual Exclusion with Busy Waiting
(Strict Alternation)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
15
Critical Section
Remainder Section
turn is i or j
repeat
while turn i do
; (no-operation)
turn = j;
until false
Let assume initially turn = 0
1.
P0 is in CS while P1 is in remaining
section.
2.
P0 done C.S. and set turn = 1, P1 is
still in remaining section.
3.
P0 done remaining section and want
to go to C.S. but turn= 1.
4.
P1 has fatal error in remainder
section and trapped out by OS.
5.
P0 is waiting forever to enter the C.S.
Violating #2 and #3 condition
2.
No process running outside its critical
region may block other processes
3.
No process should have to wait forever to
enter critical region
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
Peterson’s solution provides a good algorithmic description of
solving the critical-section problem and illustrates some of the
complexities involved in designing software that addresses the
requirements of mutual exclusion, progress, and bounded waiting.
Peterson’s solution is restricted to two processes that alternate
execution between their critical sections and remainder sections.
The processes are numbered P0 and P1.
For convenience, when presenting Pi, we use Pj to denote the other
process; that is, j equals 1 −i.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
16
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
17
#define false 0
#define true 1
#define n 2
int turn
int interested[n]
void enter_region(int process);
{
int other;
other = 1 – process
interested[process] = true
turn = process;
while (turn ==process && interest[other]==true)
; /*no operation –busy waiting*/
}
void leave_region(int process)
{
interest[process] = false;
}
void main()
{
repeat
enter_region (int i)
Critical Section
leave_resion (int i)
Remainder Section
until false
}
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
1.
Initially, neither process is in the critical section
2.
A process P0 call enter_region (0)
a)
Set interested[0] = true;
b)
Set turn = 0
3.
go to critical section
4.
the process P1 call enter_region(1) to get into its critical section
a)
set interested[1] = true;
b)
set turn = 1;
5.
since interested[0] = true, it is keep looping for interest [0] =
false
6.
finally process P0 finish its critical section and call leave_region(0)
1.
set interested[0] = false
7.
now P1 find out interest[0] = false, P1 goes to its critical section
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
18
' metadata={'source': '/tmp/tmp6trtu4ti', 'file_path': '/tmp/tmp6trtu4ti', 'page': 2, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-12 14:23:35 - INFO - Invoking chain
2024-12-12 14:23:43 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-12 14:23:43 - INFO - Response: {'cleaned_content': "9/17/2024\n\nMutual Exclusion with Busy Waiting (Using Lock Variable)\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nstatic int lock = 0; // lock is initially 0\nrepeat\n    while lock == 0 do\n        ; // (no-operation) // busy waiting\n    lock = 1;\n    lock = 0;\nuntil false\n\nCritical Section\nRemainder Section\n\nScenario:\n1. Initially, lock = 0.\n2. A process P1 tries to get into the critical section. The process P1 checks lock value = 0.\n3. Process P1's CPU time is over and goes to ready state, before updating lock = 1.\n4. Process P2 tries to get into the critical section. P2 checks lock value = 0.\n5. P2 sets lock = 1 and goes to the critical section.\n6. P2's CPU time is over and P1 is rescheduled.\n7. P1 already read lock = 0, P1 sets lock = 1 and goes to the critical section. Now P1 and P2 are in the critical section at the same time, violating condition #1: mutual exclusion.\n\nMutual Exclusion with Busy Waiting (Strict Alternation)\n- Variable turn can be i or j.\n- If turn = i, process Pi can go to the critical section.\n- Once Pi finishes its job in the critical section, Pi sets turn = j, allowing process Pj to enter the critical section.\n\nturn is i or j\nrepeat\n    while turn == i do\n        ; // (no-operation)\n    turn = j;\nuntil false\n\nLet us assume initially turn = 0\n1. P0 is in CS while P1 is in the remainder section.\n2. P0 finishes the critical section and sets turn = 1; P1 is still in the remainder section.\n3. P0 finishes the remainder section and wants to go to CS, but turn = 1.\n4. P1 has a fatal error in the remainder section and is trapped out by the OS.\n5. P0 is waiting forever to enter the CS, violating conditions #2 and #3:\n   2. No process running outside its critical region may block other processes.\n   3. No process should have to wait forever to enter the critical region.\n\nMutual Exclusion with Busy Waiting (Peterson’s Solution)\n- Peterson’s solution provides a good algorithmic description of solving the critical-section problem and illustrates some of the complexities involved in designing software that addresses the requirements of mutual exclusion, progress, and bounded waiting.\n- Peterson’s solution is restricted to two processes that alternate execution between their critical sections and remainder sections.\n- The processes are numbered P0 and P1. For convenience, when presenting Pi, we use Pj to denote the other process; that is, j equals 1 - i.\n\n#define false 0\n#define true 1\n#define n 2\nint turn;\nint interested[n];\n\nvoid enter_region(int process) {\n    int other;\n    other = 1 - process;\n    interested[process] = true;\n    turn = process;\n    while (turn == process && interested[other] == true)\n        ; /* no operation – busy waiting */\n}\n\nvoid leave_region(int process) {\n    interested[process] = false;\n}\n\nvoid main() {\n    repeat\n        enter_region(int i);\n        Critical Section;\n        leave_region(int i);\n        Remainder Section;\n    until false;\n}\n\nMutual Exclusion with Busy Waiting (Peterson’s Solution)\n1. Initially, neither process is in the critical section.\n2. A process P0 calls enter_region(0):\n   a) Set interested[0] = true;\n   b) Set turn = 0;\n3. Go to the critical section.\n4. The process P1 calls enter_region(1) to get into its critical section:\n   a) Set interested[1] = true;\n   b) Set turn = 1;\n5. Since interested[0] = true, it keeps looping for interested[0] = false.\n6. Finally, process P0 finishes its critical section and calls leave_region(0):\n   1) Set interested[0] = false;\n7. Now P1 finds out interested[0] = false, P1 goes to its critical section."}
2024-12-12 14:23:43 - INFO - Finished clean_files_chain
2024-12-12 14:23:43 - INFO - Successfully cleaned document 3 from 450Slides10.pdf
2024-12-12 14:23:43 - INFO - Document 4 (450Slides10.pdf) of 5
2024-12-12 14:23:43 - INFO - Starting clean_files_chain
2024-12-12 14:23:43 - INFO - Document: page_content='9/17/2024
4
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
Prove for Peterson’s Solution)

Lets consider the case both P0 and P1 call enter_region(0) and enter_region(1) almost
simultaneously.

Lets interest[0]= true and interest[1] = true at the same time

But turn can be only turn = 0 or turn = 1 which ever store is done last is the one that
counts!!
Case 1) turn = 0
Inside enter_region(0)
◼
Since turn =0 and interest [1] = ture, P0 keep looping in no-operation until P1 set interested[1] =
false.
Inside enter_region(1)
◼
Since turn = 0 and interest[0] = true, P1 goes to its critical section.
Case 2) turn = 1
Inside enter_region(0)
◼
Since turn =1 and interest [1] = ture,. P0 goes to its critical section
Inside enter_region(1)
◼
Since turn = 1 and interest[0] = true, P1 keep looping in no-operation until P0 set interested[0] =
false.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
19
Mutual Exclusion with Busy Waiting
(Test and Set Lock – hardware solution)

Since TSL instruction is a hardware instruction. The operations of reading the
lock and storing into register are guaranteed to be indivisible.

Instruction test and set lock
TSL RX, LOCK
1. Read the content at the memory address of LOCK into register RX.
2. Store a non-zero value at the memory address of LOCK

The operations of reading the content of LOCK and storing into it are guaranteed
to be indivisible.

How to use Test and Set Lock instruction for solving race condition?
◼
When LOCK = 0, any process may set LOCK = 1 by using TSL instruction and go to
its critical section.
◼
When the process finish its critical section, set LOCK = 0 using the original move
instruction.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
20
Mutual Exclusion with Busy Waiting
(Test and Set Lock – hardware solution)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
21
Enter_region
TSL Register, LOCK
CMP Register, #0
JNE Enter_region
Set LOCK, #1
RET
Leave_region
MOVE LOCK, #0
RET
Repeat
Enter_region
Leave_region
until false
Critical Section
Remainder Section
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
Two general memory models
◼Strongly ordered Memory –a memory modification on one processor is
immediately visible to all other processors
◼Weakly ordered Memory – a memory modification on one processor may not
be immediately visible to other processors.
With Strongly ordered memory, computer architectures provide
instructions that can force any changes in memory to be
propagated to all other processors, thereby ensuring that memory
modifications are visible to threads (or processes) running on other
processors.
Such instructions are known as memory barriers or memory
fences.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
22
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
A memory barrier is a type of barrier instruction that causes a
central processing unit (CPU) or compiler to enforce an ordering
constraint on memory operations issued before and after the
barrier instruction.
This typically means that operations issued prior to the barrier are
guaranteed to be performed before operations issued after the
barrier.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
23
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
Ex)
Lets assume two threads (or processes) are running on different
part of program by sharing two variables. (bool flag = false; int x=0;)
Thread 1 might print 0 or 100 depends on the order of execution.
By using memory barrier instruction Thread1 always print 100.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
24
while (!flag)
print x;
x = 100
flag = true;
Thread 1
Thread 2
' metadata={'source': '/tmp/tmp6trtu4ti', 'file_path': '/tmp/tmp6trtu4ti', 'page': 3, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-12 14:23:43 - INFO - Invoking chain
2024-12-12 14:23:51 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-12 14:23:51 - INFO - Response: {'cleaned_content': "9/17/2024\n\nMutual Exclusion with Busy Waiting (Peterson’s Solution)\n\nTo prove Peterson’s Solution, let's consider the case where both P0 and P1 call enter_region(0) and enter_region(1) almost simultaneously.\n\nLet interest[0] = true and interest[1] = true at the same time. But turn can be only turn = 0 or turn = 1. Whichever store is done last is the one that counts!\n\nCase 1: turn = 0\nInside enter_region(0):\n- Since turn = 0 and interest[1] = true, P0 keeps looping in a no-operation until P1 sets interest[1] = false.\n\nInside enter_region(1):\n- Since turn = 0 and interest[0] = true, P1 goes to its critical section.\n\nCase 2: turn = 1\nInside enter_region(0):\n- Since turn = 1 and interest[1] = true, P0 goes to its critical section.\n\nInside enter_region(1):\n- Since turn = 1 and interest[0] = true, P1 keeps looping in a no-operation until P0 sets interest[0] = false.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Test and Set Lock – hardware solution)\n\nSince the Test and Set Lock (TSL) instruction is a hardware instruction, the operations of reading the lock and storing into a register are guaranteed to be indivisible.\n\nInstruction for test and set lock:\n- TSL RX, LOCK\n1. Read the content at the memory address of LOCK into register RX.\n2. Store a non-zero value at the memory address of LOCK.\n\nThe operations of reading the content of LOCK and storing into it are guaranteed to be indivisible.\n\nHow to use the Test and Set Lock instruction for solving a race condition?\n- When LOCK = 0, any process may set LOCK = 1 by using the TSL instruction and go to its critical section.\n- When the process finishes its critical section, it sets LOCK = 0 using the original move instruction.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nEnter_region:\n- TSL Register, LOCK\n- CMP Register, #0\n- JNE Enter_region\n- Set LOCK, #1\n- RET\n\nLeave_region:\n- MOVE LOCK, #0\n- RET\n\nRepeat:\n- Enter_region\n- Leave_region until false\n\nCritical Section\nRemainder Section\n\nMutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)\n\nTwo general memory models:\n1. Strongly ordered Memory – a memory modification on one processor is immediately visible to all other processors.\n2. Weakly ordered Memory – a memory modification on one processor may not be immediately visible to other processors.\n\nWith strongly ordered memory, computer architectures provide instructions that can force any changes in memory to be propagated to all other processors, thereby ensuring that memory modifications are visible to threads (or processes) running on other processors.\nSuch instructions are known as memory barriers or memory fences.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nA memory barrier is a type of barrier instruction that causes a central processing unit (CPU) or compiler to enforce an ordering constraint on memory operations issued before and after the barrier instruction.\nThis typically means that operations issued prior to the barrier are guaranteed to be performed before operations issued after the barrier.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nExample:\nLet's assume two threads (or processes) are running on different parts of the program by sharing two variables: (bool flag = false; int x = 0;)\n- Thread 1 might print 0 or 100 depending on the order of execution.\n- By using a memory barrier instruction, Thread 1 will always print 100.\n\nwhile (!flag)\n    print x;\n    x = 100;\n    flag = true;\nThread 1\nThread 2"}
2024-12-12 14:23:51 - INFO - Finished clean_files_chain
2024-12-12 14:23:51 - INFO - Successfully cleaned document 4 from 450Slides10.pdf
2024-12-12 14:23:51 - INFO - Document 5 (450Slides10.pdf) of 5
2024-12-12 14:23:51 - INFO - Starting clean_files_chain
2024-12-12 14:23:51 - INFO - Document: page_content='9/17/2024
5
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
Now it is guarantee that the value of flag is loaded before the value of x
Also it is guarantee that assignment to x occurs before the assignment to flag.
So Thread 1 always print 100
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
25
while (!flag)
memory_barrier();
print x;
x = 100;
memory_barrier();
flag = true;
Thread 1
Thread 2
Mutual Exclusion with Busy Waiting
(Atomic Variables– hardware solution)
We can avoid mutual exclusion by using atomic operations.
When a thread (or process) performs an atomic operation, the
other threads (or process) see it as happening instantaneously.
The advantage of atomic operations is that they are relatively quick
compared to locks, and do not suffer from deadlock and convoying.
The disadvantage is that they only do a limited set of operations,
and often these are not enough to synthesize more complicated
operations efficiently.
But nonetheless you should not pass up an opportunity to use an
atomic operation in place of mutual exclusion.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
26
Mutual Exclusion with Busy Waiting
(Priority Inversion Problem)
Peterson's solution, test and set lock, Memory Barrier, Atomic variable method –
busy waiting – (wasting CPU time)
Priority Inversion problem with busy waiting method
A computer with two processes PH with high priorities, and PL with low priorities.
The scheduling rules are such that PH get CPU time whenever it is in ready state.
(preemptive priority scheduling)
1. At a time T0: PL is in critical section, and PH is in block state.
2. At a time T1: PH change sate from block to ready state and try to enter the critical
section. PL still in critical section.
3. Based on scheduling rule, short-term scheduler select PH, PH hold CPU and try to enter
into critical section.
4. Since PL is in critical section, PH run busy waiting outside critical section forever since
PL does not have a chance to get CPU time to finish its critical section.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
27
Mutual Exclusion with Busy Waiting
(Priority Inversion Problem)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
28
Block
Running
Ready
T0 :
PL: running state in critical section
PH: block state
PH
PL
Block
Running
Ready
PH
PL
T1 : PH become ready state
PL: ready state in critical section
PH: ready state
CPU scheduler will select higher
priority process
Block
Running
Ready
PH
PL
Ti>1
PL: ready state in critical section
PH: busy waiting in running state
PH become ready state
Scheduler keep selecting
PH since higher priority
The scheduling rules : CPU scheduler will always select higher priority process.
' metadata={'source': '/tmp/tmp6trtu4ti', 'file_path': '/tmp/tmp6trtu4ti', 'page': 4, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-12 14:23:51 - INFO - Invoking chain
2024-12-12 14:23:57 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-12 14:23:57 - INFO - Response: {'cleaned_content': "9/17/2024\n\nMutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)\n\n- Now it is guaranteed that the value of flag is loaded before the value of x.\n- Also, it is guaranteed that assignment to x occurs before the assignment to flag.\n- Therefore, Thread 1 always prints 100.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nwhile (!flag)\n    memory_barrier();\nprint x;\nx = 100;\nmemory_barrier();\nflag = true;\n\nThread 1\nThread 2\n\nMutual Exclusion with Busy Waiting (Atomic Variables – hardware solution)\n\n- We can avoid mutual exclusion by using atomic operations.\n- When a thread (or process) performs an atomic operation, the other threads (or processes) see it as happening instantaneously.\n- The advantage of atomic operations is that they are relatively quick compared to locks and do not suffer from deadlock and convoying.\n- The disadvantage is that they only perform a limited set of operations, and these are often insufficient to synthesize more complicated operations efficiently.\n- Nonetheless, you should not pass up an opportunity to use an atomic operation in place of mutual exclusion.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Priority Inversion Problem)\n\n- Peterson's solution, test and set lock, Memory Barrier, Atomic variable method – busy waiting – (wasting CPU time)\n\nPriority Inversion problem with busy waiting method:\n\n- Consider a computer with two processes: PH with high priority, and PL with low priority.\n- The scheduling rules are such that PH gets CPU time whenever it is in the ready state (preemptive priority scheduling).\n\n1. At time T0: PL is in the critical section, and PH is in the blocked state.\n2. At time T1: PH changes state from blocked to ready state and tries to enter the critical section. PL is still in the critical section.\n3. Based on the scheduling rule, the short-term scheduler selects PH; PH holds the CPU and tries to enter the critical section.\n4. Since PL is in the critical section, PH runs busy waiting outside the critical section forever, as PL does not have a chance to get CPU time to finish its critical section.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Priority Inversion Problem)\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nBlock   Running   Ready\nT0: \nPL: running state in critical section\nPH: blocked state\n\nPH\nPL\n\nBlock   Running   Ready\nPH\nPL\nT1: PH becomes ready state\nPL: ready state in critical section\nPH: ready state\n\nThe CPU scheduler will select the higher priority process.\n\nBlock   Running   Ready\nPH\nPL\nT1>1\nPL: ready state in critical section\nPH: busy waiting in running state\nPH becomes ready state\n\nThe scheduler keeps selecting PH since it has higher priority.\n\nThe scheduling rules: The CPU scheduler will always select the higher priority process."}
2024-12-12 14:23:57 - INFO - Finished clean_files_chain
2024-12-12 14:23:57 - INFO - Successfully cleaned document 5 from 450Slides10.pdf
2024-12-12 14:23:57 - INFO - Pages: []
2024-12-12 14:23:57 - INFO - Full response: 9/17/2024

Inter-Process Communication

- Race Condition
- Critical Section (or region)
- Solutions for Mutual Exclusion in a Critical Section
  - With Busy Waiting
    - Disabling Interrupts – non-preemptive kernel
    - Lock Variables – violating the first necessary condition (mutual exclusion)
    - Strict Alternation – violating the second necessary condition (block by a process outside critical section)
    - Peterson’s Solution
    - Hardware Solution
      - Test and Set Lock
      - Memory Barriers
      - Atomic Variable
  - Priority Inversion problems with busy waiting

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Interprocess Communication

Three issues in interprocess communication:
1. How one process can pass information to another (communication between processes) – with IPCS (shared memory, message queue, FIFO, PIPE, socket, …)
2. How to make sure two or more processes do not get into the critical section (mutual exclusion) - with mutex, semaphore
3. Proper sequencing (Synchronization) when dependencies are present (e.g., A creates outputs, B consumes the outputs)

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Race Condition

A race condition is a situation where two or more processes are reading or writing some shared data, and the final result depends on the precise timing of their execution.

Critical Section (Critical Region)

The critical section is the part of the program where shared memory is accessed.

To avoid race conditions in a critical section, we can ensure that no two processes are ever in their critical regions at the same time.

Slots for File Names

When a process wants to print a file, it enters a file name in a special spooler directory for the printer. The printer daemon periodically checks the spooler directory for any files that need to be printed.

Shared Variable Example

Process A tries to send a job to the spooler. Process A reads in = 7, but before updating in to in + 1, it times out and goes to the ready state.

Process B also tries to send a job to the spooler. Process B reads in = 7, loads its job name into slot 7, updates i to i + 1 = 8, and then goes to the blocked state while waiting for the job.

Process A is rescheduled by the scheduler. Process A has already read in = 7, loads its job name into slot 7, updates i to i + 1 = 9, and then goes to the blocked state while waiting for this job to finish.

How to Avoid Race Condition?

Mutual exclusion is a way to ensure that if one process is using a shared variable or file, other processes will be excluded from doing the same thing.

The choice of algorithm for achieving mutual exclusion is a major design issue in any operating system.

A solution for the race condition should meet the following four conditions:
1. No two processes may be simultaneously inside their critical regions – mutual exclusion.
2. No process running outside its critical region may block other processes.
3. No process should have to wait forever to enter the critical region.
4. No assumptions may be made about speeds or the number of CPUs.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park9/17/2024

Interprocess Communication (Race Condition)

Two approaches for mutual exclusion solutions:
1. Busy wait – A process will wait until the resource becomes available or the CPU time term expires.
2. Sleep and Wakeup – A process checks a resource; if it is not available, it goes to sleep. When the resource becomes available, the process is woken up by the system or the process releases the resource.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting

Each process has a time term. A process keeps checking the possibility to enter the critical section.

Mutual Exclusion with Busy Waiting includes:
- Disabling Interrupts – non-preemptive kernel
- Lock Variables
- Strict Alternation
- Peterson’s Solution
- Hardware Solutions
  - Test and Set Lock
  - Memory Barriers
  - Atomic Variable

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Disabling Interrupt – Nonprimitive Kernel)

Disabling Interrupt:
- Once a process enters the critical section, interrupts are set to disable.
- Other processes cannot get CPU time until the process finishes its job in the critical section.
- Since each user process has the power to control interrupts, it might cause the end of the system.
- We can build a simple program that can disable the entire system since the user has control over system interrupts (vulnerable system).

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Disabling Interrupt – Nonprimitive Kernel)
Example: End of the system with Disabling Interrupt
1. A process enters the critical section.
2. It disables all the interrupts, which means all other processes are sleeping until the job is done in the critical section.
3. The process is blocked outside the critical section just before enabling all the interrupts and never returns again, causing the end of the system.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Using Lock Variable)

There is a variable called "Lock":
- A process can enter its critical section when Lock = 0.
- Lock = 0 means no process is currently running in the critical section; set Lock = 1 and enter the critical section.
- Once a process finishes its job in the critical section, it sets Lock = 0 to let other processes into the critical section.
- Lock = 1 means there is a process running in the critical section, so a process will do busy waiting until Lock becomes 0.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Using Lock Variable)

static int lock = 0; // lock variable is initially 0
repeat
  while lock == 0 do
    ; // (no-operation) // Busy waiting
  lock = 1;
  lock = 0;
until false

Critical Section
Remainder Section9/17/2024

Mutual Exclusion with Busy Waiting (Using Lock Variable)
COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

static int lock = 0; // lock is initially 0
repeat
    while lock == 0 do
        ; // (no-operation) // busy waiting
    lock = 1;
    lock = 0;
until false

Critical Section
Remainder Section

Scenario:
1. Initially, lock = 0.
2. A process P1 tries to get into the critical section. The process P1 checks lock value = 0.
3. Process P1's CPU time is over and goes to ready state, before updating lock = 1.
4. Process P2 tries to get into the critical section. P2 checks lock value = 0.
5. P2 sets lock = 1 and goes to the critical section.
6. P2's CPU time is over and P1 is rescheduled.
7. P1 already read lock = 0, P1 sets lock = 1 and goes to the critical section. Now P1 and P2 are in the critical section at the same time, violating condition #1: mutual exclusion.

Mutual Exclusion with Busy Waiting (Strict Alternation)
- Variable turn can be i or j.
- If turn = i, process Pi can go to the critical section.
- Once Pi finishes its job in the critical section, Pi sets turn = j, allowing process Pj to enter the critical section.

turn is i or j
repeat
    while turn == i do
        ; // (no-operation)
    turn = j;
until false

Let us assume initially turn = 0
1. P0 is in CS while P1 is in the remainder section.
2. P0 finishes the critical section and sets turn = 1; P1 is still in the remainder section.
3. P0 finishes the remainder section and wants to go to CS, but turn = 1.
4. P1 has a fatal error in the remainder section and is trapped out by the OS.
5. P0 is waiting forever to enter the CS, violating conditions #2 and #3:
   2. No process running outside its critical region may block other processes.
   3. No process should have to wait forever to enter the critical region.

Mutual Exclusion with Busy Waiting (Peterson’s Solution)
- Peterson’s solution provides a good algorithmic description of solving the critical-section problem and illustrates some of the complexities involved in designing software that addresses the requirements of mutual exclusion, progress, and bounded waiting.
- Peterson’s solution is restricted to two processes that alternate execution between their critical sections and remainder sections.
- The processes are numbered P0 and P1. For convenience, when presenting Pi, we use Pj to denote the other process; that is, j equals 1 - i.

#define false 0
#define true 1
#define n 2
int turn;
int interested[n];

void enter_region(int process) {
    int other;
    other = 1 - process;
    interested[process] = true;
    turn = process;
    while (turn == process && interested[other] == true)
        ; /* no operation – busy waiting */
}

void leave_region(int process) {
    interested[process] = false;
}

void main() {
    repeat
        enter_region(int i);
        Critical Section;
        leave_region(int i);
        Remainder Section;
    until false;
}

Mutual Exclusion with Busy Waiting (Peterson’s Solution)
1. Initially, neither process is in the critical section.
2. A process P0 calls enter_region(0):
   a) Set interested[0] = true;
   b) Set turn = 0;
3. Go to the critical section.
4. The process P1 calls enter_region(1) to get into its critical section:
   a) Set interested[1] = true;
   b) Set turn = 1;
5. Since interested[0] = true, it keeps looping for interested[0] = false.
6. Finally, process P0 finishes its critical section and calls leave_region(0):
   1) Set interested[0] = false;
7. Now P1 finds out interested[0] = false, P1 goes to its critical section.9/17/2024

Mutual Exclusion with Busy Waiting (Peterson’s Solution)

To prove Peterson’s Solution, let's consider the case where both P0 and P1 call enter_region(0) and enter_region(1) almost simultaneously.

Let interest[0] = true and interest[1] = true at the same time. But turn can be only turn = 0 or turn = 1. Whichever store is done last is the one that counts!

Case 1: turn = 0
Inside enter_region(0):
- Since turn = 0 and interest[1] = true, P0 keeps looping in a no-operation until P1 sets interest[1] = false.

Inside enter_region(1):
- Since turn = 0 and interest[0] = true, P1 goes to its critical section.

Case 2: turn = 1
Inside enter_region(0):
- Since turn = 1 and interest[1] = true, P0 goes to its critical section.

Inside enter_region(1):
- Since turn = 1 and interest[0] = true, P1 keeps looping in a no-operation until P0 sets interest[0] = false.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Test and Set Lock – hardware solution)

Since the Test and Set Lock (TSL) instruction is a hardware instruction, the operations of reading the lock and storing into a register are guaranteed to be indivisible.

Instruction for test and set lock:
- TSL RX, LOCK
1. Read the content at the memory address of LOCK into register RX.
2. Store a non-zero value at the memory address of LOCK.

The operations of reading the content of LOCK and storing into it are guaranteed to be indivisible.

How to use the Test and Set Lock instruction for solving a race condition?
- When LOCK = 0, any process may set LOCK = 1 by using the TSL instruction and go to its critical section.
- When the process finishes its critical section, it sets LOCK = 0 using the original move instruction.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Enter_region:
- TSL Register, LOCK
- CMP Register, #0
- JNE Enter_region
- Set LOCK, #1
- RET

Leave_region:
- MOVE LOCK, #0
- RET

Repeat:
- Enter_region
- Leave_region until false

Critical Section
Remainder Section

Mutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)

Two general memory models:
1. Strongly ordered Memory – a memory modification on one processor is immediately visible to all other processors.
2. Weakly ordered Memory – a memory modification on one processor may not be immediately visible to other processors.

With strongly ordered memory, computer architectures provide instructions that can force any changes in memory to be propagated to all other processors, thereby ensuring that memory modifications are visible to threads (or processes) running on other processors.
Such instructions are known as memory barriers or memory fences.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

A memory barrier is a type of barrier instruction that causes a central processing unit (CPU) or compiler to enforce an ordering constraint on memory operations issued before and after the barrier instruction.
This typically means that operations issued prior to the barrier are guaranteed to be performed before operations issued after the barrier.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Example:
Let's assume two threads (or processes) are running on different parts of the program by sharing two variables: (bool flag = false; int x = 0;)
- Thread 1 might print 0 or 100 depending on the order of execution.
- By using a memory barrier instruction, Thread 1 will always print 100.

while (!flag)
    print x;
    x = 100;
    flag = true;
Thread 1
Thread 29/17/2024

Mutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)

- Now it is guaranteed that the value of flag is loaded before the value of x.
- Also, it is guaranteed that assignment to x occurs before the assignment to flag.
- Therefore, Thread 1 always prints 100.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

while (!flag)
    memory_barrier();
print x;
x = 100;
memory_barrier();
flag = true;

Thread 1
Thread 2

Mutual Exclusion with Busy Waiting (Atomic Variables – hardware solution)

- We can avoid mutual exclusion by using atomic operations.
- When a thread (or process) performs an atomic operation, the other threads (or processes) see it as happening instantaneously.
- The advantage of atomic operations is that they are relatively quick compared to locks and do not suffer from deadlock and convoying.
- The disadvantage is that they only perform a limited set of operations, and these are often insufficient to synthesize more complicated operations efficiently.
- Nonetheless, you should not pass up an opportunity to use an atomic operation in place of mutual exclusion.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Priority Inversion Problem)

- Peterson's solution, test and set lock, Memory Barrier, Atomic variable method – busy waiting – (wasting CPU time)

Priority Inversion problem with busy waiting method:

- Consider a computer with two processes: PH with high priority, and PL with low priority.
- The scheduling rules are such that PH gets CPU time whenever it is in the ready state (preemptive priority scheduling).

1. At time T0: PL is in the critical section, and PH is in the blocked state.
2. At time T1: PH changes state from blocked to ready state and tries to enter the critical section. PL is still in the critical section.
3. Based on the scheduling rule, the short-term scheduler selects PH; PH holds the CPU and tries to enter the critical section.
4. Since PL is in the critical section, PH runs busy waiting outside the critical section forever, as PL does not have a chance to get CPU time to finish its critical section.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Priority Inversion Problem)

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Block   Running   Ready
T0: 
PL: running state in critical section
PH: blocked state

PH
PL

Block   Running   Ready
PH
PL
T1: PH becomes ready state
PL: ready state in critical section
PH: ready state

The CPU scheduler will select the higher priority process.

Block   Running   Ready
PH
PL
T1>1
PL: ready state in critical section
PH: busy waiting in running state
PH becomes ready state

The scheduler keeps selecting PH since it has higher priority.

The scheduling rules: The CPU scheduler will always select the higher priority process.
2024-12-12 14:23:57 - INFO - Processing pages: 0, full_response: Yes
2024-12-12 14:23:57 - INFO - Created 1 tasks for question generation
2024-12-12 14:23:57 - INFO - Starting question_generate_chain
2024-12-12 14:23:57 - INFO - Setting up question generation chain
2024-12-12 14:23:57 - INFO - Chain type: <class 'langchain_core.runnables.base.RunnableSequence'>
2024-12-12 14:23:57 - INFO - Question generation chain setup complete
2024-12-12 14:24:02 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-12 14:24:02 - INFO - Generated 5 questions for Operating Systems with the following questions: [QAPair(question='Which of the following is NOT a solution for mutual exclusion in a critical section?', answer='Strict Alternation', q_type='multiple_choice', choices=['Disabling Interrupts', 'Lock Variables', 'Strict Alternation', 'Peterson’s Solution']), QAPair(question='A race condition occurs when two or more processes are reading or writing shared data, and the final result depends on the precise timing of their execution.', answer='True', q_type='TF', choices=['True', 'False']), QAPair(question='List and explain the four conditions that a solution for a race condition should meet.', answer='1. No two processes may be simultaneously inside their critical regions (mutual exclusion). 2. No process running outside its critical region may block other processes. 3. No process should have to wait forever to enter the critical region. 4. No assumptions may be made about speeds or the number of CPUs.', q_type='written', choices=[]), QAPair(question="Peterson's solution provides a mutual exclusion for how many processes?", answer='Two', q_type='multiple_choice', choices=['One', 'Two', 'Three', 'Four']), QAPair(question='Memory barriers are used to enforce ordering constraints on memory operations issued before and after the barrier instruction.', answer='True', q_type='TF', choices=['True', 'False'])]
2024-12-12 14:24:02 - INFO - Finished question_generate_chain
2024-12-12 14:24:02 - INFO - Completed question generation. Number of results: 1
2024-12-12 14:24:02 - INFO - Generated test list with 1 tests
2024-12-12 14:24:02 - INFO - Preparing judge_kwargs with 9 parameters
2024-12-12 14:24:02 - INFO - FINAL TEST:
{
    "questions": [
        {
            "question": "Which of the following is NOT a solution for mutual exclusion in a critical section?",
            "answer": "Strict Alternation",
            "q_type": "multiple_choice",
            "choices": [
                "Disabling Interrupts",
                "Lock Variables",
                "Strict Alternation",
                "Peterson\u2019s Solution"
            ]
        },
        {
            "question": "A race condition occurs when two or more processes are reading or writing shared data, and the final result depends on the precise timing of their execution.",
            "answer": "True",
            "q_type": "TF",
            "choices": [
                "True",
                "False"
            ]
        },
        {
            "question": "List and explain the four conditions that a solution for a race condition should meet.",
            "answer": "1. No two processes may be simultaneously inside their critical regions (mutual exclusion). 2. No process running outside its critical region may block other processes. 3. No process should have to wait forever to enter the critical region. 4. No assumptions may be made about speeds or the number of CPUs.",
            "q_type": "written",
            "choices": []
        },
        {
            "question": "Peterson's solution provides a mutual exclusion for how many processes?",
            "answer": "Two",
            "q_type": "multiple_choice",
            "choices": [
                "One",
                "Two",
                "Three",
                "Four"
            ]
        },
        {
            "question": "Memory barriers are used to enforce ordering constraints on memory operations issued before and after the barrier instruction.",
            "answer": "True",
            "q_type": "TF",
            "choices": [
                "True",
                "False"
            ]
        }
    ]
}
2024-12-12 14:24:02 - INFO - All tasks completed. Number of results: 1
2024-12-12 14:24:02 - INFO - Generated 1 tests
2024-12-12 14:24:02 - INFO - Cleaning up temp files
2024-12-12 14:24:02 - INFO - Deleted temp file: /tmp/tmp6trtu4ti
2024-12-12 14:24:02 - INFO - Temp files cleaned
2024-12-12 14:24:02 - INFO - Run function completed
2024-12-12 14:24:02 - INFO - Test generated successfully
2024-12-12 14:24:26 - INFO - POST request received for /generate
2024-12-12 14:24:26 - INFO - Form data: title='Operating Systems Test 1' course='Operating Systems' professor='Dr. Park' number_of_written_questions=1 number_of_mcq_questions=2 number_of_TF_questions=2 level='Normal' school_type='Undergraduate' difficulty='Extreme' testing_philosophy='I want a test which no student can pass' url_1=None url_2=None subject_material=[UploadFile(filename='450Slides10.pdf', size=166799, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides10.pdf"', 'content-type': 'application/pdf'}))]
2024-12-12 14:24:26 - INFO - Starting run function
2024-12-12 14:24:26 - INFO - Form data accessed
2024-12-12 14:24:26 - INFO - Form Title: Operating Systems Test 1
2024-12-12 14:24:26 - INFO - Form Course: Operating Systems
2024-12-12 14:24:26 - INFO - Form Professor: Dr. Park
2024-12-12 14:24:26 - INFO - Form Number of MCQ Questions: 2
2024-12-12 14:24:26 - INFO - Form Number of TF Questions: 2
2024-12-12 14:24:26 - INFO - Form Number of Written Questions: 1
2024-12-12 14:24:26 - INFO - Form School Type: Undergraduate
2024-12-12 14:24:26 - INFO - Form Difficulty: Extreme
2024-12-12 14:24:26 - INFO - Form Testing Philosophy: I want a test which no student can pass
2024-12-12 14:24:26 - INFO - Moving to files...
2024-12-12 14:24:26 - INFO - Starting to process files
2024-12-12 14:24:26 - INFO - Processing file: 450Slides10.pdf
2024-12-12 14:24:26 - INFO - Getting loader for file: UploadFile(filename='450Slides10.pdf', size=166799, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides10.pdf"', 'content-type': 'application/pdf'}))
2024-12-12 14:24:26 - INFO - File extension: .pdf
2024-12-12 14:24:26 - INFO - Processing PDF file: 450Slides10.pdf
2024-12-12 14:24:26 - INFO - Using loader type: PyMuPDFLoader for UploadFile(filename='450Slides10.pdf', size=166799, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides10.pdf"', 'content-type': 'application/pdf'}))
2024-12-12 14:24:26 - INFO - URLs: []
2024-12-12 14:24:26 - INFO - Processing 1 files and 0 URLs
2024-12-12 14:24:26 - INFO - Processing 450Slides10.pdf
2024-12-12 14:24:26 - INFO - Using loader type: PyMuPDFLoader for 450Slides10.pdf
2024-12-12 14:24:26 - INFO - Processing 450Slides10.pdf as a regular document using PyMuPDFLoader
2024-12-12 14:24:26 - INFO - Successfully loaded 5 documents from: 450Slides10.pdf
2024-12-12 14:24:26 - INFO - Docs: [Document(metadata={'source': '/tmp/tmpdbb69f28', 'file_path': '/tmp/tmpdbb69f28', 'page': 0, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n1\nPreview\nInter-Process Communication\n\ue007Race Condition\n\ue007Critical Section (or region)\n\ue007Solutions for Mutual Exclusion in a Critical Section\n◼With Busy Waiting\n\ue007Disabling Interrupts –non-preemptive kernel\n\ue007Lock Variables –violating the first necessary condition (mutual exclusion )\n\ue007Strict Alternation –violating the second necessary condition ( block by a process outside critical section)\n\ue007Peterson’s Solution\n\ue007Hardware Solution\n▪\nTest and Set Lock –\n▪\nMemory Barriers\n▪\nAtomic Variable\n\ue007Priority Inversion problems with busy waiting\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n1\nInterprocess Communication\n\ue007\nThree issues in interprocess communication\n1.\nHow one process can pass information to another (communication\nbetween processes) – with IPCS (shared memory, message queue,\nFIFO, PIPE, socket, …)\n2.\nHow to make sure two or more processes do not get into the\ncritical section (mutual exclusion)- with mutex, semaphore\n3.\nProper sequencing (Synchronization) when dependencies are\npresent (ex. A create outputs, B consume the outputs)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n2\nInterprocess Communication\n(Race Condition)\n\ue007Race Condition\n◼A situation where two or more processes are reading or writing some shared\ndata and the final result depends on who runs precisely when, are called race\ncondition.\n\ue007Critical section (critical region)\n◼The part of program where the shared memory is accessed.\n\ue007Mutual Exclusion in a critical section can avoid races condition:\n◼If we could arrange matters such that no two processes were ever in their\ncritical regions at the same time, we can avoid races condition.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n3\nInterprocess Communication\n(Race Condition)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n4\nSlots for file names\n• When a process want\nto print a file, it enter a\nfile name in a special\nspooler directory in\nprinter\n• Printer daemon\nperiodically check\nspooler directory any file\nneed to be printed.\nShared variable\nInterprocess Communication\n(Race Condition)\n\ue007\nProcess A tried to send a job to\nspooler, Process A read in = 7,\nprocess A time out and go to ready\nstate before updating in = in + 1.\n\ue007\nProcess B tried to send a job to\nspooler. Process B read in = 7, load\nits job name in slot 7, update i = i +\n1 = 8 and then go to block state for\nwaiting for job.\n\ue007\nProcess A is rescheduled by\nscheduler. Process A already read in\n= 7, Process A load its job name in\nslot 7, update i = i + 1 = 9 and then\ngo to blocked state waiting for this\njob finish.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n5\nInterprocess Communication\n(Race Condition)\n\ue007How to avoid race condition?\nMutual exclusion – some way of making sure that if one process is using a\nshared variable or file, the other processes will be excluded from doing the same\nthing.\n\ue007The choice of the algorithm for achieving mutual exclusion is a\nmajor design issue in any operating system.\n\ue007A solution for the race condition should have following four\nconditions\n1.\nNo two processes may be simultaneously inside their critical regions – mutual\nexclusion\n2.\nNo process running outside its critical region may block other processes\n3.\nNo process should have to wait forever to enter critical region\n4.\nNo assumptions may be made about speeds or the number of CPUs.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n6\n'), Document(metadata={'source': '/tmp/tmpdbb69f28', 'file_path': '/tmp/tmpdbb69f28', 'page': 1, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n2\nInterprocess Communication\n(Race Condition)\n\ue007Two approaches for mutual exclusion solutions.\n◼Busy wait – A process will wait until resource become available\nor CPU time term expired.\n◼Sleep and Wakeup – A process check a resource, if not available\ngo to sleep. When the resource become available, the process\nwill be waked up by system or the process release the resource.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n7\nMutual Exclusion with Busy Waiting\n\ue007Each process has time term. A process keep checking the\npossibility to get into critical section.\n\ue007Mutual Exclusion with Busy Waiting\n◼Disabling Interrupts –non-preemptive kernel\n◼Lock Variables\n◼Strict Alternation\n◼Peterson’s Solution\n◼Hardware Solutions\n\ue007Test and Set Lock\n\ue007Memory Barriers\n\ue007Atomic Variable\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n8\nMutual Exclusion with Busy Waiting\n(Disabling Interrupt – Nonprimitive Kernel)\nDisabling Interrupt\n\ue007Once a process get into the critical section, interrupts set to disable.\n\ue007Other process cannot get CPU time until the process finish its job in\nthe critical section.\n\ue007Since each user process has power to control interrupt, it might\ncause the end of system.\n\ue007We can build a simple program which can disable entire system\nsince user has control system interrupt. (vulnerable system)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n9\nMutual Exclusion with Busy Waiting\n(Disabling Interrupt – Nonprimitive Kernel)\nEx) End of the system with Disabling interrupt\n1. A process get into the critical section.\n2. It make disable all the interrupts – which means all\nother process are sleeping until the job is done in the\ncritical section.\n3. The process has blocked outside critical section just\nbefore make enable all the interrupts and never return\nagain, cause end of the system.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n10\nMutual Exclusion with Busy Waiting\n(Using Lock Variable)\n\ue007There are variable called “Lock”\n◼A process can enter in its critical section when Lock = 0.\n◼Lock =0 means no process is currently running in the critical\nsection, set Lock =1 and enter in the critical section.\n◼Once a process finish its job in critical section, set Lock = 0 and\nlet other process in the critical section\n◼Lock = 1 means there is a process running in the critical section,\na process do busy waiting until Lock become 0.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n11\nMutual Exclusion with Busy Waiting\n(Using Lock Variable)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n12\nstatic int lock = 0; //lock variable is initially 0\nrepeat\nwhile lock \ue0060do\n; (no-operation) // Busy waiting\nlock = 1;\nlock = 0;\nuntil false\nCritical Section\nRemainder Section\n'), Document(metadata={'source': '/tmp/tmpdbb69f28', 'file_path': '/tmp/tmpdbb69f28', 'page': 2, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n3\nMutual Exclusion with Busy Waiting\n(Using Lock Variable)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n13\nstatic int lock = 0; //lock is initially 0\nrepeat\nwhile lock \ue0060 do\n; (no-operation) //busy waiting\nlock = 1;\nlock = 0;\nuntil false\nCritical Section\nRemainder Section\nScenario)\n1.\nInitially lock = 0.\n2.\nA process P1 tries get into critical section.\nThe process P1 check lock value = 0.\n3.\nProcess P1 CPU time is over and go to\nready state, before updating lock = 1.\n4.\nProcess P2 tries get into critical section.\nP2 check lock value lock = 0\n5.\nP2 set lock = 1 and go to critical section.\n6.\nP2 CPU time is over and P1 is rescheduled.\n7.\nP1 already read lock = 0, P1 set lock = 1\nand go to Critical section. Now P1 and P2\nare in the critical section at the same\ntime\nViolating condition #1: mutual exclusion\nMutual Exclusion with Busy Waiting\n(Strict Alternation)\n\ue007Variable turn can be i or j.\n\ue007if turn = i, process Pi can go to the\ncritical section.\n\ue007Once Pi finish its job in critical\nsection, Pi set turn = j, let process\nPj enter critical section\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n14\nCritical Section\nRemainder Section\nturn is i or j\nrepeat\nwhile turn \ue006i do\n; (no-operation)\nturn = j;\nuntil false\nMutual Exclusion with Busy Waiting\n(Strict Alternation)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n15\nCritical Section\nRemainder Section\nturn is i or j\nrepeat\nwhile turn \ue006i do\n; (no-operation)\nturn = j;\nuntil false\nLet assume initially turn = 0\n1.\nP0 is in CS while P1 is in remaining\nsection.\n2.\nP0 done C.S. and set turn = 1, P1 is\nstill in remaining section.\n3.\nP0 done remaining section and want\nto go to C.S. but turn= 1.\n4.\nP1 has fatal error in remainder\nsection and trapped out by OS.\n5.\nP0 is waiting forever to enter the C.S.\nViolating #2 and #3 condition\n2.\nNo process running outside its critical\nregion may block other processes\n3.\nNo process should have to wait forever to\nenter critical region\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\n\ue007Peterson’s solution provides a good algorithmic description of\nsolving the critical-section problem and illustrates some of the\ncomplexities involved in designing software that addresses the\nrequirements of mutual exclusion, progress, and bounded waiting.\n\ue007Peterson’s solution is restricted to two processes that alternate\nexecution between their critical sections and remainder sections.\n\ue007The processes are numbered P0 and P1.\n\ue007For convenience, when presenting Pi, we use Pj to denote the other\nprocess; that is, j equals 1 −i.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n16\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n17\n#define false 0\n#define true 1\n#define n 2\nint turn\nint interested[n]\nvoid enter_region(int process);\n{\nint other;\nother = 1 – process\ninterested[process] = true\nturn = process;\nwhile (turn ==process && interest[other]==true)\n; /*no operation –busy waiting*/\n}\nvoid leave_region(int process)\n{\ninterest[process] = false;\n}\nvoid main()\n{\nrepeat\nenter_region (int i)\nCritical Section\nleave_resion (int i)\nRemainder Section\nuntil false\n}\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\n1.\nInitially, neither process is in the critical section\n2.\nA process P0 call enter_region (0)\na)\nSet interested[0] = true;\nb)\nSet turn = 0\n3.\ngo to critical section\n4.\nthe process P1 call enter_region(1) to get into its critical section\na)\nset interested[1] = true;\nb)\nset turn = 1;\n5.\nsince interested[0] = true, it is keep looping for interest [0] =\nfalse\n6.\nfinally process P0 finish its critical section and call leave_region(0)\n1.\nset interested[0] = false\n7.\nnow P1 find out interest[0] = false, P1 goes to its critical section\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n18\n'), Document(metadata={'source': '/tmp/tmpdbb69f28', 'file_path': '/tmp/tmpdbb69f28', 'page': 3, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n4\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\nProve for Peterson’s Solution)\n\ue007\nLets consider the case both P0 and P1 call enter_region(0) and enter_region(1) almost\nsimultaneously.\n\ue007\nLets interest[0]= true and interest[1] = true at the same time\n\ue007\nBut turn can be only turn = 0 or turn = 1 which ever store is done last is the one that\ncounts!!\nCase 1) turn = 0\nInside enter_region(0)\n◼\nSince turn =0 and interest [1] = ture, P0 keep looping in no-operation until P1 set interested[1] =\nfalse.\nInside enter_region(1)\n◼\nSince turn = 0 and interest[0] = true, P1 goes to its critical section.\nCase 2) turn = 1\nInside enter_region(0)\n◼\nSince turn =1 and interest [1] = ture,. P0 goes to its critical section\nInside enter_region(1)\n◼\nSince turn = 1 and interest[0] = true, P1 keep looping in no-operation until P0 set interested[0] =\nfalse.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n19\nMutual Exclusion with Busy Waiting\n(Test and Set Lock – hardware solution)\n\ue007\nSince TSL instruction is a hardware instruction. The operations of reading the\nlock and storing into register are guaranteed to be indivisible.\n\ue007\nInstruction test and set lock\nTSL RX, LOCK\n1. Read the content at the memory address of LOCK into register RX.\n2. Store a non-zero value at the memory address of LOCK\n\ue007\nThe operations of reading the content of LOCK and storing into it are guaranteed\nto be indivisible.\n\ue007\nHow to use Test and Set Lock instruction for solving race condition?\n◼\nWhen LOCK = 0, any process may set LOCK = 1 by using TSL instruction and go to\nits critical section.\n◼\nWhen the process finish its critical section, set LOCK = 0 using the original move\ninstruction.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n20\nMutual Exclusion with Busy Waiting\n(Test and Set Lock – hardware solution)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n21\nEnter_region\nTSL Register, LOCK\nCMP Register, #0\nJNE Enter_region\nSet LOCK, #1\nRET\nLeave_region\nMOVE LOCK, #0\nRET\nRepeat\nEnter_region\nLeave_region\nuntil false\nCritical Section\nRemainder Section\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\n\ue007Two general memory models\n◼Strongly ordered Memory –a memory modification on one processor is\nimmediately visible to all other processors\n◼Weakly ordered Memory – a memory modification on one processor may not\nbe immediately visible to other processors.\n\ue007With Strongly ordered memory, computer architectures provide\ninstructions that can force any changes in memory to be\npropagated to all other processors, thereby ensuring that memory\nmodifications are visible to threads (or processes) running on other\nprocessors.\n\ue007Such instructions are known as memory barriers or memory\nfences.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n22\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\n\ue007A memory barrier is a type of barrier instruction that causes a\ncentral processing unit (CPU) or compiler to enforce an ordering\nconstraint on memory operations issued before and after the\nbarrier instruction.\n\ue007This typically means that operations issued prior to the barrier are\nguaranteed to be performed before operations issued after the\nbarrier.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n23\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\nEx)\n\ue007Lets assume two threads (or processes) are running on different\npart of program by sharing two variables. (bool flag = false; int x=0;)\n\ue007Thread 1 might print 0 or 100 depends on the order of execution.\n\ue007By using memory barrier instruction Thread1 always print 100.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n24\nwhile (!flag)\nprint x;\nx = 100\nflag = true;\nThread 1\nThread 2\n'), Document(metadata={'source': '/tmp/tmpdbb69f28', 'file_path': '/tmp/tmpdbb69f28', 'page': 4, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content="9/17/2024\n5\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\n\ue007Now it is guarantee that the value of flag is loaded before the value of x\n\ue007Also it is guarantee that assignment to x occurs before the assignment to flag.\n\ue007So Thread 1 always print 100\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n25\nwhile (!flag)\nmemory_barrier();\nprint x;\nx = 100;\nmemory_barrier();\nflag = true;\nThread 1\nThread 2\nMutual Exclusion with Busy Waiting\n(Atomic Variables– hardware solution)\n\ue007We can avoid mutual exclusion by using atomic operations.\n\ue007When a thread (or process) performs an atomic operation, the\nother threads (or process) see it as happening instantaneously.\n\ue007The advantage of atomic operations is that they are relatively quick\ncompared to locks, and do not suffer from deadlock and convoying.\n\ue007The disadvantage is that they only do a limited set of operations,\nand often these are not enough to synthesize more complicated\noperations efficiently.\n\ue007But nonetheless you should not pass up an opportunity to use an\natomic operation in place of mutual exclusion.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n26\nMutual Exclusion with Busy Waiting\n(Priority Inversion Problem)\n\ue007Peterson's solution, test and set lock, Memory Barrier, Atomic variable method –\nbusy waiting – (wasting CPU time)\nPriority Inversion problem with busy waiting method\n\ue007A computer with two processes PH with high priorities, and PL with low priorities.\n\ue007The scheduling rules are such that PH get CPU time whenever it is in ready state.\n(preemptive priority scheduling)\n1. At a time T0: PL is in critical section, and PH is in block state.\n2. At a time T1: PH change sate from block to ready state and try to enter the critical\nsection. PL still in critical section.\n3. Based on scheduling rule, short-term scheduler select PH, PH hold CPU and try to enter\ninto critical section.\n4. Since PL is in critical section, PH run busy waiting outside critical section forever since\nPL does not have a chance to get CPU time to finish its critical section.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n27\nMutual Exclusion with Busy Waiting\n(Priority Inversion Problem)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n28\nBlock\nRunning\nReady\nT0 :\nPL: running state in critical section\nPH: block state\nPH\nPL\nBlock\nRunning\nReady\nPH\nPL\nT1 : PH become ready state\nPL: ready state in critical section\nPH: ready state\nCPU scheduler will select higher\npriority process\nBlock\nRunning\nReady\nPH\nPL\nTi>1\nPL: ready state in critical section\nPH: busy waiting in running state\nPH become ready state\nScheduler keep selecting\nPH since higher priority\nThe scheduling rules : CPU scheduler will always select higher priority process.\n")] for 450Slides10.pdf using PyMuPDFLoader
2024-12-12 14:24:26 - INFO - Document 1 (450Slides10.pdf) of 5
2024-12-12 14:24:26 - INFO - Starting clean_files_chain
2024-12-12 14:24:26 - INFO - Document: page_content='9/17/2024
1
Preview
Inter-Process Communication
Race Condition
Critical Section (or region)
Solutions for Mutual Exclusion in a Critical Section
◼With Busy Waiting
Disabling Interrupts –non-preemptive kernel
Lock Variables –violating the first necessary condition (mutual exclusion )
Strict Alternation –violating the second necessary condition ( block by a process outside critical section)
Peterson’s Solution
Hardware Solution
▪
Test and Set Lock –
▪
Memory Barriers
▪
Atomic Variable
Priority Inversion problems with busy waiting
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
1
Interprocess Communication

Three issues in interprocess communication
1.
How one process can pass information to another (communication
between processes) – with IPCS (shared memory, message queue,
FIFO, PIPE, socket, …)
2.
How to make sure two or more processes do not get into the
critical section (mutual exclusion)- with mutex, semaphore
3.
Proper sequencing (Synchronization) when dependencies are
present (ex. A create outputs, B consume the outputs)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
2
Interprocess Communication
(Race Condition)
Race Condition
◼A situation where two or more processes are reading or writing some shared
data and the final result depends on who runs precisely when, are called race
condition.
Critical section (critical region)
◼The part of program where the shared memory is accessed.
Mutual Exclusion in a critical section can avoid races condition:
◼If we could arrange matters such that no two processes were ever in their
critical regions at the same time, we can avoid races condition.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
3
Interprocess Communication
(Race Condition)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
4
Slots for file names
• When a process want
to print a file, it enter a
file name in a special
spooler directory in
printer
• Printer daemon
periodically check
spooler directory any file
need to be printed.
Shared variable
Interprocess Communication
(Race Condition)

Process A tried to send a job to
spooler, Process A read in = 7,
process A time out and go to ready
state before updating in = in + 1.

Process B tried to send a job to
spooler. Process B read in = 7, load
its job name in slot 7, update i = i +
1 = 8 and then go to block state for
waiting for job.

Process A is rescheduled by
scheduler. Process A already read in
= 7, Process A load its job name in
slot 7, update i = i + 1 = 9 and then
go to blocked state waiting for this
job finish.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
5
Interprocess Communication
(Race Condition)
How to avoid race condition?
Mutual exclusion – some way of making sure that if one process is using a
shared variable or file, the other processes will be excluded from doing the same
thing.
The choice of the algorithm for achieving mutual exclusion is a
major design issue in any operating system.
A solution for the race condition should have following four
conditions
1.
No two processes may be simultaneously inside their critical regions – mutual
exclusion
2.
No process running outside its critical region may block other processes
3.
No process should have to wait forever to enter critical region
4.
No assumptions may be made about speeds or the number of CPUs.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
6
' metadata={'source': '/tmp/tmpdbb69f28', 'file_path': '/tmp/tmpdbb69f28', 'page': 0, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-12 14:24:26 - INFO - Invoking chain
2024-12-12 14:24:33 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-12 14:24:33 - INFO - Response: {'cleaned_content': '9/17/2024\n\nInter-Process Communication\n\n- Race Condition\n- Critical Section (or region)\n- Solutions for Mutual Exclusion in a Critical Section\n  - With Busy Waiting\n    - Disabling Interrupts – non-preemptive kernel\n    - Lock Variables – violating the first necessary condition (mutual exclusion)\n    - Strict Alternation – violating the second necessary condition (block by a process outside critical section)\n    - Peterson’s Solution\n    - Hardware Solution\n      - Test and Set Lock\n      - Memory Barriers\n      - Atomic Variable\n- Priority Inversion problems with busy waiting\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nInterprocess Communication\n\nThree issues in interprocess communication:\n1. How one process can pass information to another (communication between processes) – with IPCS (shared memory, message queue, FIFO, PIPE, socket, …)\n2. How to make sure two or more processes do not get into the critical section (mutual exclusion) – with mutex, semaphore\n3. Proper sequencing (Synchronization) when dependencies are present (e.g., A create outputs, B consume the outputs)\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nInterprocess Communication (Race Condition)\n\n- Race Condition: A situation where two or more processes are reading or writing some shared data and the final result depends on who runs precisely when, are called race condition.\n- Critical section (critical region): The part of a program where the shared memory is accessed.\n- Mutual Exclusion in a critical section can avoid race conditions: If we could arrange matters such that no two processes were ever in their critical regions at the same time, we can avoid race conditions.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nSlots for file names:\n- When a process wants to print a file, it enters a file name in a special spooler directory in the printer.\n- The printer daemon periodically checks the spooler directory for any file that needs to be printed.\n\nShared variable\n\nInterprocess Communication (Race Condition)\n\n- Process A tries to send a job to the spooler. Process A reads in = 7, process A times out and goes to ready state before updating in = in + 1.\n- Process B tries to send a job to the spooler. Process B reads in = 7, loads its job name in slot 7, updates i = i + 1 = 8, and then goes to blocked state waiting for the job.\n- Process A is rescheduled by the scheduler. Process A has already read in = 7, Process A loads its job name in slot 7, updates i = i + 1 = 9, and then goes to blocked state waiting for this job to finish.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nInterprocess Communication (Race Condition)\n\n- How to avoid race conditions? Mutual exclusion – some way of making sure that if one process is using a shared variable or file, the other processes will be excluded from doing the same thing.\n- The choice of the algorithm for achieving mutual exclusion is a major design issue in any operating system.\n- A solution for the race condition should have the following four conditions:\n  1. No two processes may be simultaneously inside their critical regions – mutual exclusion.\n  2. No process running outside its critical region may block other processes.\n  3. No process should have to wait forever to enter the critical region.\n  4. No assumptions may be made about speeds or the number of CPUs.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park'}
2024-12-12 14:24:33 - INFO - Finished clean_files_chain
2024-12-12 14:24:33 - INFO - Successfully cleaned document 1 from 450Slides10.pdf
2024-12-12 14:24:33 - INFO - Document 2 (450Slides10.pdf) of 5
2024-12-12 14:24:33 - INFO - Starting clean_files_chain
2024-12-12 14:24:33 - INFO - Document: page_content='9/17/2024
2
Interprocess Communication
(Race Condition)
Two approaches for mutual exclusion solutions.
◼Busy wait – A process will wait until resource become available
or CPU time term expired.
◼Sleep and Wakeup – A process check a resource, if not available
go to sleep. When the resource become available, the process
will be waked up by system or the process release the resource.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
7
Mutual Exclusion with Busy Waiting
Each process has time term. A process keep checking the
possibility to get into critical section.
Mutual Exclusion with Busy Waiting
◼Disabling Interrupts –non-preemptive kernel
◼Lock Variables
◼Strict Alternation
◼Peterson’s Solution
◼Hardware Solutions
Test and Set Lock
Memory Barriers
Atomic Variable
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
8
Mutual Exclusion with Busy Waiting
(Disabling Interrupt – Nonprimitive Kernel)
Disabling Interrupt
Once a process get into the critical section, interrupts set to disable.
Other process cannot get CPU time until the process finish its job in
the critical section.
Since each user process has power to control interrupt, it might
cause the end of system.
We can build a simple program which can disable entire system
since user has control system interrupt. (vulnerable system)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
9
Mutual Exclusion with Busy Waiting
(Disabling Interrupt – Nonprimitive Kernel)
Ex) End of the system with Disabling interrupt
1. A process get into the critical section.
2. It make disable all the interrupts – which means all
other process are sleeping until the job is done in the
critical section.
3. The process has blocked outside critical section just
before make enable all the interrupts and never return
again, cause end of the system.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
10
Mutual Exclusion with Busy Waiting
(Using Lock Variable)
There are variable called “Lock”
◼A process can enter in its critical section when Lock = 0.
◼Lock =0 means no process is currently running in the critical
section, set Lock =1 and enter in the critical section.
◼Once a process finish its job in critical section, set Lock = 0 and
let other process in the critical section
◼Lock = 1 means there is a process running in the critical section,
a process do busy waiting until Lock become 0.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
11
Mutual Exclusion with Busy Waiting
(Using Lock Variable)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
12
static int lock = 0; //lock variable is initially 0
repeat
while lock 0do
; (no-operation) // Busy waiting
lock = 1;
lock = 0;
until false
Critical Section
Remainder Section
' metadata={'source': '/tmp/tmpdbb69f28', 'file_path': '/tmp/tmpdbb69f28', 'page': 1, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-12 14:24:33 - INFO - Invoking chain
2024-12-12 14:24:38 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-12 14:24:38 - INFO - Response: {'cleaned_content': "Date: 9/17/2024\n\nInterprocess Communication (Race Condition)\n\nThere are two approaches for mutual exclusion solutions:\n1. Busy wait – A process will wait until the resource becomes available or the CPU time term expires.\n2. Sleep and Wakeup – A process checks a resource, and if it is not available, it goes to sleep. When the resource becomes available, the process is woken up by the system or by the process that releases the resource.\n\nCourse: COSC450 Operating System, Fall 2024\nInstructor: Dr. Sang-Eon Park\n\n---\n\nMutual Exclusion with Busy Waiting\n\nEach process has a time term. A process keeps checking the possibility to enter the critical section. \n\nMethods of Mutual Exclusion with Busy Waiting:\n- Disabling Interrupts (non-preemptive kernel)\n- Lock Variables\n- Strict Alternation\n- Peterson’s Solution\n- Hardware Solutions\n- Test and Set Lock\n- Memory Barriers\n- Atomic Variable\n\n---\n\nMutual Exclusion with Busy Waiting (Disabling Interrupt – Nonprimitive Kernel)\n\nDisabling Interrupt:\n- Once a process enters the critical section, interrupts are disabled.\n- Other processes cannot get CPU time until the process finishes its job in the critical section.\n- Since each user process has the power to control interrupts, it might cause the end of the system.\n- We can create a simple program that disables the entire system since the user has control over system interrupts, resulting in a vulnerable system.\n\n---\n\nExample: End of the System with Disabling Interrupt\n1. A process enters the critical section.\n2. It disables all interrupts, meaning all other processes are sleeping until the job is done in the critical section.\n3. The process is blocked outside the critical section just before it enables all interrupts and never returns again, causing the end of the system.\n\nCourse: COSC450 Operating System, Fall 2024\nInstructor: Dr. Sang-Eon Park\n\n---\n\nMutual Exclusion with Busy Waiting (Using Lock Variable)\n\nThere is a variable called 'Lock':\n- A process can enter its critical section when Lock = 0.\n- Lock = 0 means no process is currently running in the critical section. The process sets Lock = 1 and enters the critical section.\n- Once a process finishes its job in the critical section, it sets Lock = 0 to allow other processes to enter the critical section.\n- Lock = 1 means there is a process running in the critical section, and a process does busy waiting until Lock becomes 0.\n\nCourse: COSC450 Operating System, Fall 2024\nInstructor: Dr. Sang-Eon Park\n\n---\n\nExample Code:\nstatic int lock = 0; // Lock variable is initially 0\nrepeat\n    while lock == 0 do\n        ; // (no-operation) // Busy waiting\n    lock = 1;\n    lock = 0;\nuntil false\n\nCritical Section\nRemainder Section"}
2024-12-12 14:24:38 - INFO - Finished clean_files_chain
2024-12-12 14:24:38 - INFO - Successfully cleaned document 2 from 450Slides10.pdf
2024-12-12 14:24:38 - INFO - Document 3 (450Slides10.pdf) of 5
2024-12-12 14:24:38 - INFO - Starting clean_files_chain
2024-12-12 14:24:38 - INFO - Document: page_content='9/17/2024
3
Mutual Exclusion with Busy Waiting
(Using Lock Variable)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
13
static int lock = 0; //lock is initially 0
repeat
while lock 0 do
; (no-operation) //busy waiting
lock = 1;
lock = 0;
until false
Critical Section
Remainder Section
Scenario)
1.
Initially lock = 0.
2.
A process P1 tries get into critical section.
The process P1 check lock value = 0.
3.
Process P1 CPU time is over and go to
ready state, before updating lock = 1.
4.
Process P2 tries get into critical section.
P2 check lock value lock = 0
5.
P2 set lock = 1 and go to critical section.
6.
P2 CPU time is over and P1 is rescheduled.
7.
P1 already read lock = 0, P1 set lock = 1
and go to Critical section. Now P1 and P2
are in the critical section at the same
time
Violating condition #1: mutual exclusion
Mutual Exclusion with Busy Waiting
(Strict Alternation)
Variable turn can be i or j.
if turn = i, process Pi can go to the
critical section.
Once Pi finish its job in critical
section, Pi set turn = j, let process
Pj enter critical section
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
14
Critical Section
Remainder Section
turn is i or j
repeat
while turn i do
; (no-operation)
turn = j;
until false
Mutual Exclusion with Busy Waiting
(Strict Alternation)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
15
Critical Section
Remainder Section
turn is i or j
repeat
while turn i do
; (no-operation)
turn = j;
until false
Let assume initially turn = 0
1.
P0 is in CS while P1 is in remaining
section.
2.
P0 done C.S. and set turn = 1, P1 is
still in remaining section.
3.
P0 done remaining section and want
to go to C.S. but turn= 1.
4.
P1 has fatal error in remainder
section and trapped out by OS.
5.
P0 is waiting forever to enter the C.S.
Violating #2 and #3 condition
2.
No process running outside its critical
region may block other processes
3.
No process should have to wait forever to
enter critical region
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
Peterson’s solution provides a good algorithmic description of
solving the critical-section problem and illustrates some of the
complexities involved in designing software that addresses the
requirements of mutual exclusion, progress, and bounded waiting.
Peterson’s solution is restricted to two processes that alternate
execution between their critical sections and remainder sections.
The processes are numbered P0 and P1.
For convenience, when presenting Pi, we use Pj to denote the other
process; that is, j equals 1 −i.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
16
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
17
#define false 0
#define true 1
#define n 2
int turn
int interested[n]
void enter_region(int process);
{
int other;
other = 1 – process
interested[process] = true
turn = process;
while (turn ==process && interest[other]==true)
; /*no operation –busy waiting*/
}
void leave_region(int process)
{
interest[process] = false;
}
void main()
{
repeat
enter_region (int i)
Critical Section
leave_resion (int i)
Remainder Section
until false
}
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
1.
Initially, neither process is in the critical section
2.
A process P0 call enter_region (0)
a)
Set interested[0] = true;
b)
Set turn = 0
3.
go to critical section
4.
the process P1 call enter_region(1) to get into its critical section
a)
set interested[1] = true;
b)
set turn = 1;
5.
since interested[0] = true, it is keep looping for interest [0] =
false
6.
finally process P0 finish its critical section and call leave_region(0)
1.
set interested[0] = false
7.
now P1 find out interest[0] = false, P1 goes to its critical section
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
18
' metadata={'source': '/tmp/tmpdbb69f28', 'file_path': '/tmp/tmpdbb69f28', 'page': 2, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-12 14:24:38 - INFO - Invoking chain
2024-12-12 14:24:46 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-12 14:24:46 - INFO - Response: {'cleaned_content': "9/17/2024\n\nMutual Exclusion with Busy Waiting (Using Lock Variable)\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nstatic int lock = 0; // lock is initially 0\n\nrepeat\n    while lock == 0 do\n        ; // (no-operation) // busy waiting\n    lock = 1;\n    lock = 0;\nuntil false\n\nCritical Section\nRemainder Section\n\nScenario:\n1. Initially lock = 0.\n2. A process P1 tries to get into the critical section. The process P1 checks lock value = 0.\n3. Process P1's CPU time is over and goes to the ready state, before updating lock = 1.\n4. Process P2 tries to get into the critical section. P2 checks lock value = 0.\n5. P2 sets lock = 1 and goes to the critical section.\n6. P2's CPU time is over and P1 is rescheduled.\n7. P1 already read lock = 0, P1 sets lock = 1 and goes to the critical section. Now P1 and P2 are in the critical section at the same time.\n\nViolating condition #1: mutual exclusion\n\nMutual Exclusion with Busy Waiting (Strict Alternation)\n- Variable turn can be i or j.\n- If turn = i, process Pi can go to the critical section.\n- Once Pi finishes its job in the critical section, Pi sets turn = j, letting process Pj enter the critical section.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nCritical Section\nRemainder Section\nturn is i or j\n\nrepeat\n    while turn == i do\n        ; // (no-operation)\n    turn = j;\nuntil false\n\nLet us assume initially turn = 0:\n1. P0 is in the critical section while P1 is in the remainder section.\n2. P0 finishes the critical section and sets turn = 1; P1 is still in the remainder section.\n3. P0 finishes the remainder section and wants to go to the critical section, but turn = 1.\n4. P1 has a fatal error in the remainder section and is trapped out by the operating system.\n5. P0 is waiting forever to enter the critical section.\n\nViolating conditions #2 and #3:\n2. No process running outside its critical region may block other processes.\n3. No process should have to wait forever to enter the critical region.\n\nMutual Exclusion with Busy Waiting (Peterson’s Solution)\n- Peterson’s solution provides a good algorithmic description of solving the critical-section problem and illustrates some of the complexities involved in designing software that addresses the requirements of mutual exclusion, progress, and bounded waiting.\n- Peterson’s solution is restricted to two processes that alternate execution between their critical sections and remainder sections.\n- The processes are numbered P0 and P1.\n- For convenience, when presenting Pi, we use Pj to denote the other process; that is, j equals 1 − i.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\n#define false 0\n#define true 1\n#define n 2\nint turn;\nint interested[n];\n\nvoid enter_region(int process) {\n    int other;\n    other = 1 - process;\n    interested[process] = true;\n    turn = process;\n    while (turn == process && interested[other] == true)\n        ; // no operation – busy waiting\n}\n\nvoid leave_region(int process) {\n    interested[process] = false;\n}\n\nvoid main() {\n    repeat\n        enter_region(i);\n        // Critical Section\n        leave_region(i);\n        // Remainder Section\n    until false;\n}\n\nMutual Exclusion with Busy Waiting (Peterson’s Solution)\n1. Initially, neither process is in the critical section.\n2. A process P0 calls enter_region(0):\n   a) Set interested[0] = true;\n   b) Set turn = 0;\n3. P0 goes to the critical section.\n4. The process P1 calls enter_region(1) to get into its critical section:\n   a) Set interested[1] = true;\n   b) Set turn = 1;\n5. Since interested[0] = true, it keeps looping for interested[0] = false.\n6. Finally, process P0 finishes its critical section and calls leave_region(0):\n   1. Set interested[0] = false;\n7. Now P1 finds interest[0] = false, and P1 goes to its critical section.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park"}
2024-12-12 14:24:46 - INFO - Finished clean_files_chain
2024-12-12 14:24:46 - INFO - Successfully cleaned document 3 from 450Slides10.pdf
2024-12-12 14:24:46 - INFO - Document 4 (450Slides10.pdf) of 5
2024-12-12 14:24:46 - INFO - Starting clean_files_chain
2024-12-12 14:24:46 - INFO - Document: page_content='9/17/2024
4
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
Prove for Peterson’s Solution)

Lets consider the case both P0 and P1 call enter_region(0) and enter_region(1) almost
simultaneously.

Lets interest[0]= true and interest[1] = true at the same time

But turn can be only turn = 0 or turn = 1 which ever store is done last is the one that
counts!!
Case 1) turn = 0
Inside enter_region(0)
◼
Since turn =0 and interest [1] = ture, P0 keep looping in no-operation until P1 set interested[1] =
false.
Inside enter_region(1)
◼
Since turn = 0 and interest[0] = true, P1 goes to its critical section.
Case 2) turn = 1
Inside enter_region(0)
◼
Since turn =1 and interest [1] = ture,. P0 goes to its critical section
Inside enter_region(1)
◼
Since turn = 1 and interest[0] = true, P1 keep looping in no-operation until P0 set interested[0] =
false.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
19
Mutual Exclusion with Busy Waiting
(Test and Set Lock – hardware solution)

Since TSL instruction is a hardware instruction. The operations of reading the
lock and storing into register are guaranteed to be indivisible.

Instruction test and set lock
TSL RX, LOCK
1. Read the content at the memory address of LOCK into register RX.
2. Store a non-zero value at the memory address of LOCK

The operations of reading the content of LOCK and storing into it are guaranteed
to be indivisible.

How to use Test and Set Lock instruction for solving race condition?
◼
When LOCK = 0, any process may set LOCK = 1 by using TSL instruction and go to
its critical section.
◼
When the process finish its critical section, set LOCK = 0 using the original move
instruction.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
20
Mutual Exclusion with Busy Waiting
(Test and Set Lock – hardware solution)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
21
Enter_region
TSL Register, LOCK
CMP Register, #0
JNE Enter_region
Set LOCK, #1
RET
Leave_region
MOVE LOCK, #0
RET
Repeat
Enter_region
Leave_region
until false
Critical Section
Remainder Section
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
Two general memory models
◼Strongly ordered Memory –a memory modification on one processor is
immediately visible to all other processors
◼Weakly ordered Memory – a memory modification on one processor may not
be immediately visible to other processors.
With Strongly ordered memory, computer architectures provide
instructions that can force any changes in memory to be
propagated to all other processors, thereby ensuring that memory
modifications are visible to threads (or processes) running on other
processors.
Such instructions are known as memory barriers or memory
fences.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
22
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
A memory barrier is a type of barrier instruction that causes a
central processing unit (CPU) or compiler to enforce an ordering
constraint on memory operations issued before and after the
barrier instruction.
This typically means that operations issued prior to the barrier are
guaranteed to be performed before operations issued after the
barrier.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
23
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
Ex)
Lets assume two threads (or processes) are running on different
part of program by sharing two variables. (bool flag = false; int x=0;)
Thread 1 might print 0 or 100 depends on the order of execution.
By using memory barrier instruction Thread1 always print 100.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
24
while (!flag)
print x;
x = 100
flag = true;
Thread 1
Thread 2
' metadata={'source': '/tmp/tmpdbb69f28', 'file_path': '/tmp/tmpdbb69f28', 'page': 3, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-12 14:24:46 - INFO - Invoking chain
2024-12-12 14:24:55 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-12 14:24:55 - INFO - Response: {'cleaned_content': "9/17/2024\n\nMutual Exclusion with Busy Waiting (Peterson’s Solution)\n\nProve for Peterson’s Solution:\n\nLet's consider the case where both P0 and P1 call enter_region(0) and enter_region(1) almost simultaneously.\n\nLet's assume interest[0] = true and interest[1] = true at the same time.\n\nHowever, turn can only be either turn = 0 or turn = 1; whichever store is done last is the one that counts!\n\nCase 1: turn = 0\n- Inside enter_region(0):\n  - Since turn = 0 and interest[1] = true, P0 keeps looping in a no-operation until P1 sets interest[1] = false.\n- Inside enter_region(1):\n  - Since turn = 0 and interest[0] = true, P1 goes to its critical section.\n\nCase 2: turn = 1\n- Inside enter_region(0):\n  - Since turn = 1 and interest[1] = true, P0 goes to its critical section.\n- Inside enter_region(1):\n  - Since turn = 1 and interest[0] = true, P1 keeps looping in a no-operation until P0 sets interest[0] = false.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Test and Set Lock – hardware solution)\n\nSince the TSL (Test and Set Lock) instruction is a hardware instruction, the operations of reading the lock and storing into a register are guaranteed to be indivisible.\n\nInstruction: test and set lock\n- TSL RX, LOCK\n1. Read the content at the memory address of LOCK into register RX.\n2. Store a non-zero value at the memory address of LOCK.\n\nThe operations of reading the content of LOCK and storing into it are guaranteed to be indivisible.\n\nHow to use the Test and Set Lock instruction for solving race conditions:\n- When LOCK = 0, any process may set LOCK = 1 by using the TSL instruction and go to its critical section.\n- When the process finishes its critical section, it sets LOCK = 0 using the original move instruction.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nEnter_region:\n- TSL Register, LOCK\n- CMP Register, #0\n- JNE Enter_region\n- Set LOCK, #1\n- RET\n\nLeave_region:\n- MOVE LOCK, #0\n- RET\n\nRepeat:\n- Enter_region\n- Leave_region\nuntil false\n\nCritical Section\nRemainder Section\n\nMutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)\n\nThere are two general memory models:\n1. Strongly ordered Memory – a memory modification on one processor is immediately visible to all other processors.\n2. Weakly ordered Memory – a memory modification on one processor may not be immediately visible to other processors.\n\nWith Strongly ordered memory, computer architectures provide instructions that can force any changes in memory to be propagated to all other processors, thereby ensuring that memory modifications are visible to threads (or processes) running on other processors.\n\nSuch instructions are known as memory barriers or memory fences.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nA memory barrier is a type of barrier instruction that causes a central processing unit (CPU) or compiler to enforce an ordering constraint on memory operations issued before and after the barrier instruction.\n\nThis typically means that operations issued prior to the barrier are guaranteed to be performed before operations issued after the barrier.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nExample:\nLet's assume two threads (or processes) are running on different parts of a program by sharing two variables: (bool flag = false; int x = 0;)\n\nThread 1 might print 0 or 100 depending on the order of execution.\n\nBy using memory barrier instruction, Thread 1 always prints 100.\n\nwhile (!flag)\nprint x;\nx = 100;\nflag = true;\n\nThread 1\nThread 2"}
2024-12-12 14:24:55 - INFO - Finished clean_files_chain
2024-12-12 14:24:55 - INFO - Successfully cleaned document 4 from 450Slides10.pdf
2024-12-12 14:24:55 - INFO - Document 5 (450Slides10.pdf) of 5
2024-12-12 14:24:55 - INFO - Starting clean_files_chain
2024-12-12 14:24:55 - INFO - Document: page_content='9/17/2024
5
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
Now it is guarantee that the value of flag is loaded before the value of x
Also it is guarantee that assignment to x occurs before the assignment to flag.
So Thread 1 always print 100
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
25
while (!flag)
memory_barrier();
print x;
x = 100;
memory_barrier();
flag = true;
Thread 1
Thread 2
Mutual Exclusion with Busy Waiting
(Atomic Variables– hardware solution)
We can avoid mutual exclusion by using atomic operations.
When a thread (or process) performs an atomic operation, the
other threads (or process) see it as happening instantaneously.
The advantage of atomic operations is that they are relatively quick
compared to locks, and do not suffer from deadlock and convoying.
The disadvantage is that they only do a limited set of operations,
and often these are not enough to synthesize more complicated
operations efficiently.
But nonetheless you should not pass up an opportunity to use an
atomic operation in place of mutual exclusion.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
26
Mutual Exclusion with Busy Waiting
(Priority Inversion Problem)
Peterson's solution, test and set lock, Memory Barrier, Atomic variable method –
busy waiting – (wasting CPU time)
Priority Inversion problem with busy waiting method
A computer with two processes PH with high priorities, and PL with low priorities.
The scheduling rules are such that PH get CPU time whenever it is in ready state.
(preemptive priority scheduling)
1. At a time T0: PL is in critical section, and PH is in block state.
2. At a time T1: PH change sate from block to ready state and try to enter the critical
section. PL still in critical section.
3. Based on scheduling rule, short-term scheduler select PH, PH hold CPU and try to enter
into critical section.
4. Since PL is in critical section, PH run busy waiting outside critical section forever since
PL does not have a chance to get CPU time to finish its critical section.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
27
Mutual Exclusion with Busy Waiting
(Priority Inversion Problem)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
28
Block
Running
Ready
T0 :
PL: running state in critical section
PH: block state
PH
PL
Block
Running
Ready
PH
PL
T1 : PH become ready state
PL: ready state in critical section
PH: ready state
CPU scheduler will select higher
priority process
Block
Running
Ready
PH
PL
Ti>1
PL: ready state in critical section
PH: busy waiting in running state
PH become ready state
Scheduler keep selecting
PH since higher priority
The scheduling rules : CPU scheduler will always select higher priority process.
' metadata={'source': '/tmp/tmpdbb69f28', 'file_path': '/tmp/tmpdbb69f28', 'page': 4, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-12 14:24:55 - INFO - Invoking chain
2024-12-12 14:25:01 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-12 14:25:01 - INFO - Response: {'cleaned_content': "9/17/2024\n\nMutual Exclusion with Busy Waiting (Memory Barriers – Hardware Solution)\n- It is guaranteed that the value of flag is loaded before the value of x.\n- It is also guaranteed that the assignment to x occurs before the assignment to flag.\n- Therefore, Thread 1 always prints 100.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nwhile (!flag) {\n    memory_barrier();\n}\nprint x;\n\nx = 100;\nmemory_barrier();\nflag = true;\n\nThread 1\nThread 2\n\nMutual Exclusion with Busy Waiting (Atomic Variables – Hardware Solution)\n- We can avoid mutual exclusion by using atomic operations.\n- When a thread (or process) performs an atomic operation, the other threads (or processes) see it as happening instantaneously.\n- The advantage of atomic operations is that they are relatively quick compared to locks and do not suffer from deadlock and convoying.\n- The disadvantage is that they only perform a limited set of operations, which are often not sufficient to synthesize more complicated operations efficiently.\n- Nevertheless, you should not miss the opportunity to use an atomic operation in place of mutual exclusion.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Priority Inversion Problem)\n- Peterson's solution, test and set lock, memory barrier, and atomic variable method all result in busy waiting, which wastes CPU time.\n\nPriority Inversion Problem with Busy Waiting Method:\n- Consider a computer with two processes: PH with high priority and PL with low priority.\n- The scheduling rules ensure that PH gets CPU time whenever it is in the ready state (preemptive priority scheduling).\n\n1. At time T0: PL is in the critical section, and PH is in the blocked state.\n2. At time T1: PH changes state from blocked to ready and tries to enter the critical section. PL is still in the critical section.\n3. According to the scheduling rule, the short-term scheduler selects PH. PH holds the CPU and attempts to enter the critical section.\n4. Since PL is in the critical section, PH runs in busy waiting outside the critical section indefinitely because PL does not have a chance to get CPU time to finish its critical section.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Priority Inversion Problem)\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nState Transitions:\n- T0: \n  PL: running state in critical section\n  PH: blocked state\n\n- T1: \n  PH becomes ready state\n  PL: ready state in critical section\n  PH: ready state\n\nThe CPU scheduler will select the higher priority process.\n\n- Ti>1: \n  PL: ready state in critical section\n  PH: busy waiting in running state\n  PH becomes ready state\n\nThe scheduler continues to select PH since it has higher priority.\n\nThe scheduling rules state that the CPU scheduler will always select the higher priority process."}
2024-12-12 14:25:01 - INFO - Finished clean_files_chain
2024-12-12 14:25:01 - INFO - Successfully cleaned document 5 from 450Slides10.pdf
2024-12-12 14:25:01 - INFO - Pages: []
2024-12-12 14:25:01 - INFO - Full response: 9/17/2024

Inter-Process Communication

- Race Condition
- Critical Section (or region)
- Solutions for Mutual Exclusion in a Critical Section
  - With Busy Waiting
    - Disabling Interrupts – non-preemptive kernel
    - Lock Variables – violating the first necessary condition (mutual exclusion)
    - Strict Alternation – violating the second necessary condition (block by a process outside critical section)
    - Peterson’s Solution
    - Hardware Solution
      - Test and Set Lock
      - Memory Barriers
      - Atomic Variable
- Priority Inversion problems with busy waiting

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Interprocess Communication

Three issues in interprocess communication:
1. How one process can pass information to another (communication between processes) – with IPCS (shared memory, message queue, FIFO, PIPE, socket, …)
2. How to make sure two or more processes do not get into the critical section (mutual exclusion) – with mutex, semaphore
3. Proper sequencing (Synchronization) when dependencies are present (e.g., A create outputs, B consume the outputs)

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Interprocess Communication (Race Condition)

- Race Condition: A situation where two or more processes are reading or writing some shared data and the final result depends on who runs precisely when, are called race condition.
- Critical section (critical region): The part of a program where the shared memory is accessed.
- Mutual Exclusion in a critical section can avoid race conditions: If we could arrange matters such that no two processes were ever in their critical regions at the same time, we can avoid race conditions.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Slots for file names:
- When a process wants to print a file, it enters a file name in a special spooler directory in the printer.
- The printer daemon periodically checks the spooler directory for any file that needs to be printed.

Shared variable

Interprocess Communication (Race Condition)

- Process A tries to send a job to the spooler. Process A reads in = 7, process A times out and goes to ready state before updating in = in + 1.
- Process B tries to send a job to the spooler. Process B reads in = 7, loads its job name in slot 7, updates i = i + 1 = 8, and then goes to blocked state waiting for the job.
- Process A is rescheduled by the scheduler. Process A has already read in = 7, Process A loads its job name in slot 7, updates i = i + 1 = 9, and then goes to blocked state waiting for this job to finish.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Interprocess Communication (Race Condition)

- How to avoid race conditions? Mutual exclusion – some way of making sure that if one process is using a shared variable or file, the other processes will be excluded from doing the same thing.
- The choice of the algorithm for achieving mutual exclusion is a major design issue in any operating system.
- A solution for the race condition should have the following four conditions:
  1. No two processes may be simultaneously inside their critical regions – mutual exclusion.
  2. No process running outside its critical region may block other processes.
  3. No process should have to wait forever to enter the critical region.
  4. No assumptions may be made about speeds or the number of CPUs.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon ParkDate: 9/17/2024

Interprocess Communication (Race Condition)

There are two approaches for mutual exclusion solutions:
1. Busy wait – A process will wait until the resource becomes available or the CPU time term expires.
2. Sleep and Wakeup – A process checks a resource, and if it is not available, it goes to sleep. When the resource becomes available, the process is woken up by the system or by the process that releases the resource.

Course: COSC450 Operating System, Fall 2024
Instructor: Dr. Sang-Eon Park

---

Mutual Exclusion with Busy Waiting

Each process has a time term. A process keeps checking the possibility to enter the critical section. 

Methods of Mutual Exclusion with Busy Waiting:
- Disabling Interrupts (non-preemptive kernel)
- Lock Variables
- Strict Alternation
- Peterson’s Solution
- Hardware Solutions
- Test and Set Lock
- Memory Barriers
- Atomic Variable

---

Mutual Exclusion with Busy Waiting (Disabling Interrupt – Nonprimitive Kernel)

Disabling Interrupt:
- Once a process enters the critical section, interrupts are disabled.
- Other processes cannot get CPU time until the process finishes its job in the critical section.
- Since each user process has the power to control interrupts, it might cause the end of the system.
- We can create a simple program that disables the entire system since the user has control over system interrupts, resulting in a vulnerable system.

---

Example: End of the System with Disabling Interrupt
1. A process enters the critical section.
2. It disables all interrupts, meaning all other processes are sleeping until the job is done in the critical section.
3. The process is blocked outside the critical section just before it enables all interrupts and never returns again, causing the end of the system.

Course: COSC450 Operating System, Fall 2024
Instructor: Dr. Sang-Eon Park

---

Mutual Exclusion with Busy Waiting (Using Lock Variable)

There is a variable called 'Lock':
- A process can enter its critical section when Lock = 0.
- Lock = 0 means no process is currently running in the critical section. The process sets Lock = 1 and enters the critical section.
- Once a process finishes its job in the critical section, it sets Lock = 0 to allow other processes to enter the critical section.
- Lock = 1 means there is a process running in the critical section, and a process does busy waiting until Lock becomes 0.

Course: COSC450 Operating System, Fall 2024
Instructor: Dr. Sang-Eon Park

---

Example Code:
static int lock = 0; // Lock variable is initially 0
repeat
    while lock == 0 do
        ; // (no-operation) // Busy waiting
    lock = 1;
    lock = 0;
until false

Critical Section
Remainder Section9/17/2024

Mutual Exclusion with Busy Waiting (Using Lock Variable)
COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

static int lock = 0; // lock is initially 0

repeat
    while lock == 0 do
        ; // (no-operation) // busy waiting
    lock = 1;
    lock = 0;
until false

Critical Section
Remainder Section

Scenario:
1. Initially lock = 0.
2. A process P1 tries to get into the critical section. The process P1 checks lock value = 0.
3. Process P1's CPU time is over and goes to the ready state, before updating lock = 1.
4. Process P2 tries to get into the critical section. P2 checks lock value = 0.
5. P2 sets lock = 1 and goes to the critical section.
6. P2's CPU time is over and P1 is rescheduled.
7. P1 already read lock = 0, P1 sets lock = 1 and goes to the critical section. Now P1 and P2 are in the critical section at the same time.

Violating condition #1: mutual exclusion

Mutual Exclusion with Busy Waiting (Strict Alternation)
- Variable turn can be i or j.
- If turn = i, process Pi can go to the critical section.
- Once Pi finishes its job in the critical section, Pi sets turn = j, letting process Pj enter the critical section.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Critical Section
Remainder Section
turn is i or j

repeat
    while turn == i do
        ; // (no-operation)
    turn = j;
until false

Let us assume initially turn = 0:
1. P0 is in the critical section while P1 is in the remainder section.
2. P0 finishes the critical section and sets turn = 1; P1 is still in the remainder section.
3. P0 finishes the remainder section and wants to go to the critical section, but turn = 1.
4. P1 has a fatal error in the remainder section and is trapped out by the operating system.
5. P0 is waiting forever to enter the critical section.

Violating conditions #2 and #3:
2. No process running outside its critical region may block other processes.
3. No process should have to wait forever to enter the critical region.

Mutual Exclusion with Busy Waiting (Peterson’s Solution)
- Peterson’s solution provides a good algorithmic description of solving the critical-section problem and illustrates some of the complexities involved in designing software that addresses the requirements of mutual exclusion, progress, and bounded waiting.
- Peterson’s solution is restricted to two processes that alternate execution between their critical sections and remainder sections.
- The processes are numbered P0 and P1.
- For convenience, when presenting Pi, we use Pj to denote the other process; that is, j equals 1 − i.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

#define false 0
#define true 1
#define n 2
int turn;
int interested[n];

void enter_region(int process) {
    int other;
    other = 1 - process;
    interested[process] = true;
    turn = process;
    while (turn == process && interested[other] == true)
        ; // no operation – busy waiting
}

void leave_region(int process) {
    interested[process] = false;
}

void main() {
    repeat
        enter_region(i);
        // Critical Section
        leave_region(i);
        // Remainder Section
    until false;
}

Mutual Exclusion with Busy Waiting (Peterson’s Solution)
1. Initially, neither process is in the critical section.
2. A process P0 calls enter_region(0):
   a) Set interested[0] = true;
   b) Set turn = 0;
3. P0 goes to the critical section.
4. The process P1 calls enter_region(1) to get into its critical section:
   a) Set interested[1] = true;
   b) Set turn = 1;
5. Since interested[0] = true, it keeps looping for interested[0] = false.
6. Finally, process P0 finishes its critical section and calls leave_region(0):
   1. Set interested[0] = false;
7. Now P1 finds interest[0] = false, and P1 goes to its critical section.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park9/17/2024

Mutual Exclusion with Busy Waiting (Peterson’s Solution)

Prove for Peterson’s Solution:

Let's consider the case where both P0 and P1 call enter_region(0) and enter_region(1) almost simultaneously.

Let's assume interest[0] = true and interest[1] = true at the same time.

However, turn can only be either turn = 0 or turn = 1; whichever store is done last is the one that counts!

Case 1: turn = 0
- Inside enter_region(0):
  - Since turn = 0 and interest[1] = true, P0 keeps looping in a no-operation until P1 sets interest[1] = false.
- Inside enter_region(1):
  - Since turn = 0 and interest[0] = true, P1 goes to its critical section.

Case 2: turn = 1
- Inside enter_region(0):
  - Since turn = 1 and interest[1] = true, P0 goes to its critical section.
- Inside enter_region(1):
  - Since turn = 1 and interest[0] = true, P1 keeps looping in a no-operation until P0 sets interest[0] = false.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Test and Set Lock – hardware solution)

Since the TSL (Test and Set Lock) instruction is a hardware instruction, the operations of reading the lock and storing into a register are guaranteed to be indivisible.

Instruction: test and set lock
- TSL RX, LOCK
1. Read the content at the memory address of LOCK into register RX.
2. Store a non-zero value at the memory address of LOCK.

The operations of reading the content of LOCK and storing into it are guaranteed to be indivisible.

How to use the Test and Set Lock instruction for solving race conditions:
- When LOCK = 0, any process may set LOCK = 1 by using the TSL instruction and go to its critical section.
- When the process finishes its critical section, it sets LOCK = 0 using the original move instruction.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Enter_region:
- TSL Register, LOCK
- CMP Register, #0
- JNE Enter_region
- Set LOCK, #1
- RET

Leave_region:
- MOVE LOCK, #0
- RET

Repeat:
- Enter_region
- Leave_region
until false

Critical Section
Remainder Section

Mutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)

There are two general memory models:
1. Strongly ordered Memory – a memory modification on one processor is immediately visible to all other processors.
2. Weakly ordered Memory – a memory modification on one processor may not be immediately visible to other processors.

With Strongly ordered memory, computer architectures provide instructions that can force any changes in memory to be propagated to all other processors, thereby ensuring that memory modifications are visible to threads (or processes) running on other processors.

Such instructions are known as memory barriers or memory fences.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

A memory barrier is a type of barrier instruction that causes a central processing unit (CPU) or compiler to enforce an ordering constraint on memory operations issued before and after the barrier instruction.

This typically means that operations issued prior to the barrier are guaranteed to be performed before operations issued after the barrier.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Example:
Let's assume two threads (or processes) are running on different parts of a program by sharing two variables: (bool flag = false; int x = 0;)

Thread 1 might print 0 or 100 depending on the order of execution.

By using memory barrier instruction, Thread 1 always prints 100.

while (!flag)
print x;
x = 100;
flag = true;

Thread 1
Thread 29/17/2024

Mutual Exclusion with Busy Waiting (Memory Barriers – Hardware Solution)
- It is guaranteed that the value of flag is loaded before the value of x.
- It is also guaranteed that the assignment to x occurs before the assignment to flag.
- Therefore, Thread 1 always prints 100.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

while (!flag) {
    memory_barrier();
}
print x;

x = 100;
memory_barrier();
flag = true;

Thread 1
Thread 2

Mutual Exclusion with Busy Waiting (Atomic Variables – Hardware Solution)
- We can avoid mutual exclusion by using atomic operations.
- When a thread (or process) performs an atomic operation, the other threads (or processes) see it as happening instantaneously.
- The advantage of atomic operations is that they are relatively quick compared to locks and do not suffer from deadlock and convoying.
- The disadvantage is that they only perform a limited set of operations, which are often not sufficient to synthesize more complicated operations efficiently.
- Nevertheless, you should not miss the opportunity to use an atomic operation in place of mutual exclusion.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Priority Inversion Problem)
- Peterson's solution, test and set lock, memory barrier, and atomic variable method all result in busy waiting, which wastes CPU time.

Priority Inversion Problem with Busy Waiting Method:
- Consider a computer with two processes: PH with high priority and PL with low priority.
- The scheduling rules ensure that PH gets CPU time whenever it is in the ready state (preemptive priority scheduling).

1. At time T0: PL is in the critical section, and PH is in the blocked state.
2. At time T1: PH changes state from blocked to ready and tries to enter the critical section. PL is still in the critical section.
3. According to the scheduling rule, the short-term scheduler selects PH. PH holds the CPU and attempts to enter the critical section.
4. Since PL is in the critical section, PH runs in busy waiting outside the critical section indefinitely because PL does not have a chance to get CPU time to finish its critical section.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Priority Inversion Problem)

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

State Transitions:
- T0: 
  PL: running state in critical section
  PH: blocked state

- T1: 
  PH becomes ready state
  PL: ready state in critical section
  PH: ready state

The CPU scheduler will select the higher priority process.

- Ti>1: 
  PL: ready state in critical section
  PH: busy waiting in running state
  PH becomes ready state

The scheduler continues to select PH since it has higher priority.

The scheduling rules state that the CPU scheduler will always select the higher priority process.
2024-12-12 14:25:01 - INFO - Processing pages: 0, full_response: Yes
2024-12-12 14:25:01 - INFO - Created 1 tasks for question generation
2024-12-12 14:25:01 - INFO - Starting question_generate_chain
2024-12-12 14:25:01 - INFO - Setting up question generation chain
2024-12-12 14:25:01 - INFO - Chain type: <class 'langchain_core.runnables.base.RunnableSequence'>
2024-12-12 14:25:01 - INFO - Question generation chain setup complete
2024-12-12 14:25:07 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-12 14:25:07 - INFO - Generated 5 questions for Operating Systems with the following questions: [QAPair(question='Which of the following is NOT a method of achieving mutual exclusion with busy waiting?', answer='Sleep and Wakeup', q_type='multiple_choice', choices=['Disabling Interrupts', 'Lock Variables', 'Strict Alternation', 'Sleep and Wakeup']), QAPair(question="Peterson's solution is a method designed to achieve mutual exclusion for how many processes?", answer='Two', q_type='multiple_choice', choices=['One', 'Two', 'Three', 'Infinite']), QAPair(question='A race condition occurs when two or more processes access shared data simultaneously, and the final outcome depends on the sequence of execution.', answer='True', q_type='TF', choices=['True', 'False']), QAPair(question='Mutual exclusion can be achieved through solutions that ensure no two processes are simultaneously in their critical regions.', answer='True', q_type='TF', choices=['True', 'False']), QAPair(question='Discuss the concept of race conditions in inter-process communication and how mutual exclusion can mitigate their effects.', answer='Race conditions occur when multiple processes read and write shared data, leading to unpredictable results based on execution timing. To mitigate race conditions, mutual exclusion ensures that only one process can access the critical section at a time, thereby preventing simultaneous access and ensuring data consistency.', q_type='written', choices=[])]
2024-12-12 14:25:07 - INFO - Finished question_generate_chain
2024-12-12 14:25:07 - INFO - Completed question generation. Number of results: 1
2024-12-12 14:25:07 - INFO - Generated test list with 1 tests
2024-12-12 14:25:07 - INFO - Preparing judge_kwargs with 9 parameters
2024-12-12 14:25:07 - INFO - FINAL TEST:
{
    "questions": [
        {
            "question": "Which of the following is NOT a method of achieving mutual exclusion with busy waiting?",
            "answer": "Sleep and Wakeup",
            "q_type": "multiple_choice",
            "choices": [
                "Disabling Interrupts",
                "Lock Variables",
                "Strict Alternation",
                "Sleep and Wakeup"
            ]
        },
        {
            "question": "Peterson's solution is a method designed to achieve mutual exclusion for how many processes?",
            "answer": "Two",
            "q_type": "multiple_choice",
            "choices": [
                "One",
                "Two",
                "Three",
                "Infinite"
            ]
        },
        {
            "question": "A race condition occurs when two or more processes access shared data simultaneously, and the final outcome depends on the sequence of execution.",
            "answer": "True",
            "q_type": "TF",
            "choices": [
                "True",
                "False"
            ]
        },
        {
            "question": "Mutual exclusion can be achieved through solutions that ensure no two processes are simultaneously in their critical regions.",
            "answer": "True",
            "q_type": "TF",
            "choices": [
                "True",
                "False"
            ]
        },
        {
            "question": "Discuss the concept of race conditions in inter-process communication and how mutual exclusion can mitigate their effects.",
            "answer": "Race conditions occur when multiple processes read and write shared data, leading to unpredictable results based on execution timing. To mitigate race conditions, mutual exclusion ensures that only one process can access the critical section at a time, thereby preventing simultaneous access and ensuring data consistency.",
            "q_type": "written",
            "choices": []
        }
    ]
}
2024-12-12 14:25:07 - INFO - All tasks completed. Number of results: 1
2024-12-12 14:25:07 - INFO - Generated 1 tests
2024-12-12 14:25:07 - INFO - Cleaning up temp files
2024-12-12 14:25:07 - INFO - Deleted temp file: /tmp/tmpdbb69f28
2024-12-12 14:25:07 - INFO - Temp files cleaned
2024-12-12 14:25:07 - INFO - Run function completed
2024-12-12 14:25:07 - INFO - Test generated successfully
