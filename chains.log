2024-12-19 01:08:09 - INFO - Static files mounted
2024-12-19 01:08:09 - INFO - toLetter filter added to Jinja2 environment
2024-12-19 01:08:46 - INFO - GET request received for index page
2024-12-19 01:10:23 - INFO - POST request received for /generate
2024-12-19 01:10:23 - INFO - Form data: title='Operating Systems Test 1' course='Operating Systems' professor='Dr. Park' number_of_written_questions=4 number_of_mcq_questions=2 number_of_TF_questions=2 level='Normal' school_type='Undergraduate' difficulty='Extreme' testing_philosophy='I believe is extrememly hard tests to counter act rising grade inflation no one except the best students should get As in a class C is Average' url_1=None url_2=None subject_material=[UploadFile(filename='450Slides9.pdf', size=233626, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides9.pdf"', 'content-type': 'application/pdf'})), UploadFile(filename='450Slides11.pdf', size=343833, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides11.pdf"', 'content-type': 'application/pdf'})), UploadFile(filename='cosc450_11.pdf', size=343833, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="cosc450_11.pdf"', 'content-type': 'application/pdf'})), UploadFile(filename='450Slides10.pdf', size=166799, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides10.pdf"', 'content-type': 'application/pdf'}))]
2024-12-19 01:10:23 - INFO - Starting run function
2024-12-19 01:10:23 - INFO - Form data accessed
2024-12-19 01:10:23 - INFO - Form Title: Operating Systems Test 1
2024-12-19 01:10:23 - INFO - Form Course: Operating Systems
2024-12-19 01:10:23 - INFO - Form Professor: Dr. Park
2024-12-19 01:10:23 - INFO - Form Number of MCQ Questions: 2
2024-12-19 01:10:23 - INFO - Form Number of TF Questions: 2
2024-12-19 01:10:23 - INFO - Form Number of Written Questions: 4
2024-12-19 01:10:23 - INFO - Form School Type: Undergraduate
2024-12-19 01:10:23 - INFO - Form Difficulty: Extreme
2024-12-19 01:10:23 - INFO - Form Testing Philosophy: I believe is extrememly hard tests to counter act rising grade inflation no one except the best students should get As in a class C is Average
2024-12-19 01:10:23 - INFO - Moving to files...
2024-12-19 01:10:23 - INFO - Starting to process files
2024-12-19 01:10:23 - INFO - Processing file: 450Slides9.pdf
2024-12-19 01:10:23 - INFO - Getting loader for file: UploadFile(filename='450Slides9.pdf', size=233626, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides9.pdf"', 'content-type': 'application/pdf'}))
2024-12-19 01:10:23 - INFO - File extension: .pdf
2024-12-19 01:10:23 - INFO - Processing PDF file: 450Slides9.pdf
2024-12-19 01:10:24 - INFO - Using loader type: PyMuPDFLoader for UploadFile(filename='450Slides9.pdf', size=233626, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides9.pdf"', 'content-type': 'application/pdf'}))
2024-12-19 01:10:24 - INFO - Processing file: 450Slides11.pdf
2024-12-19 01:10:24 - INFO - Getting loader for file: UploadFile(filename='450Slides11.pdf', size=343833, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides11.pdf"', 'content-type': 'application/pdf'}))
2024-12-19 01:10:24 - INFO - File extension: .pdf
2024-12-19 01:10:24 - INFO - Processing PDF file: 450Slides11.pdf
2024-12-19 01:10:24 - INFO - Using loader type: PyMuPDFLoader for UploadFile(filename='450Slides11.pdf', size=343833, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides11.pdf"', 'content-type': 'application/pdf'}))
2024-12-19 01:10:24 - INFO - Processing file: cosc450_11.pdf
2024-12-19 01:10:24 - INFO - Getting loader for file: UploadFile(filename='cosc450_11.pdf', size=343833, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="cosc450_11.pdf"', 'content-type': 'application/pdf'}))
2024-12-19 01:10:24 - INFO - File extension: .pdf
2024-12-19 01:10:24 - INFO - Processing PDF file: cosc450_11.pdf
2024-12-19 01:10:24 - INFO - Using loader type: PyMuPDFLoader for UploadFile(filename='cosc450_11.pdf', size=343833, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="cosc450_11.pdf"', 'content-type': 'application/pdf'}))
2024-12-19 01:10:24 - INFO - Processing file: 450Slides10.pdf
2024-12-19 01:10:24 - INFO - Getting loader for file: UploadFile(filename='450Slides10.pdf', size=166799, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides10.pdf"', 'content-type': 'application/pdf'}))
2024-12-19 01:10:24 - INFO - File extension: .pdf
2024-12-19 01:10:24 - INFO - Processing PDF file: 450Slides10.pdf
2024-12-19 01:10:24 - INFO - Using loader type: PyMuPDFLoader for UploadFile(filename='450Slides10.pdf', size=166799, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides10.pdf"', 'content-type': 'application/pdf'}))
2024-12-19 01:10:24 - INFO - URLs: []
2024-12-19 01:10:24 - INFO - Processing 4 files and 0 URLs
2024-12-19 01:10:24 - INFO - Processing 450Slides9.pdf
2024-12-19 01:10:24 - INFO - Using loader type: PyMuPDFLoader for 450Slides9.pdf
2024-12-19 01:10:24 - INFO - Processing 450Slides9.pdf as a regular document using PyMuPDFLoader
2024-12-19 01:10:24 - INFO - Processing 450Slides11.pdf
2024-12-19 01:10:24 - INFO - Using loader type: PyMuPDFLoader for 450Slides11.pdf
2024-12-19 01:10:24 - INFO - Processing 450Slides11.pdf as a regular document using PyMuPDFLoader
2024-12-19 01:10:24 - INFO - Processing cosc450_11.pdf
2024-12-19 01:10:24 - INFO - Using loader type: PyMuPDFLoader for cosc450_11.pdf
2024-12-19 01:10:24 - INFO - Processing cosc450_11.pdf as a regular document using PyMuPDFLoader
2024-12-19 01:10:24 - INFO - Processing 450Slides10.pdf
2024-12-19 01:10:24 - INFO - Using loader type: PyMuPDFLoader for 450Slides10.pdf
2024-12-19 01:10:24 - INFO - Processing 450Slides10.pdf as a regular document using PyMuPDFLoader
2024-12-19 01:10:24 - INFO - Successfully loaded 5 documents from: 450Slides10.pdf
2024-12-19 01:10:24 - INFO - Docs: [Document(metadata={'source': '/tmp/tmp50p_945n', 'file_path': '/tmp/tmp50p_945n', 'page': 0, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n1\nPreview\nInter-Process Communication\n\ue007Race Condition\n\ue007Critical Section (or region)\n\ue007Solutions for Mutual Exclusion in a Critical Section\n◼With Busy Waiting\n\ue007Disabling Interrupts –non-preemptive kernel\n\ue007Lock Variables –violating the first necessary condition (mutual exclusion )\n\ue007Strict Alternation –violating the second necessary condition ( block by a process outside critical section)\n\ue007Peterson’s Solution\n\ue007Hardware Solution\n▪\nTest and Set Lock –\n▪\nMemory Barriers\n▪\nAtomic Variable\n\ue007Priority Inversion problems with busy waiting\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n1\nInterprocess Communication\n\ue007\nThree issues in interprocess communication\n1.\nHow one process can pass information to another (communication\nbetween processes) – with IPCS (shared memory, message queue,\nFIFO, PIPE, socket, …)\n2.\nHow to make sure two or more processes do not get into the\ncritical section (mutual exclusion)- with mutex, semaphore\n3.\nProper sequencing (Synchronization) when dependencies are\npresent (ex. A create outputs, B consume the outputs)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n2\nInterprocess Communication\n(Race Condition)\n\ue007Race Condition\n◼A situation where two or more processes are reading or writing some shared\ndata and the final result depends on who runs precisely when, are called race\ncondition.\n\ue007Critical section (critical region)\n◼The part of program where the shared memory is accessed.\n\ue007Mutual Exclusion in a critical section can avoid races condition:\n◼If we could arrange matters such that no two processes were ever in their\ncritical regions at the same time, we can avoid races condition.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n3\nInterprocess Communication\n(Race Condition)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n4\nSlots for file names\n• When a process want\nto print a file, it enter a\nfile name in a special\nspooler directory in\nprinter\n• Printer daemon\nperiodically check\nspooler directory any file\nneed to be printed.\nShared variable\nInterprocess Communication\n(Race Condition)\n\ue007\nProcess A tried to send a job to\nspooler, Process A read in = 7,\nprocess A time out and go to ready\nstate before updating in = in + 1.\n\ue007\nProcess B tried to send a job to\nspooler. Process B read in = 7, load\nits job name in slot 7, update i = i +\n1 = 8 and then go to block state for\nwaiting for job.\n\ue007\nProcess A is rescheduled by\nscheduler. Process A already read in\n= 7, Process A load its job name in\nslot 7, update i = i + 1 = 9 and then\ngo to blocked state waiting for this\njob finish.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n5\nInterprocess Communication\n(Race Condition)\n\ue007How to avoid race condition?\nMutual exclusion – some way of making sure that if one process is using a\nshared variable or file, the other processes will be excluded from doing the same\nthing.\n\ue007The choice of the algorithm for achieving mutual exclusion is a\nmajor design issue in any operating system.\n\ue007A solution for the race condition should have following four\nconditions\n1.\nNo two processes may be simultaneously inside their critical regions – mutual\nexclusion\n2.\nNo process running outside its critical region may block other processes\n3.\nNo process should have to wait forever to enter critical region\n4.\nNo assumptions may be made about speeds or the number of CPUs.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n6\n'), Document(metadata={'source': '/tmp/tmp50p_945n', 'file_path': '/tmp/tmp50p_945n', 'page': 1, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n2\nInterprocess Communication\n(Race Condition)\n\ue007Two approaches for mutual exclusion solutions.\n◼Busy wait – A process will wait until resource become available\nor CPU time term expired.\n◼Sleep and Wakeup – A process check a resource, if not available\ngo to sleep. When the resource become available, the process\nwill be waked up by system or the process release the resource.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n7\nMutual Exclusion with Busy Waiting\n\ue007Each process has time term. A process keep checking the\npossibility to get into critical section.\n\ue007Mutual Exclusion with Busy Waiting\n◼Disabling Interrupts –non-preemptive kernel\n◼Lock Variables\n◼Strict Alternation\n◼Peterson’s Solution\n◼Hardware Solutions\n\ue007Test and Set Lock\n\ue007Memory Barriers\n\ue007Atomic Variable\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n8\nMutual Exclusion with Busy Waiting\n(Disabling Interrupt – Nonprimitive Kernel)\nDisabling Interrupt\n\ue007Once a process get into the critical section, interrupts set to disable.\n\ue007Other process cannot get CPU time until the process finish its job in\nthe critical section.\n\ue007Since each user process has power to control interrupt, it might\ncause the end of system.\n\ue007We can build a simple program which can disable entire system\nsince user has control system interrupt. (vulnerable system)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n9\nMutual Exclusion with Busy Waiting\n(Disabling Interrupt – Nonprimitive Kernel)\nEx) End of the system with Disabling interrupt\n1. A process get into the critical section.\n2. It make disable all the interrupts – which means all\nother process are sleeping until the job is done in the\ncritical section.\n3. The process has blocked outside critical section just\nbefore make enable all the interrupts and never return\nagain, cause end of the system.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n10\nMutual Exclusion with Busy Waiting\n(Using Lock Variable)\n\ue007There are variable called “Lock”\n◼A process can enter in its critical section when Lock = 0.\n◼Lock =0 means no process is currently running in the critical\nsection, set Lock =1 and enter in the critical section.\n◼Once a process finish its job in critical section, set Lock = 0 and\nlet other process in the critical section\n◼Lock = 1 means there is a process running in the critical section,\na process do busy waiting until Lock become 0.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n11\nMutual Exclusion with Busy Waiting\n(Using Lock Variable)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n12\nstatic int lock = 0; //lock variable is initially 0\nrepeat\nwhile lock \ue0060do\n; (no-operation) // Busy waiting\nlock = 1;\nlock = 0;\nuntil false\nCritical Section\nRemainder Section\n'), Document(metadata={'source': '/tmp/tmp50p_945n', 'file_path': '/tmp/tmp50p_945n', 'page': 2, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n3\nMutual Exclusion with Busy Waiting\n(Using Lock Variable)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n13\nstatic int lock = 0; //lock is initially 0\nrepeat\nwhile lock \ue0060 do\n; (no-operation) //busy waiting\nlock = 1;\nlock = 0;\nuntil false\nCritical Section\nRemainder Section\nScenario)\n1.\nInitially lock = 0.\n2.\nA process P1 tries get into critical section.\nThe process P1 check lock value = 0.\n3.\nProcess P1 CPU time is over and go to\nready state, before updating lock = 1.\n4.\nProcess P2 tries get into critical section.\nP2 check lock value lock = 0\n5.\nP2 set lock = 1 and go to critical section.\n6.\nP2 CPU time is over and P1 is rescheduled.\n7.\nP1 already read lock = 0, P1 set lock = 1\nand go to Critical section. Now P1 and P2\nare in the critical section at the same\ntime\nViolating condition #1: mutual exclusion\nMutual Exclusion with Busy Waiting\n(Strict Alternation)\n\ue007Variable turn can be i or j.\n\ue007if turn = i, process Pi can go to the\ncritical section.\n\ue007Once Pi finish its job in critical\nsection, Pi set turn = j, let process\nPj enter critical section\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n14\nCritical Section\nRemainder Section\nturn is i or j\nrepeat\nwhile turn \ue006i do\n; (no-operation)\nturn = j;\nuntil false\nMutual Exclusion with Busy Waiting\n(Strict Alternation)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n15\nCritical Section\nRemainder Section\nturn is i or j\nrepeat\nwhile turn \ue006i do\n; (no-operation)\nturn = j;\nuntil false\nLet assume initially turn = 0\n1.\nP0 is in CS while P1 is in remaining\nsection.\n2.\nP0 done C.S. and set turn = 1, P1 is\nstill in remaining section.\n3.\nP0 done remaining section and want\nto go to C.S. but turn= 1.\n4.\nP1 has fatal error in remainder\nsection and trapped out by OS.\n5.\nP0 is waiting forever to enter the C.S.\nViolating #2 and #3 condition\n2.\nNo process running outside its critical\nregion may block other processes\n3.\nNo process should have to wait forever to\nenter critical region\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\n\ue007Peterson’s solution provides a good algorithmic description of\nsolving the critical-section problem and illustrates some of the\ncomplexities involved in designing software that addresses the\nrequirements of mutual exclusion, progress, and bounded waiting.\n\ue007Peterson’s solution is restricted to two processes that alternate\nexecution between their critical sections and remainder sections.\n\ue007The processes are numbered P0 and P1.\n\ue007For convenience, when presenting Pi, we use Pj to denote the other\nprocess; that is, j equals 1 −i.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n16\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n17\n#define false 0\n#define true 1\n#define n 2\nint turn\nint interested[n]\nvoid enter_region(int process);\n{\nint other;\nother = 1 – process\ninterested[process] = true\nturn = process;\nwhile (turn ==process && interest[other]==true)\n; /*no operation –busy waiting*/\n}\nvoid leave_region(int process)\n{\ninterest[process] = false;\n}\nvoid main()\n{\nrepeat\nenter_region (int i)\nCritical Section\nleave_resion (int i)\nRemainder Section\nuntil false\n}\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\n1.\nInitially, neither process is in the critical section\n2.\nA process P0 call enter_region (0)\na)\nSet interested[0] = true;\nb)\nSet turn = 0\n3.\ngo to critical section\n4.\nthe process P1 call enter_region(1) to get into its critical section\na)\nset interested[1] = true;\nb)\nset turn = 1;\n5.\nsince interested[0] = true, it is keep looping for interest [0] =\nfalse\n6.\nfinally process P0 finish its critical section and call leave_region(0)\n1.\nset interested[0] = false\n7.\nnow P1 find out interest[0] = false, P1 goes to its critical section\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n18\n'), Document(metadata={'source': '/tmp/tmp50p_945n', 'file_path': '/tmp/tmp50p_945n', 'page': 3, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n4\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\nProve for Peterson’s Solution)\n\ue007\nLets consider the case both P0 and P1 call enter_region(0) and enter_region(1) almost\nsimultaneously.\n\ue007\nLets interest[0]= true and interest[1] = true at the same time\n\ue007\nBut turn can be only turn = 0 or turn = 1 which ever store is done last is the one that\ncounts!!\nCase 1) turn = 0\nInside enter_region(0)\n◼\nSince turn =0 and interest [1] = ture, P0 keep looping in no-operation until P1 set interested[1] =\nfalse.\nInside enter_region(1)\n◼\nSince turn = 0 and interest[0] = true, P1 goes to its critical section.\nCase 2) turn = 1\nInside enter_region(0)\n◼\nSince turn =1 and interest [1] = ture,. P0 goes to its critical section\nInside enter_region(1)\n◼\nSince turn = 1 and interest[0] = true, P1 keep looping in no-operation until P0 set interested[0] =\nfalse.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n19\nMutual Exclusion with Busy Waiting\n(Test and Set Lock – hardware solution)\n\ue007\nSince TSL instruction is a hardware instruction. The operations of reading the\nlock and storing into register are guaranteed to be indivisible.\n\ue007\nInstruction test and set lock\nTSL RX, LOCK\n1. Read the content at the memory address of LOCK into register RX.\n2. Store a non-zero value at the memory address of LOCK\n\ue007\nThe operations of reading the content of LOCK and storing into it are guaranteed\nto be indivisible.\n\ue007\nHow to use Test and Set Lock instruction for solving race condition?\n◼\nWhen LOCK = 0, any process may set LOCK = 1 by using TSL instruction and go to\nits critical section.\n◼\nWhen the process finish its critical section, set LOCK = 0 using the original move\ninstruction.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n20\nMutual Exclusion with Busy Waiting\n(Test and Set Lock – hardware solution)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n21\nEnter_region\nTSL Register, LOCK\nCMP Register, #0\nJNE Enter_region\nSet LOCK, #1\nRET\nLeave_region\nMOVE LOCK, #0\nRET\nRepeat\nEnter_region\nLeave_region\nuntil false\nCritical Section\nRemainder Section\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\n\ue007Two general memory models\n◼Strongly ordered Memory –a memory modification on one processor is\nimmediately visible to all other processors\n◼Weakly ordered Memory – a memory modification on one processor may not\nbe immediately visible to other processors.\n\ue007With Strongly ordered memory, computer architectures provide\ninstructions that can force any changes in memory to be\npropagated to all other processors, thereby ensuring that memory\nmodifications are visible to threads (or processes) running on other\nprocessors.\n\ue007Such instructions are known as memory barriers or memory\nfences.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n22\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\n\ue007A memory barrier is a type of barrier instruction that causes a\ncentral processing unit (CPU) or compiler to enforce an ordering\nconstraint on memory operations issued before and after the\nbarrier instruction.\n\ue007This typically means that operations issued prior to the barrier are\nguaranteed to be performed before operations issued after the\nbarrier.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n23\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\nEx)\n\ue007Lets assume two threads (or processes) are running on different\npart of program by sharing two variables. (bool flag = false; int x=0;)\n\ue007Thread 1 might print 0 or 100 depends on the order of execution.\n\ue007By using memory barrier instruction Thread1 always print 100.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n24\nwhile (!flag)\nprint x;\nx = 100\nflag = true;\nThread 1\nThread 2\n'), Document(metadata={'source': '/tmp/tmp50p_945n', 'file_path': '/tmp/tmp50p_945n', 'page': 4, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content="9/17/2024\n5\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\n\ue007Now it is guarantee that the value of flag is loaded before the value of x\n\ue007Also it is guarantee that assignment to x occurs before the assignment to flag.\n\ue007So Thread 1 always print 100\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n25\nwhile (!flag)\nmemory_barrier();\nprint x;\nx = 100;\nmemory_barrier();\nflag = true;\nThread 1\nThread 2\nMutual Exclusion with Busy Waiting\n(Atomic Variables– hardware solution)\n\ue007We can avoid mutual exclusion by using atomic operations.\n\ue007When a thread (or process) performs an atomic operation, the\nother threads (or process) see it as happening instantaneously.\n\ue007The advantage of atomic operations is that they are relatively quick\ncompared to locks, and do not suffer from deadlock and convoying.\n\ue007The disadvantage is that they only do a limited set of operations,\nand often these are not enough to synthesize more complicated\noperations efficiently.\n\ue007But nonetheless you should not pass up an opportunity to use an\natomic operation in place of mutual exclusion.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n26\nMutual Exclusion with Busy Waiting\n(Priority Inversion Problem)\n\ue007Peterson's solution, test and set lock, Memory Barrier, Atomic variable method –\nbusy waiting – (wasting CPU time)\nPriority Inversion problem with busy waiting method\n\ue007A computer with two processes PH with high priorities, and PL with low priorities.\n\ue007The scheduling rules are such that PH get CPU time whenever it is in ready state.\n(preemptive priority scheduling)\n1. At a time T0: PL is in critical section, and PH is in block state.\n2. At a time T1: PH change sate from block to ready state and try to enter the critical\nsection. PL still in critical section.\n3. Based on scheduling rule, short-term scheduler select PH, PH hold CPU and try to enter\ninto critical section.\n4. Since PL is in critical section, PH run busy waiting outside critical section forever since\nPL does not have a chance to get CPU time to finish its critical section.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n27\nMutual Exclusion with Busy Waiting\n(Priority Inversion Problem)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n28\nBlock\nRunning\nReady\nT0 :\nPL: running state in critical section\nPH: block state\nPH\nPL\nBlock\nRunning\nReady\nPH\nPL\nT1 : PH become ready state\nPL: ready state in critical section\nPH: ready state\nCPU scheduler will select higher\npriority process\nBlock\nRunning\nReady\nPH\nPL\nTi>1\nPL: ready state in critical section\nPH: busy waiting in running state\nPH become ready state\nScheduler keep selecting\nPH since higher priority\nThe scheduling rules : CPU scheduler will always select higher priority process.\n")] for 450Slides10.pdf using PyMuPDFLoader
2024-12-19 01:10:24 - INFO - Document 1 (450Slides10.pdf) of 5
2024-12-19 01:10:24 - INFO - Starting clean_files_chain
2024-12-19 01:10:24 - INFO - Document: page_content='9/17/2024
1
Preview
Inter-Process Communication
Race Condition
Critical Section (or region)
Solutions for Mutual Exclusion in a Critical Section
◼With Busy Waiting
Disabling Interrupts –non-preemptive kernel
Lock Variables –violating the first necessary condition (mutual exclusion )
Strict Alternation –violating the second necessary condition ( block by a process outside critical section)
Peterson’s Solution
Hardware Solution
▪
Test and Set Lock –
▪
Memory Barriers
▪
Atomic Variable
Priority Inversion problems with busy waiting
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
1
Interprocess Communication

Three issues in interprocess communication
1.
How one process can pass information to another (communication
between processes) – with IPCS (shared memory, message queue,
FIFO, PIPE, socket, …)
2.
How to make sure two or more processes do not get into the
critical section (mutual exclusion)- with mutex, semaphore
3.
Proper sequencing (Synchronization) when dependencies are
present (ex. A create outputs, B consume the outputs)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
2
Interprocess Communication
(Race Condition)
Race Condition
◼A situation where two or more processes are reading or writing some shared
data and the final result depends on who runs precisely when, are called race
condition.
Critical section (critical region)
◼The part of program where the shared memory is accessed.
Mutual Exclusion in a critical section can avoid races condition:
◼If we could arrange matters such that no two processes were ever in their
critical regions at the same time, we can avoid races condition.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
3
Interprocess Communication
(Race Condition)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
4
Slots for file names
• When a process want
to print a file, it enter a
file name in a special
spooler directory in
printer
• Printer daemon
periodically check
spooler directory any file
need to be printed.
Shared variable
Interprocess Communication
(Race Condition)

Process A tried to send a job to
spooler, Process A read in = 7,
process A time out and go to ready
state before updating in = in + 1.

Process B tried to send a job to
spooler. Process B read in = 7, load
its job name in slot 7, update i = i +
1 = 8 and then go to block state for
waiting for job.

Process A is rescheduled by
scheduler. Process A already read in
= 7, Process A load its job name in
slot 7, update i = i + 1 = 9 and then
go to blocked state waiting for this
job finish.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
5
Interprocess Communication
(Race Condition)
How to avoid race condition?
Mutual exclusion – some way of making sure that if one process is using a
shared variable or file, the other processes will be excluded from doing the same
thing.
The choice of the algorithm for achieving mutual exclusion is a
major design issue in any operating system.
A solution for the race condition should have following four
conditions
1.
No two processes may be simultaneously inside their critical regions – mutual
exclusion
2.
No process running outside its critical region may block other processes
3.
No process should have to wait forever to enter critical region
4.
No assumptions may be made about speeds or the number of CPUs.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
6
' metadata={'source': '/tmp/tmp50p_945n', 'file_path': '/tmp/tmp50p_945n', 'page': 0, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-19 01:10:24 - INFO - Invoking chain
2024-12-19 01:10:24 - INFO - Successfully loaded 5 documents from: 450Slides11.pdf
2024-12-19 01:10:24 - INFO - Docs: [Document(metadata={'source': '/tmp/tmpye5dombc', 'file_path': '/tmp/tmpye5dombc', 'page': 0, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}, page_content='9/26/2024\n1\nReview\nInter-Process Communication\n\uf070Race Condition\n\uf070Critical Section (or region) \n\uf070Solutions for Mutual Exclusion in a Critical Section\n\uf06eWith Busy Waiting\n\uf070Disabling Interrupts –non-preemptive kernel\n\uf070Lock Variables –violating the first necessary condition (mutual exclusion )\n\uf070Strict Alternation –violating the second necessary condition ( block by a process outside critical section)\n\uf070Peterson’s Solution\n\uf070Hardware Solution\n\uf0a7\nTest and Set Lock –\n\uf0a7\nMemory Barriers\n\uf0a7\nAtomic Variable\n\uf070Priority Inversion problems with busy waiting\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n1\nPreview\n\uf070Mutual Exclusion in a Critical Section\n\uf06eWith Sleep and Wake up\n\uf070Producer Consumer Problem\n\uf070Race Condition Producer Consumer problem\n\uf070Semaphore\n\uf0a7\nConcept of Semaphore\n\uf0a7\nSemaphore Operation\n\uf0a7\nSemaphore Implementation\n\uf0a7\nProducer Consumer problem with semaphores\n\uf0a7\nCareless Usage of semaphore causes deadlock \n\uf070Dining Philosophers Problem\n\uf070Reader’s and Writer’s Problem\n\uf070Mutexes\n\uf070Monitor\n\uf0a7\nImplementation of Monitor\n\uf0a7\nProducer Consumer with Monitor\n\uf070Message Passing\n\uf0a7\nProducer Consumer with Message Passing\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n2\nMutual Exclusion with Sleep and Wakeup\n\uf070Sleep and Wakeup-\n\uf06eA process check a resource (critical section), if not available go \nto sleep. \n\uf06eWhen the resource become available, the process will be waked \nup by system or the process release the resource.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n3\nThe Producer-Consumer Problem\nDescription\n\uf070Two processes share a common, fixed-sized buffer. \n\uf070Producer puts information into the buffer, and consumer takes it \nout.\nTroubles arises \n\uf070When the producer wants to put a new item in the buffer, but it is \nalready full.\n\uf070When the consumer tries to take a item from the buffer, but buffer \nis already empty.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n4\nThe Producer-Consumer Problem\n\uf070When the producer wants to put a new item in the buffer, \nbut it is already full.\n\uf06eSolution – producer is go to sleep, awakened by customer when \ncustomer has removed on or more items.\n\uf070When the consumer tries to take a item from the buffer, \nbut buffer is already empty.\n\uf06eSolution – customer is go to sleep, awakened by the producer \nwhen producer puts one or more information into the buffer.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n5\nThe Producer-Consumer Problem\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n6\n#define N 100 //buffer size\nint count = 0;//# of item\nvoid producer()\n{\nint item\nwhile (true)\n{\nitem = produce_item();\nif (count == N)\nsleep();\ninsert_item(item)\ncount = count + 1;\nif (count ==1)\nwakeup(consumer);\n}\n}\nvoid consumer()\n{\nint item;\nwhile(true)\n{\nif (count == 0)\nsleep();\nitem = remove_item();\ncount = count – 1;\nif (count == N – 1)\nwakeup(producer);\nconsume_item(item);\n}\n}\n'), Document(metadata={'source': '/tmp/tmpye5dombc', 'file_path': '/tmp/tmpye5dombc', 'page': 1, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}, page_content='9/26/2024\n2\nSemaphores – by E. W. Dijkstra \n\uf070A semaphore is an integer variable which could have \nvalue \n\uf06e0:  no wakeups are saved\n\uf06e+ i: i wakeups are pending\n\uf070A semaphore is accessed only through two standard \natomic operations down (or P) and up (or V).\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n7\nConcept of Semaphores\n\uf070Modification to the integer value of the semaphore in the \ndown and up operations are executed indivisibly. \n\uf070Which means that when a process is modifying the \nsemaphore value, no other process can simultaneously \nmodify that same semaphore value.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n8\nSemaphore Operation\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n9\nvoid down (S)\n{\nif S == 0\n{\n1. Add this process to the sleeping list\n2. block;\n}\nS = S – 1;\n}\nvoid up (S)\n{\nS = S + 1;\nIf S = 1\n{\n1. choose one process P from the \nsleeping list or let them move to \nready state\n2. wakeup(P) to finish down operation\n}\n}\nSemaphore Implementation\nThe normal way for implementing a semaphore\n\uf070Implement semaphore operations up and down as \nsystem call.\n\uf070operating system briefly disabling all interrupts while it is \ntesting the semaphore, updating it and putting the \nprocess to sleep.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n10\nSolving the Producer-Consumer Problem using \nSemaphores\n#define N 100\ntypedef int semaphore;\nsemaphore mutex = 1;  //mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of item\nvoid producer ()\n{\nint item;\nwhile (ture)\n{\nitem = produce_item(); //produce item\ndown (&empty); //check empty space\ndown (&mutex); //check mutual exclusion\ninsert_item(item); //insert item\nup(&mutex); //out from critical section\nup(&full); //increase # of item\n}\n}\nvoid consumer()\n{\nint item;\nwhile (true)\n{\ndown(&full); //check item in buffer\ndown(&mutex) //check mutual exclusion\nitem = remove_item(); //remove a item\nup(&mutex); //out from critical section\nup(&empty); //increase the empty space\nconsume_item(item);\n}\n}\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n11\nCareless usage of Semaphore causes deadlock\n#define N 100\ntypedef int semaphore;\nsemaphore mutex = 1; //mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of item\nvoid producer ()\n{\nint item;\nwhile (ture)\n{\nitem = produce_item();\ndown (&mutex);\ndown (&empty);\ninsert_item(item);\nup(&mutex);\nup(&full);\n}\n}\nvoid consumer()\n{\nint item;\nwhile (true)\n{\ndown(&full)\ndown(&mutex)\nitem = remove_item();\nup(&mutex);\nup(&empty);\nconsume_item(item);\n}\n}\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n12\n'), Document(metadata={'source': '/tmp/tmpye5dombc', 'file_path': '/tmp/tmpye5dombc', 'page': 2, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}, page_content="9/26/2024\n3\nCareless usage of Semaphore causes deadlock\n#define N 100\ntypedef int semaphore;\nsemaphore mutex = 1; //mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of item\nvoid producer ()\n{\nint item;\nwhile (ture)\n{\nitem = produce_item();\ndown (&empty);\ndown (&mutex);\ninsert_item(item);\nup(&mutex);\nup(&full);\n}\n}\nvoid consumer()\n{\nint item;\nwhile (true)\n{\ndown(&mutex);\ndown(&full);\nitem = remove_item();\nup(&mutex);\nup(&empty);\nconsume_item(item);\n}\n}\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n13\nDining Philosophers Problem\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n14\nDining Philosophers Problem\n\uf070Five silent philosophers sit at a round table with bowls of spaghetti. Chopsticks \nare placed between each pair of adjacent philosophers.\n\uf070Each philosopher must alternately think and eat. However, a philosopher can \nonly eat spaghetti when they have both left and right chopsticks. \n\uf070Each chopstick can be held by only one philosopher and so a philosopher can use \nthe chopstick only if it is not being used by another philosopher. \n\uf070After an individual philosopher finishes eating, they need to put down both \nchopsticks so that the chopstick s become available to others. A philosopher can \ntake the chopstick on their right or the one on their left as they become \navailable, but cannot start eating before getting both chopsticks.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n15\nReaders-Writers Problem\n\uf070Process reader R and writers W are sharing resources at one time. \nOnly one process (reader or writer) can access the shared \nresources at any time.\n1. It is possible that a reader R1 might have the lock to a shared resource, and \nthen another reader R2 requests access. It would be foolish for R2 to wait \nuntil R1 was done before starting its own read operation; instead R1 and R2\ncan read same resource at the same time since both are reading.\n2. It is possible that a reader R1 might have the lock, a writer W be waiting for \nthe lock, and then a reader R2 requests access. It would be unfair for R2 to \njump in immediately, ahead of W; if that happened often \nenough, W would starve.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n16\nReaders-Writers Problem\nW2\nR3\nW1\nR2\nR1\nW2\nW1\nR1\nR2\nR3\nR4\nR3\nR2\nW1\nR1\nW1\nR1\nR4\nR2\nR3\nUnfair for W1 (starvation)\nMight be better\nShared resource(database)\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n17\nMutexes\n\uf070When the semaphore's ability to count is not needed, the simplified \nversion of the semaphore, called mutex is used.\n\uf070It is good for managing a mutual exclusion to some shared \nresources or pieces of code\n\uf070It is useful in thread packages that are implemented in user’s \nspace.\n\uf070A mutex is a variable that can be in one of two state: unlocked (0), \nlocked(1).\n\uf070A mutex concept is same as binary semaphore which has value 0 \nor 1.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n18\n"), Document(metadata={'source': '/tmp/tmpye5dombc', 'file_path': '/tmp/tmpye5dombc', 'page': 3, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}, page_content='9/26/2024\n4\nMutexes\nmutexes mutex = 0\nrepeat\nmutex_lock (mutex);\nmutex_unlock (mutex);\nuntil false\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n19\nCritical Section\nRemainder Section\nMonitor\n\uf070\nMonitor – High level synchronizing primitive \n\uf06e\nA collection of procedures, variables, and data structures that are all grouped \ntogether in a special kind of module.\n\uf06e\nOnly one process can be active in a monitor at any instant.\n\uf06e\nCompiler knows that monitors are special and can handle calls to monitor \nprocedure differently from other procedure call (create special code for \nmonitor).\n\uf06e\nWhen a process call a procedure inside a monitor, \n1.\ncheck whether any process is active within monitor or not. \n2.\nIf so, the calling process will be suspended until the other process has left the \nmonitor.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n20\nImplementation of Monitor\n\uf070Since monitor is a construct for a programming \nlanguage, Monitor implementation is based on the \ncompiler\n\uf070Compiler knows monitor is special kind of module, \ncompiler use mutex or binary semaphore for mutual \nexclusion.\n\uf070Monitor provide an easy way to achieve mutual exclusion. \nBut we need to consider, how a process can be blocked \nand how blocked process can be waked up?\n\uf06eIntroduction of Condition variables\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n21\nImplementation of Monitor\n\uf070Conditional variables are used in the monitor. \n\uf070There are two operation on the conditional variables (wait, signal).\n\uf070When a monitor procedure discovers that it cannot continue, it does wait \non some condition variable (ex full). This action causes the calling \nprocess to block. – allows other process get into the monitor.\n\uf070Other process (ex. consumer) can wake up its sleeping partner by doing \na signal on the condition variable that its partner is waiting on.\n\uf070If there are more than one processes are waiting on a condition variable, \nsystem scheduler choose one of them \nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n22\nImplementation of Monitor\nOnce a process do a signal, what is next step for the process do a \nsignal, to avoid having two active processes in the monitor at the \nsame time?\nSolution 1) by Hoare\n\uf06eLetting the newly awakened process run, suspending the one do the signal\nSolution 2) by Brinch Hansen\n\uf06eA signal statement may appear only as the final statement in a monitor \nprocedure.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n23\nProducer-Consumer with Monitor\nmonitor ProducerConsumer\ncondition full, empty;\ninteger count;\nprocedure insert (item: integer);\nbegin\nif count = N then\nwait (full);\ninsert_item(item);\ncount :=count + 1;\nif count = 1 then\nsignal (empty)\nend;\nfunction remove: integer;\nbegin\nif count = 0 then\nwait (empty);\nremove = remove_item;\ncount := count – 1;\nif count = N – 1 then\nsignal (full);\nend;\ncount := 0;\nend monitor\nprocedure producer\nbegin\nwhile true do\nbegin\nitem = produce_item;\nProducerConsumer.insert(item)\nend\nend;\nprocedure consumer;\nbegin\nwhile true do\nbegin\nitem = ProducerConsumer.remove;\nconsume_item(item)\nend\nend;\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n24\n'), Document(metadata={'source': '/tmp/tmpye5dombc', 'file_path': '/tmp/tmpye5dombc', 'page': 4, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}, page_content='9/26/2024\n5\nMessage Passing\n\uf070Message Passing is a method of interprocess communication by using two \nprimitive system calls\n\uf06esend(destination, &message);\n\uf06ereceive(source, &message);\n\uf070Usually Message Passing is used between processes located in different system \nsince it is slower than using semaphore or monitor in the same system.\n\uf070If there is no message is available, the receiver will be blocked by system until \none arrived.\n\uf070If there is no message to send, the sender will be blocked by system until one \nbecome available.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n25\nMessage Passing\n(Design Issues for Message Passing System)\n\uf070Message can be lost\n\uf06eSolution: \n\uf070When a message is received, receiver send acknowledgement message.\n\uf070If sender has not received the ack. message within a certain time interval, retransmits the \nmessage.\n\uf06eThis solution cause new design issue. \n\uf070Receiver receive a message from sender, receiver send Ack. message. If the Ack. \nmessage lost, sender send same message again. Then receiver receive same \nmessage twice.\n\uf06eSolution:\n\uf070Each message is assigned with sequence number.\n\uf070Receiver site system can recognize duplicated message and discard one of them.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n26\nProducer-Consumer Problem \n(with Message Passing)\n#define N 100\n/* number of slots in the buffer */\nvoid producer ()\n{\nint item;\nmessage m;\n/* message buffer */\nwhile (ture)\n{\nitem = produce_item();\n/* generate item to put in buffer */\nreceive(consumer, &m);\n/* wait for an empty slot (ACK)*/\nbuild_message(&m, item);\n/* construct a message to send */\nsend(consumer, &m);\n/* send item to consumer */\n}\n}\nvoid consumer()\n{\nint item, i;\nmessage m;\nfor (i=0; i < N; i++)\n/* send N empty messages*/\nsend(producer, &m);\nwhile (true)\n{\nreceive(producer, &m);\n/* receive a message from producer */\nitem = extract_item(&m);\n/* extract a message */\nsend(producer, &m)\n/* send an empty message to producer (ACK)*/\nconsume_item(item);\n}\n}\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n27\n')] for 450Slides11.pdf using PyMuPDFLoader
2024-12-19 01:10:24 - INFO - Document 1 (450Slides11.pdf) of 5
2024-12-19 01:10:24 - INFO - Starting clean_files_chain
2024-12-19 01:10:24 - INFO - Document: page_content='9/26/2024
1
Review
Inter-Process Communication
Race Condition
Critical Section (or region) 
Solutions for Mutual Exclusion in a Critical Section
With Busy Waiting
Disabling Interrupts –non-preemptive kernel
Lock Variables –violating the first necessary condition (mutual exclusion )
Strict Alternation –violating the second necessary condition ( block by a process outside critical section)
Peterson’s Solution
Hardware Solution

Test and Set Lock –

Memory Barriers

Atomic Variable
Priority Inversion problems with busy waiting
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
1
Preview
Mutual Exclusion in a Critical Section
With Sleep and Wake up
Producer Consumer Problem
Race Condition Producer Consumer problem
Semaphore

Concept of Semaphore

Semaphore Operation

Semaphore Implementation

Producer Consumer problem with semaphores

Careless Usage of semaphore causes deadlock 
Dining Philosophers Problem
Reader’s and Writer’s Problem
Mutexes
Monitor

Implementation of Monitor

Producer Consumer with Monitor
Message Passing

Producer Consumer with Message Passing
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
2
Mutual Exclusion with Sleep and Wakeup
Sleep and Wakeup-
A process check a resource (critical section), if not available go 
to sleep. 
When the resource become available, the process will be waked 
up by system or the process release the resource.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
3
The Producer-Consumer Problem
Description
Two processes share a common, fixed-sized buffer. 
Producer puts information into the buffer, and consumer takes it 
out.
Troubles arises 
When the producer wants to put a new item in the buffer, but it is 
already full.
When the consumer tries to take a item from the buffer, but buffer 
is already empty.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
4
The Producer-Consumer Problem
When the producer wants to put a new item in the buffer, 
but it is already full.
Solution – producer is go to sleep, awakened by customer when 
customer has removed on or more items.
When the consumer tries to take a item from the buffer, 
but buffer is already empty.
Solution – customer is go to sleep, awakened by the producer 
when producer puts one or more information into the buffer.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
5
The Producer-Consumer Problem
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
6
#define N 100 //buffer size
int count = 0;//# of item
void producer()
{
int item
while (true)
{
item = produce_item();
if (count == N)
sleep();
insert_item(item)
count = count + 1;
if (count ==1)
wakeup(consumer);
}
}
void consumer()
{
int item;
while(true)
{
if (count == 0)
sleep();
item = remove_item();
count = count – 1;
if (count == N – 1)
wakeup(producer);
consume_item(item);
}
}
' metadata={'source': '/tmp/tmpye5dombc', 'file_path': '/tmp/tmpye5dombc', 'page': 0, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}
2024-12-19 01:10:24 - INFO - Invoking chain
2024-12-19 01:10:24 - INFO - Successfully loaded 4 documents from: 450Slides9.pdf
2024-12-19 01:10:24 - INFO - Docs: [Document(metadata={'source': '/tmp/tmpedy24fk1', 'file_path': '/tmp/tmpedy24fk1', 'page': 0, 'total_pages': 4, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240917075958-04'00'", 'modDate': "D:20240917075958-04'00'", 'trapped': ''}, page_content="9/17/2024\n1\nPreview\n\uf070Real-Time CPU Scheduling\n\uf06eMinimizing Latency\n\uf06ePreemptive Priority-Based Scheduling\n\uf06eRate-Monotonic Scheduling\n\uf06eEarliest-Deadline-First Scheduling\n\uf06eProportional Share Scheduling\n\uf070Criteria for selecting an algorithm\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n1\nReal-Time CPU Scheduling \n\uf070CPU scheduling for real-time operating systems involves special \nissues. In general, we can distinguish between hard real-time \nsystems and soft real-time systems.\n\uf070Hard real-time systems - A task must be serviced by its deadline; \nservice after the deadline has expired is the same as no service at \nall. Any missed deadline to be a system failure. \n\uf06eAn Inkjet printer has a print head with control software for depositing the \ncorrect amount of ink onto a specific part of the paper. If a deadline is missed \nthen the print job is ruined.\n\uf06eAir France Flight 447 crashed into the ocean after a sensor malfunction \ncaused a series of system errors.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n2\nReal-Time CPU Scheduling \n\uf070Soft real-time system allows for frequently missed deadlines, and \nas long as tasks are timely executed their results continue to have \nvalue. Completed tasks may have increasing value up to the \ndeadline and decreasing value past it.\n\uf06eWeather stations have many sensors for reading temperature, humidity, wind \nspeed, etc. The readings should be taken and transmitted at regular intervals, \nhowever the sensors are not synchronized. Even though a sensor reading may \nbe early or late compared with the others it can still be relevant as long as it \nis close enough.\n\uf06eThe sound system in computer. If you miss a few bits, no big deal, but miss \ntoo many and you're going to eventually degrade the system.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n3\nReal-Time CPU Scheduling  \n(Minimizing Latency)\n\uf070A real-time system is typically waiting for an event in real time to \noccur. Events may arise either in software (as when a timer \nexpires)or in hardware (when a remote-controlled vehicle detects \nthat it is approaching an obstruction). \n\uf070When an event occurs, the system must respond to and service it \nas quickly as possible.\n\uf070Event latency is the amount of time that elapses from when an \nevent occurs to when it is serviced.\n\uf070Different events have different latency requirements in a system.\n\uf06eFor an antilock brake system – 3 to 5 milliseconds.\n\uf06eIf antilock brake system does not respond within, car accident might occurs  \nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n4\nReal-Time CPU Scheduling  \n(Minimizing Latency)\n\uf070Two types of latencies affect the performance of real-time systems\n1. Interrupt latency –.\n\uf06eWhen an interrupt occurs, \n\uf070the OS complete the instruction it is executing and \n\uf070determine the type of interrupt that occurred. \n\uf070save the state of the current process before servicing the interrupt using the specific interrupt \nservice routine (ISR).\n\uf06eA Interrupt latency is the period of time from the arrival of an interrupt at the \nCPU to the start of the routine that services the interrupt\n2. Dispatch latency – The amount of time required for the scheduling \ndispatcher to stop one process and start another\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n5\nReal-Time CPU Scheduling  \n(Minimizing Latency)\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n6\n: from current process to interrupt service routine\n"), Document(metadata={'source': '/tmp/tmpedy24fk1', 'file_path': '/tmp/tmpedy24fk1', 'page': 1, 'total_pages': 4, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240917075958-04'00'", 'modDate': "D:20240917075958-04'00'", 'trapped': ''}, page_content='9/17/2024\n2\nReal-Time CPU Scheduling  \n(Minimizing Latency)\n\uf070Two types of latencies affect the performance of real-time systems\n1. Interrupt latency –\n2. Dispatch latency –\n\uf06eDispatch latency is the amount of time required for the scheduling dispatcher \nto stop one process and start another\n\uf06eThe most effective technique for keeping dispatch latency low is to provide \npreemptive kernels. For hard real-time systems, dispatch latency is typically \nmeasured in several microseconds.\n\uf06eTwo components of conflict phase of dispatch latency:\n\uf070Preemption of any process running in the kernel\n\uf070Release by low-priority processes of resources needed by a high-priority process\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n7\nReal-Time CPU Scheduling  \n(Minimizing Latency)\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n8\nFig. Dispatch Latency\nReal-Time CPU Scheduling  \n(Preemptive Priority-Based Scheduling)\n\uf070The most important feature of a real-time operating system is to \nrespond immediately to a real-time process.\n\uf070In Priority-Based scheduling, scheduler always select highest \npriority process; more important tasks are assigned higher \npriorities than those deemed less important.\n\uf070With Preemptive, process currently running on the CPU will be \npreempted if a higher-priority process becomes available to run.\n\uf070Preemptive, priority-based scheduler only guarantees soft real-time \nfunctionality\n\uf070Since hard real-time system need consider deadline, the scheduler \nrequires additional scheduling features.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n9\nReal-Time CPU Scheduling  \n\uf070Characteristics for a process require to consider for real-time CPU \nscheduler.\n\uf06ePeriod (p)- That is, process require the CPU at constant intervals (periods).\n\uf06eDeadline (d)\n\uf06eProcessing time (t)–fixed processing time\n\uf070The relationship of the processing time, the deadline, and the \nperiod can be expressed as \n\uf06e0 ≤ t ≤ d ≤ p. \n\uf070The rate of a periodic task is 1∕p.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n10\nReal-Time CPU Scheduling \n\uf070A process have to provide its deadline requirement to the scheduler. Then, the \nscheduler either admit the process guaranteeing that the process will complete \non time, or rejects the request as impossible (admission-control algorithm)\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n11\nFig. Periodic task.\nReal-Time CPU Scheduling  \n(Rate-Monotonic Scheduling)\n\uf070Rate-monotonic scheduling assumes that the processing time of a \nperiodic process is the same for each CPU burst. That is, every \ntime a process acquires the CPU, the duration of its CPU burst is \nthe same. \n\uf070Upon entering the system, priority is assigned to a process based \non length of period (p). The shorter the period, the higher the \npriority.\n\uf070The rate-monotonic scheduling algorithm schedules periodic tasks \nusing a static priority policy with preemption.\n\uf070If a lower-priority process is running and a higher-priority process \nbecomes available to run, it will preempt the lower-priority \nprocess.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n12\n'), Document(metadata={'source': '/tmp/tmpedy24fk1', 'file_path': '/tmp/tmpedy24fk1', 'page': 2, 'total_pages': 4, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240917075958-04'00'", 'modDate': "D:20240917075958-04'00'", 'trapped': ''}, page_content='9/17/2024\n3\nReal-Time CPU Scheduling  \n(Rate-Monotonic Scheduling)\n\uf070Ex) Two process P1, P2\n\uf06ep1= 50, t1=20, d1= by the start of its next period\n\uf070CPU utilization of P1= p1/t1=20/50 = 0.4\n\uf06ep2=100, t2=35, d2 = by the start of its next period\n\uf070CPU utilization of P1= p2/t2=35/100 = 0.35\n\uf06eSince t1 \uf03ct2, P1 has higher priority than P2\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n13\n110\n0\n120\n150\n160\n170\n180\n190\n200\n130\n140\n100\n30\n40\n50\n60\n70\n80\n90\n20\n10\nP2\nP1\nP1\nP2\nP2\nP1\nP1\nP2\np2\np1\np1\np1\np2\nP1 ,P2 deadline =200\nP1 deadline =150\nP1 deadline =50\nP1 ,P2 deadline =100\nReal-Time CPU Scheduling  \n(Rate-Monotonic Scheduling)\n\uf070Ex) Two process P1, P2\n\uf06ep1= 50, t1=25, d1= by the start of its next period\n\uf070CPU utilization of P1= p1/t1=25/50 = 0.5\n\uf06ep2=80, t2=35, d2 = by the start of its next period\n\uf070CPU utilization of P2 = p2/t2=35/80 = 0.4375\n\uf06eSince t1 \uf03ct2, P1 has higher priority than P2\n\uf06erate-monotonic scheduling cannot guarantee that they can be scheduled so that they \nmeet their deadlines.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n14\n110\n0\n120\n150\n160\n170\n180\n190\n200\n130\n140\n100\n30\n40\n50\n60\n70\n80\n90\n20\n10\nP2\nP1\nP1\nP2\np2\np1\nP1 deadline =50\np2\np2\np1\np1\np1\nP2 deadline =80\nReal-Time CPU Scheduling  \n(Earliest-Deadline-First Scheduling)\n\uf070Earliest-deadline-firs (EDF) scheduling assigns priorities \ndynamically according to deadline. \n\uf06eThe earlier the deadline, the higher the priority; \n\uf06eThe later the deadline, the lower the priority\n\uf070When a process becomes runnable (ready state), it must \nannounce its deadline requirements to the system. \n\uf070Priorities have to be adjusted to reflect the deadline of \nthe newly runnable process.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n15\nP2\nP1\nP2\nP1\nP2\nP1\nReal-Time CPU Scheduling  \n(Earliest-Deadline-First Scheduling)\n\uf070Ex) Two process P1, P2\n\uf06ep1= 50, t1=25, d1= by the start of its next period\n\uf070CPU utilization of P1= p1/t1=25/50 = 0.5\n\uf06ep2=80, t2=35, d2 = by the start of its next period\n\uf070CPU utilization of P2 = p2/t2=35/80 = 0.4375\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n16\n110\n0\n120\n150\n160\n170\n180\n190\n200\n130\n140\n100\n30\n40\n50\n60\n70\n80\n90\n20\n10\np1\nP2\np2\np2\np1\np1\np1\np2\nP1\nP1\nP2\nP1\nReal-Time CPU Scheduling  \n(Earliest-Deadline-First Scheduling)\n\uf070EDF scheduling is theoretically optimal—theoretically, it \ncan schedule processes so that each process can meet its \ndeadline requirements and CPU utilization will be 100 \npercent. \n\uf070In practice, it is not possible to achieve this level of CPU \nutilization due to the cost of context switching between \nprocesses and interrupt handling.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n17\nReal-Time CPU Scheduling  \n(Proportional Share Scheduling)\n\uf070Proportional share schedulers operate by allocating T shares \namong all processes.\n\uf070An process can receive N shares of time, ensuring that the process \nwill have N∕T of the total processor time.\n\uf070Ex) There are three processes P1, P2, and P3. And, total of share T \n= 100.\n\uf06eP1 is assigned 50 shares, P2 is assigned 15 shares, and P3 is assigned 20 \nshares.\n\uf06eMeans that P1 will have 50 %, P2 will have 15 %, and P3 will have 20 % of \ntotal processor time.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n18\n'), Document(metadata={'source': '/tmp/tmpedy24fk1', 'file_path': '/tmp/tmpedy24fk1', 'page': 3, 'total_pages': 4, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240917075958-04'00'", 'modDate': "D:20240917075958-04'00'", 'trapped': ''}, page_content='9/17/2024\n4\nReal-Time CPU Scheduling  \n(Proportional Share Scheduling)\n\uf070Proportional share schedulers must work in conjunction \nwith an admission-control policy to guarantee that an \napplication receives its allocated shares of time.\n\uf070An admission-control policy will admit a process \nrequesting a particular number of shares only if sufficient \nshares are available.\n\uf06eIn previous example, we have allocated 50 + 15 + 20 = 85 \nshares of the total of 100 shares. \n\uf06eIf a new process P4 requested 30 shares, the admission \ncontroller would deny P4 entry into the system.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n19\nScheduling Algorithm Evaluation\n\uf070Criteria for selecting an algorithm.\n\uf06eCPU Utilization\n\uf06eThroughput\n\uf06eResponse time\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n20\n')] for 450Slides9.pdf using PyMuPDFLoader
2024-12-19 01:10:24 - INFO - Document 1 (450Slides9.pdf) of 4
2024-12-19 01:10:24 - INFO - Starting clean_files_chain
2024-12-19 01:10:24 - INFO - Document: page_content='9/17/2024
1
Preview
Real-Time CPU Scheduling
Minimizing Latency
Preemptive Priority-Based Scheduling
Rate-Monotonic Scheduling
Earliest-Deadline-First Scheduling
Proportional Share Scheduling
Criteria for selecting an algorithm
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
1
Real-Time CPU Scheduling 
CPU scheduling for real-time operating systems involves special 
issues. In general, we can distinguish between hard real-time 
systems and soft real-time systems.
Hard real-time systems - A task must be serviced by its deadline; 
service after the deadline has expired is the same as no service at 
all. Any missed deadline to be a system failure. 
An Inkjet printer has a print head with control software for depositing the 
correct amount of ink onto a specific part of the paper. If a deadline is missed 
then the print job is ruined.
Air France Flight 447 crashed into the ocean after a sensor malfunction 
caused a series of system errors.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
2
Real-Time CPU Scheduling 
Soft real-time system allows for frequently missed deadlines, and 
as long as tasks are timely executed their results continue to have 
value. Completed tasks may have increasing value up to the 
deadline and decreasing value past it.
Weather stations have many sensors for reading temperature, humidity, wind 
speed, etc. The readings should be taken and transmitted at regular intervals, 
however the sensors are not synchronized. Even though a sensor reading may 
be early or late compared with the others it can still be relevant as long as it 
is close enough.
The sound system in computer. If you miss a few bits, no big deal, but miss 
too many and you're going to eventually degrade the system.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
3
Real-Time CPU Scheduling  
(Minimizing Latency)
A real-time system is typically waiting for an event in real time to 
occur. Events may arise either in software (as when a timer 
expires)or in hardware (when a remote-controlled vehicle detects 
that it is approaching an obstruction). 
When an event occurs, the system must respond to and service it 
as quickly as possible.
Event latency is the amount of time that elapses from when an 
event occurs to when it is serviced.
Different events have different latency requirements in a system.
For an antilock brake system – 3 to 5 milliseconds.
If antilock brake system does not respond within, car accident might occurs  
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
4
Real-Time CPU Scheduling  
(Minimizing Latency)
Two types of latencies affect the performance of real-time systems
1. Interrupt latency –.
When an interrupt occurs, 
the OS complete the instruction it is executing and 
determine the type of interrupt that occurred. 
save the state of the current process before servicing the interrupt using the specific interrupt 
service routine (ISR).
A Interrupt latency is the period of time from the arrival of an interrupt at the 
CPU to the start of the routine that services the interrupt
2. Dispatch latency – The amount of time required for the scheduling 
dispatcher to stop one process and start another
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
5
Real-Time CPU Scheduling  
(Minimizing Latency)
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
6
: from current process to interrupt service routine
' metadata={'source': '/tmp/tmpedy24fk1', 'file_path': '/tmp/tmpedy24fk1', 'page': 0, 'total_pages': 4, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240917075958-04'00'", 'modDate': "D:20240917075958-04'00'", 'trapped': ''}
2024-12-19 01:10:24 - INFO - Invoking chain
2024-12-19 01:10:24 - INFO - Successfully loaded 5 documents from: cosc450_11.pdf
2024-12-19 01:10:24 - INFO - Docs: [Document(metadata={'source': '/tmp/tmplpxmqkix', 'file_path': '/tmp/tmplpxmqkix', 'page': 0, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}, page_content='9/26/2024\n1\nReview\nInter-Process Communication\n\uf070Race Condition\n\uf070Critical Section (or region) \n\uf070Solutions for Mutual Exclusion in a Critical Section\n\uf06eWith Busy Waiting\n\uf070Disabling Interrupts –non-preemptive kernel\n\uf070Lock Variables –violating the first necessary condition (mutual exclusion )\n\uf070Strict Alternation –violating the second necessary condition ( block by a process outside critical section)\n\uf070Peterson’s Solution\n\uf070Hardware Solution\n\uf0a7\nTest and Set Lock –\n\uf0a7\nMemory Barriers\n\uf0a7\nAtomic Variable\n\uf070Priority Inversion problems with busy waiting\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n1\nPreview\n\uf070Mutual Exclusion in a Critical Section\n\uf06eWith Sleep and Wake up\n\uf070Producer Consumer Problem\n\uf070Race Condition Producer Consumer problem\n\uf070Semaphore\n\uf0a7\nConcept of Semaphore\n\uf0a7\nSemaphore Operation\n\uf0a7\nSemaphore Implementation\n\uf0a7\nProducer Consumer problem with semaphores\n\uf0a7\nCareless Usage of semaphore causes deadlock \n\uf070Dining Philosophers Problem\n\uf070Reader’s and Writer’s Problem\n\uf070Mutexes\n\uf070Monitor\n\uf0a7\nImplementation of Monitor\n\uf0a7\nProducer Consumer with Monitor\n\uf070Message Passing\n\uf0a7\nProducer Consumer with Message Passing\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n2\nMutual Exclusion with Sleep and Wakeup\n\uf070Sleep and Wakeup-\n\uf06eA process check a resource (critical section), if not available go \nto sleep. \n\uf06eWhen the resource become available, the process will be waked \nup by system or the process release the resource.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n3\nThe Producer-Consumer Problem\nDescription\n\uf070Two processes share a common, fixed-sized buffer. \n\uf070Producer puts information into the buffer, and consumer takes it \nout.\nTroubles arises \n\uf070When the producer wants to put a new item in the buffer, but it is \nalready full.\n\uf070When the consumer tries to take a item from the buffer, but buffer \nis already empty.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n4\nThe Producer-Consumer Problem\n\uf070When the producer wants to put a new item in the buffer, \nbut it is already full.\n\uf06eSolution – producer is go to sleep, awakened by customer when \ncustomer has removed on or more items.\n\uf070When the consumer tries to take a item from the buffer, \nbut buffer is already empty.\n\uf06eSolution – customer is go to sleep, awakened by the producer \nwhen producer puts one or more information into the buffer.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n5\nThe Producer-Consumer Problem\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n6\n#define N 100 //buffer size\nint count = 0;//# of item\nvoid producer()\n{\nint item\nwhile (true)\n{\nitem = produce_item();\nif (count == N)\nsleep();\ninsert_item(item)\ncount = count + 1;\nif (count ==1)\nwakeup(consumer);\n}\n}\nvoid consumer()\n{\nint item;\nwhile(true)\n{\nif (count == 0)\nsleep();\nitem = remove_item();\ncount = count – 1;\nif (count == N – 1)\nwakeup(producer);\nconsume_item(item);\n}\n}\n'), Document(metadata={'source': '/tmp/tmplpxmqkix', 'file_path': '/tmp/tmplpxmqkix', 'page': 1, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}, page_content='9/26/2024\n2\nSemaphores – by E. W. Dijkstra \n\uf070A semaphore is an integer variable which could have \nvalue \n\uf06e0:  no wakeups are saved\n\uf06e+ i: i wakeups are pending\n\uf070A semaphore is accessed only through two standard \natomic operations down (or P) and up (or V).\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n7\nConcept of Semaphores\n\uf070Modification to the integer value of the semaphore in the \ndown and up operations are executed indivisibly. \n\uf070Which means that when a process is modifying the \nsemaphore value, no other process can simultaneously \nmodify that same semaphore value.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n8\nSemaphore Operation\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n9\nvoid down (S)\n{\nif S == 0\n{\n1. Add this process to the sleeping list\n2. block;\n}\nS = S – 1;\n}\nvoid up (S)\n{\nS = S + 1;\nIf S = 1\n{\n1. choose one process P from the \nsleeping list or let them move to \nready state\n2. wakeup(P) to finish down operation\n}\n}\nSemaphore Implementation\nThe normal way for implementing a semaphore\n\uf070Implement semaphore operations up and down as \nsystem call.\n\uf070operating system briefly disabling all interrupts while it is \ntesting the semaphore, updating it and putting the \nprocess to sleep.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n10\nSolving the Producer-Consumer Problem using \nSemaphores\n#define N 100\ntypedef int semaphore;\nsemaphore mutex = 1;  //mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of item\nvoid producer ()\n{\nint item;\nwhile (ture)\n{\nitem = produce_item(); //produce item\ndown (&empty); //check empty space\ndown (&mutex); //check mutual exclusion\ninsert_item(item); //insert item\nup(&mutex); //out from critical section\nup(&full); //increase # of item\n}\n}\nvoid consumer()\n{\nint item;\nwhile (true)\n{\ndown(&full); //check item in buffer\ndown(&mutex) //check mutual exclusion\nitem = remove_item(); //remove a item\nup(&mutex); //out from critical section\nup(&empty); //increase the empty space\nconsume_item(item);\n}\n}\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n11\nCareless usage of Semaphore causes deadlock\n#define N 100\ntypedef int semaphore;\nsemaphore mutex = 1; //mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of item\nvoid producer ()\n{\nint item;\nwhile (ture)\n{\nitem = produce_item();\ndown (&mutex);\ndown (&empty);\ninsert_item(item);\nup(&mutex);\nup(&full);\n}\n}\nvoid consumer()\n{\nint item;\nwhile (true)\n{\ndown(&full)\ndown(&mutex)\nitem = remove_item();\nup(&mutex);\nup(&empty);\nconsume_item(item);\n}\n}\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n12\n'), Document(metadata={'source': '/tmp/tmplpxmqkix', 'file_path': '/tmp/tmplpxmqkix', 'page': 2, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}, page_content="9/26/2024\n3\nCareless usage of Semaphore causes deadlock\n#define N 100\ntypedef int semaphore;\nsemaphore mutex = 1; //mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of item\nvoid producer ()\n{\nint item;\nwhile (ture)\n{\nitem = produce_item();\ndown (&empty);\ndown (&mutex);\ninsert_item(item);\nup(&mutex);\nup(&full);\n}\n}\nvoid consumer()\n{\nint item;\nwhile (true)\n{\ndown(&mutex);\ndown(&full);\nitem = remove_item();\nup(&mutex);\nup(&empty);\nconsume_item(item);\n}\n}\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n13\nDining Philosophers Problem\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n14\nDining Philosophers Problem\n\uf070Five silent philosophers sit at a round table with bowls of spaghetti. Chopsticks \nare placed between each pair of adjacent philosophers.\n\uf070Each philosopher must alternately think and eat. However, a philosopher can \nonly eat spaghetti when they have both left and right chopsticks. \n\uf070Each chopstick can be held by only one philosopher and so a philosopher can use \nthe chopstick only if it is not being used by another philosopher. \n\uf070After an individual philosopher finishes eating, they need to put down both \nchopsticks so that the chopstick s become available to others. A philosopher can \ntake the chopstick on their right or the one on their left as they become \navailable, but cannot start eating before getting both chopsticks.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n15\nReaders-Writers Problem\n\uf070Process reader R and writers W are sharing resources at one time. \nOnly one process (reader or writer) can access the shared \nresources at any time.\n1. It is possible that a reader R1 might have the lock to a shared resource, and \nthen another reader R2 requests access. It would be foolish for R2 to wait \nuntil R1 was done before starting its own read operation; instead R1 and R2\ncan read same resource at the same time since both are reading.\n2. It is possible that a reader R1 might have the lock, a writer W be waiting for \nthe lock, and then a reader R2 requests access. It would be unfair for R2 to \njump in immediately, ahead of W; if that happened often \nenough, W would starve.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n16\nReaders-Writers Problem\nW2\nR3\nW1\nR2\nR1\nW2\nW1\nR1\nR2\nR3\nR4\nR3\nR2\nW1\nR1\nW1\nR1\nR4\nR2\nR3\nUnfair for W1 (starvation)\nMight be better\nShared resource(database)\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n17\nMutexes\n\uf070When the semaphore's ability to count is not needed, the simplified \nversion of the semaphore, called mutex is used.\n\uf070It is good for managing a mutual exclusion to some shared \nresources or pieces of code\n\uf070It is useful in thread packages that are implemented in user’s \nspace.\n\uf070A mutex is a variable that can be in one of two state: unlocked (0), \nlocked(1).\n\uf070A mutex concept is same as binary semaphore which has value 0 \nor 1.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n18\n"), Document(metadata={'source': '/tmp/tmplpxmqkix', 'file_path': '/tmp/tmplpxmqkix', 'page': 3, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}, page_content='9/26/2024\n4\nMutexes\nmutexes mutex = 0\nrepeat\nmutex_lock (mutex);\nmutex_unlock (mutex);\nuntil false\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n19\nCritical Section\nRemainder Section\nMonitor\n\uf070\nMonitor – High level synchronizing primitive \n\uf06e\nA collection of procedures, variables, and data structures that are all grouped \ntogether in a special kind of module.\n\uf06e\nOnly one process can be active in a monitor at any instant.\n\uf06e\nCompiler knows that monitors are special and can handle calls to monitor \nprocedure differently from other procedure call (create special code for \nmonitor).\n\uf06e\nWhen a process call a procedure inside a monitor, \n1.\ncheck whether any process is active within monitor or not. \n2.\nIf so, the calling process will be suspended until the other process has left the \nmonitor.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n20\nImplementation of Monitor\n\uf070Since monitor is a construct for a programming \nlanguage, Monitor implementation is based on the \ncompiler\n\uf070Compiler knows monitor is special kind of module, \ncompiler use mutex or binary semaphore for mutual \nexclusion.\n\uf070Monitor provide an easy way to achieve mutual exclusion. \nBut we need to consider, how a process can be blocked \nand how blocked process can be waked up?\n\uf06eIntroduction of Condition variables\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n21\nImplementation of Monitor\n\uf070Conditional variables are used in the monitor. \n\uf070There are two operation on the conditional variables (wait, signal).\n\uf070When a monitor procedure discovers that it cannot continue, it does wait \non some condition variable (ex full). This action causes the calling \nprocess to block. – allows other process get into the monitor.\n\uf070Other process (ex. consumer) can wake up its sleeping partner by doing \na signal on the condition variable that its partner is waiting on.\n\uf070If there are more than one processes are waiting on a condition variable, \nsystem scheduler choose one of them \nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n22\nImplementation of Monitor\nOnce a process do a signal, what is next step for the process do a \nsignal, to avoid having two active processes in the monitor at the \nsame time?\nSolution 1) by Hoare\n\uf06eLetting the newly awakened process run, suspending the one do the signal\nSolution 2) by Brinch Hansen\n\uf06eA signal statement may appear only as the final statement in a monitor \nprocedure.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n23\nProducer-Consumer with Monitor\nmonitor ProducerConsumer\ncondition full, empty;\ninteger count;\nprocedure insert (item: integer);\nbegin\nif count = N then\nwait (full);\ninsert_item(item);\ncount :=count + 1;\nif count = 1 then\nsignal (empty)\nend;\nfunction remove: integer;\nbegin\nif count = 0 then\nwait (empty);\nremove = remove_item;\ncount := count – 1;\nif count = N – 1 then\nsignal (full);\nend;\ncount := 0;\nend monitor\nprocedure producer\nbegin\nwhile true do\nbegin\nitem = produce_item;\nProducerConsumer.insert(item)\nend\nend;\nprocedure consumer;\nbegin\nwhile true do\nbegin\nitem = ProducerConsumer.remove;\nconsume_item(item)\nend\nend;\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n24\n'), Document(metadata={'source': '/tmp/tmplpxmqkix', 'file_path': '/tmp/tmplpxmqkix', 'page': 4, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}, page_content='9/26/2024\n5\nMessage Passing\n\uf070Message Passing is a method of interprocess communication by using two \nprimitive system calls\n\uf06esend(destination, &message);\n\uf06ereceive(source, &message);\n\uf070Usually Message Passing is used between processes located in different system \nsince it is slower than using semaphore or monitor in the same system.\n\uf070If there is no message is available, the receiver will be blocked by system until \none arrived.\n\uf070If there is no message to send, the sender will be blocked by system until one \nbecome available.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n25\nMessage Passing\n(Design Issues for Message Passing System)\n\uf070Message can be lost\n\uf06eSolution: \n\uf070When a message is received, receiver send acknowledgement message.\n\uf070If sender has not received the ack. message within a certain time interval, retransmits the \nmessage.\n\uf06eThis solution cause new design issue. \n\uf070Receiver receive a message from sender, receiver send Ack. message. If the Ack. \nmessage lost, sender send same message again. Then receiver receive same \nmessage twice.\n\uf06eSolution:\n\uf070Each message is assigned with sequence number.\n\uf070Receiver site system can recognize duplicated message and discard one of them.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n26\nProducer-Consumer Problem \n(with Message Passing)\n#define N 100\n/* number of slots in the buffer */\nvoid producer ()\n{\nint item;\nmessage m;\n/* message buffer */\nwhile (ture)\n{\nitem = produce_item();\n/* generate item to put in buffer */\nreceive(consumer, &m);\n/* wait for an empty slot (ACK)*/\nbuild_message(&m, item);\n/* construct a message to send */\nsend(consumer, &m);\n/* send item to consumer */\n}\n}\nvoid consumer()\n{\nint item, i;\nmessage m;\nfor (i=0; i < N; i++)\n/* send N empty messages*/\nsend(producer, &m);\nwhile (true)\n{\nreceive(producer, &m);\n/* receive a message from producer */\nitem = extract_item(&m);\n/* extract a message */\nsend(producer, &m)\n/* send an empty message to producer (ACK)*/\nconsume_item(item);\n}\n}\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n27\n')] for cosc450_11.pdf using PyMuPDFLoader
2024-12-19 01:10:24 - INFO - Document 1 (cosc450_11.pdf) of 5
2024-12-19 01:10:24 - INFO - Starting clean_files_chain
2024-12-19 01:10:24 - INFO - Document: page_content='9/26/2024
1
Review
Inter-Process Communication
Race Condition
Critical Section (or region) 
Solutions for Mutual Exclusion in a Critical Section
With Busy Waiting
Disabling Interrupts –non-preemptive kernel
Lock Variables –violating the first necessary condition (mutual exclusion )
Strict Alternation –violating the second necessary condition ( block by a process outside critical section)
Peterson’s Solution
Hardware Solution

Test and Set Lock –

Memory Barriers

Atomic Variable
Priority Inversion problems with busy waiting
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
1
Preview
Mutual Exclusion in a Critical Section
With Sleep and Wake up
Producer Consumer Problem
Race Condition Producer Consumer problem
Semaphore

Concept of Semaphore

Semaphore Operation

Semaphore Implementation

Producer Consumer problem with semaphores

Careless Usage of semaphore causes deadlock 
Dining Philosophers Problem
Reader’s and Writer’s Problem
Mutexes
Monitor

Implementation of Monitor

Producer Consumer with Monitor
Message Passing

Producer Consumer with Message Passing
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
2
Mutual Exclusion with Sleep and Wakeup
Sleep and Wakeup-
A process check a resource (critical section), if not available go 
to sleep. 
When the resource become available, the process will be waked 
up by system or the process release the resource.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
3
The Producer-Consumer Problem
Description
Two processes share a common, fixed-sized buffer. 
Producer puts information into the buffer, and consumer takes it 
out.
Troubles arises 
When the producer wants to put a new item in the buffer, but it is 
already full.
When the consumer tries to take a item from the buffer, but buffer 
is already empty.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
4
The Producer-Consumer Problem
When the producer wants to put a new item in the buffer, 
but it is already full.
Solution – producer is go to sleep, awakened by customer when 
customer has removed on or more items.
When the consumer tries to take a item from the buffer, 
but buffer is already empty.
Solution – customer is go to sleep, awakened by the producer 
when producer puts one or more information into the buffer.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
5
The Producer-Consumer Problem
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
6
#define N 100 //buffer size
int count = 0;//# of item
void producer()
{
int item
while (true)
{
item = produce_item();
if (count == N)
sleep();
insert_item(item)
count = count + 1;
if (count ==1)
wakeup(consumer);
}
}
void consumer()
{
int item;
while(true)
{
if (count == 0)
sleep();
item = remove_item();
count = count – 1;
if (count == N – 1)
wakeup(producer);
consume_item(item);
}
}
' metadata={'source': '/tmp/tmplpxmqkix', 'file_path': '/tmp/tmplpxmqkix', 'page': 0, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}
2024-12-19 01:10:24 - INFO - Invoking chain
2024-12-19 01:10:34 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 01:10:35 - INFO - Response: {'cleaned_content': '9/17/2024\n\nInter-Process Communication\n- Race Condition\n- Critical Section (or region)\n- Solutions for Mutual Exclusion in a Critical Section\n  - With Busy Waiting\n    - Disabling Interrupts – non-preemptive kernel\n    - Lock Variables – violating the first necessary condition (mutual exclusion)\n    - Strict Alternation – violating the second necessary condition (block by a process outside critical section)\n    - Peterson’s Solution\n    - Hardware Solution\n      - Test and Set Lock\n      - Memory Barriers\n      - Atomic Variable\n  - Priority Inversion problems with busy waiting\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nInterprocess Communication\nThree issues in interprocess communication:\n1. How one process can pass information to another (communication between processes) – with IPCS (shared memory, message queue, FIFO, PIPE, socket, …)\n2. How to make sure two or more processes do not get into the critical section (mutual exclusion) – with mutex, semaphore\n3. Proper sequencing (Synchronization) when dependencies are present (e.g., A creates outputs, B consumes the outputs)\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nRace Condition\n- A situation where two or more processes are reading or writing some shared data and the final result depends on who runs precisely when is called a race condition.\n\nCritical section (critical region)\n- The part of the program where the shared memory is accessed.\n\nMutual Exclusion in a critical section can avoid race conditions:\n- If we could arrange matters such that no two processes were ever in their critical regions at the same time, we can avoid race conditions.\n\nSlots for file names\n- When a process wants to print a file, it enters a file name in a special spooler directory in the printer.\n- The printer daemon periodically checks the spooler directory for any files that need to be printed.\n\nShared variable\n\nRace Condition Example:\n- Process A tries to send a job to the spooler, reads in = 7, times out, and goes to the ready state before updating in = in + 1.\n- Process B tries to send a job to the spooler. It reads in = 7, loads its job name in slot 7, updates i = i + 1 = 8, and then goes to the blocked state waiting for the job.\n- Process A is rescheduled by the scheduler. Process A already read in = 7, loads its job name in slot 7, updates i = i + 1 = 9, and then goes to the blocked state waiting for this job to finish.\n\nHow to avoid race conditions?\n- Mutual exclusion – some way of making sure that if one process is using a shared variable or file, the other processes will be excluded from doing the same thing.\n\nThe choice of the algorithm for achieving mutual exclusion is a major design issue in any operating system.\n\nA solution for the race condition should have the following four conditions:\n1. No two processes may be simultaneously inside their critical regions – mutual exclusion.\n2. No process running outside its critical region may block other processes.\n3. No process should have to wait forever to enter the critical region.\n4. No assumptions may be made about speeds or the number of CPUs.'}
2024-12-19 01:10:35 - INFO - Finished clean_files_chain
2024-12-19 01:10:35 - INFO - Successfully cleaned document 1 from 450Slides10.pdf
2024-12-19 01:10:35 - INFO - Document 2 (450Slides10.pdf) of 5
2024-12-19 01:10:35 - INFO - Starting clean_files_chain
2024-12-19 01:10:35 - INFO - Document: page_content='9/17/2024
2
Interprocess Communication
(Race Condition)
Two approaches for mutual exclusion solutions.
◼Busy wait – A process will wait until resource become available
or CPU time term expired.
◼Sleep and Wakeup – A process check a resource, if not available
go to sleep. When the resource become available, the process
will be waked up by system or the process release the resource.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
7
Mutual Exclusion with Busy Waiting
Each process has time term. A process keep checking the
possibility to get into critical section.
Mutual Exclusion with Busy Waiting
◼Disabling Interrupts –non-preemptive kernel
◼Lock Variables
◼Strict Alternation
◼Peterson’s Solution
◼Hardware Solutions
Test and Set Lock
Memory Barriers
Atomic Variable
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
8
Mutual Exclusion with Busy Waiting
(Disabling Interrupt – Nonprimitive Kernel)
Disabling Interrupt
Once a process get into the critical section, interrupts set to disable.
Other process cannot get CPU time until the process finish its job in
the critical section.
Since each user process has power to control interrupt, it might
cause the end of system.
We can build a simple program which can disable entire system
since user has control system interrupt. (vulnerable system)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
9
Mutual Exclusion with Busy Waiting
(Disabling Interrupt – Nonprimitive Kernel)
Ex) End of the system with Disabling interrupt
1. A process get into the critical section.
2. It make disable all the interrupts – which means all
other process are sleeping until the job is done in the
critical section.
3. The process has blocked outside critical section just
before make enable all the interrupts and never return
again, cause end of the system.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
10
Mutual Exclusion with Busy Waiting
(Using Lock Variable)
There are variable called “Lock”
◼A process can enter in its critical section when Lock = 0.
◼Lock =0 means no process is currently running in the critical
section, set Lock =1 and enter in the critical section.
◼Once a process finish its job in critical section, set Lock = 0 and
let other process in the critical section
◼Lock = 1 means there is a process running in the critical section,
a process do busy waiting until Lock become 0.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
11
Mutual Exclusion with Busy Waiting
(Using Lock Variable)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
12
static int lock = 0; //lock variable is initially 0
repeat
while lock 0do
; (no-operation) // Busy waiting
lock = 1;
lock = 0;
until false
Critical Section
Remainder Section
' metadata={'source': '/tmp/tmp50p_945n', 'file_path': '/tmp/tmp50p_945n', 'page': 1, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-19 01:10:35 - INFO - Invoking chain
2024-12-19 01:10:35 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 01:10:35 - INFO - Response: {'cleaned_content': '9/26/2024\n\nReview\n\nInter-Process Communication\n\n- Race Condition\n- Critical Section (or region)\n- Solutions for Mutual Exclusion in a Critical Section\n  - With Busy Waiting\n    - Disabling Interrupts – non-preemptive kernel\n    - Lock Variables – violating the first necessary condition (mutual exclusion)\n    - Strict Alternation – violating the second necessary condition (block by a process outside critical section)\n    - Peterson’s Solution\n    - Hardware Solution\n      - Test and Set Lock\n      - Memory Barriers\n      - Atomic Variable\n    - Priority Inversion problems with busy waiting\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nPreview\n\n- Mutual Exclusion in a Critical Section\n  - With Sleep and Wake up\n- Producer Consumer Problem\n- Race Condition Producer Consumer problem\n- Semaphore\n  - Concept of Semaphore\n  - Semaphore Operation\n  - Semaphore Implementation\n  - Producer Consumer problem with semaphores\n  - Careless Usage of semaphore causes deadlock\n- Dining Philosophers Problem\n- Reader’s and Writer’s Problem\n- Mutexes\n- Monitor\n  - Implementation of Monitor\n  - Producer Consumer with Monitor\n- Message Passing\n  - Producer Consumer with Message Passing\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Sleep and Wakeup\n\n- Sleep and Wakeup:\n  - A process checks a resource (critical section); if not available, it goes to sleep.\n  - When the resource becomes available, the process will be woken up by the system or the process will release the resource.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nThe Producer-Consumer Problem\nDescription\n\n- Two processes share a common, fixed-sized buffer.\n- Producer puts information into the buffer, and consumer takes it out.\n\nTroubles arise:\n\n- When the producer wants to put a new item in the buffer, but it is already full.\n- When the consumer tries to take an item from the buffer, but the buffer is already empty.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nThe Producer-Consumer Problem\n\n- When the producer wants to put a new item in the buffer, but it is already full.\n  - Solution: producer goes to sleep, awakened by consumer when consumer has removed one or more items.\n- When the consumer tries to take an item from the buffer, but the buffer is already empty.\n  - Solution: consumer goes to sleep, awakened by producer when producer puts one or more items into the buffer.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nThe Producer-Consumer Problem\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\n#define N 100 // buffer size\nint count = 0; // number of items\n\nvoid producer() {\n    int item;\n    while (true) {\n        item = produce_item();\n        if (count == N)\n            sleep();\n        insert_item(item);\n        count = count + 1;\n        if (count == 1)\n            wakeup(consumer);\n    }\n}\n\nvoid consumer() {\n    int item;\n    while (true) {\n        if (count == 0)\n            sleep();\n        item = remove_item();\n        count = count - 1;\n        if (count == N - 1)\n            wakeup(producer);\n        consume_item(item);\n    }\n}'}
2024-12-19 01:10:35 - INFO - Finished clean_files_chain
2024-12-19 01:10:35 - INFO - Successfully cleaned document 1 from 450Slides11.pdf
2024-12-19 01:10:35 - INFO - Document 2 (450Slides11.pdf) of 5
2024-12-19 01:10:35 - INFO - Starting clean_files_chain
2024-12-19 01:10:35 - INFO - Document: page_content='9/26/2024
2
Semaphores – by E. W. Dijkstra 
A semaphore is an integer variable which could have 
value 
0:  no wakeups are saved
+ i: i wakeups are pending
A semaphore is accessed only through two standard 
atomic operations down (or P) and up (or V).
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
7
Concept of Semaphores
Modification to the integer value of the semaphore in the 
down and up operations are executed indivisibly. 
Which means that when a process is modifying the 
semaphore value, no other process can simultaneously 
modify that same semaphore value.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
8
Semaphore Operation
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
9
void down (S)
{
if S == 0
{
1. Add this process to the sleeping list
2. block;
}
S = S – 1;
}
void up (S)
{
S = S + 1;
If S = 1
{
1. choose one process P from the 
sleeping list or let them move to 
ready state
2. wakeup(P) to finish down operation
}
}
Semaphore Implementation
The normal way for implementing a semaphore
Implement semaphore operations up and down as 
system call.
operating system briefly disabling all interrupts while it is 
testing the semaphore, updating it and putting the 
process to sleep.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
10
Solving the Producer-Consumer Problem using 
Semaphores
#define N 100
typedef int semaphore;
semaphore mutex = 1;  //mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of item
void producer ()
{
int item;
while (ture)
{
item = produce_item(); //produce item
down (&empty); //check empty space
down (&mutex); //check mutual exclusion
insert_item(item); //insert item
up(&mutex); //out from critical section
up(&full); //increase # of item
}
}
void consumer()
{
int item;
while (true)
{
down(&full); //check item in buffer
down(&mutex) //check mutual exclusion
item = remove_item(); //remove a item
up(&mutex); //out from critical section
up(&empty); //increase the empty space
consume_item(item);
}
}
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
11
Careless usage of Semaphore causes deadlock
#define N 100
typedef int semaphore;
semaphore mutex = 1; //mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of item
void producer ()
{
int item;
while (ture)
{
item = produce_item();
down (&mutex);
down (&empty);
insert_item(item);
up(&mutex);
up(&full);
}
}
void consumer()
{
int item;
while (true)
{
down(&full)
down(&mutex)
item = remove_item();
up(&mutex);
up(&empty);
consume_item(item);
}
}
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
12
' metadata={'source': '/tmp/tmpye5dombc', 'file_path': '/tmp/tmpye5dombc', 'page': 1, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}
2024-12-19 01:10:35 - INFO - Invoking chain
2024-12-19 01:10:35 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 01:10:35 - INFO - Response: {'cleaned_content': '9/26/2024\n\nReview\n\nInter-Process Communication\n- Race Condition\n- Critical Section (or region)\n- Solutions for Mutual Exclusion in a Critical Section\n  - With Busy Waiting\n    - Disabling Interrupts – non-preemptive kernel\n    - Lock Variables – violating the first necessary condition (mutual exclusion)\n    - Strict Alternation – violating the second necessary condition (block by a process outside critical section)\n    - Peterson’s Solution\n    - Hardware Solution\n      - Test and Set Lock\n      - Memory Barriers\n      - Atomic Variable\n- Priority Inversion problems with busy waiting\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nPreview\n- Mutual Exclusion in a Critical Section\n  - With Sleep and Wake up\n- Producer Consumer Problem\n- Race Condition Producer Consumer problem\n- Semaphore\n  - Concept of Semaphore\n  - Semaphore Operation\n  - Semaphore Implementation\n  - Producer Consumer problem with semaphores\n  - Careless Usage of semaphore causes deadlock\n- Dining Philosophers Problem\n- Reader’s and Writer’s Problem\n- Mutexes\n- Monitor\n  - Implementation of Monitor\n  - Producer Consumer with Monitor\n- Message Passing\n  - Producer Consumer with Message Passing\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Sleep and Wakeup\n- Sleep and Wakeup:\n  - A process checks a resource (critical section); if not available, it goes to sleep.\n  - When the resource becomes available, the process will be woken up by the system or the process releasing the resource.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nThe Producer-Consumer Problem\nDescription\n- Two processes share a common, fixed-sized buffer.\n- Producer puts information into the buffer, and consumer takes it out.\n\nTroubles arise:\n- When the producer wants to put a new item in the buffer, but it is already full.\n- When the consumer tries to take an item from the buffer, but the buffer is already empty.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nThe Producer-Consumer Problem\n- When the producer wants to put a new item in the buffer, but it is already full.\n  - Solution: Producer goes to sleep, awakened by consumer when the consumer has removed one or more items.\n- When the consumer tries to take an item from the buffer, but the buffer is already empty.\n  - Solution: Consumer goes to sleep, awakened by the producer when the producer puts one or more items into the buffer.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nThe Producer-Consumer Problem\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\n#define N 100 // buffer size\nint count = 0; // # of items\n\nvoid producer() {\n    int item;\n    while (true) {\n        item = produce_item();\n        if (count == N) sleep();\n        insert_item(item);\n        count = count + 1;\n        if (count == 1) wakeup(consumer);\n    }\n}\n\nvoid consumer() {\n    int item;\n    while (true) {\n        if (count == 0) sleep();\n        item = remove_item();\n        count = count - 1;\n        if (count == N - 1) wakeup(producer);\n        consume_item(item);\n    }\n}'}
2024-12-19 01:10:35 - INFO - Finished clean_files_chain
2024-12-19 01:10:35 - INFO - Successfully cleaned document 1 from cosc450_11.pdf
2024-12-19 01:10:35 - INFO - Document 2 (cosc450_11.pdf) of 5
2024-12-19 01:10:35 - INFO - Starting clean_files_chain
2024-12-19 01:10:35 - INFO - Document: page_content='9/26/2024
2
Semaphores – by E. W. Dijkstra 
A semaphore is an integer variable which could have 
value 
0:  no wakeups are saved
+ i: i wakeups are pending
A semaphore is accessed only through two standard 
atomic operations down (or P) and up (or V).
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
7
Concept of Semaphores
Modification to the integer value of the semaphore in the 
down and up operations are executed indivisibly. 
Which means that when a process is modifying the 
semaphore value, no other process can simultaneously 
modify that same semaphore value.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
8
Semaphore Operation
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
9
void down (S)
{
if S == 0
{
1. Add this process to the sleeping list
2. block;
}
S = S – 1;
}
void up (S)
{
S = S + 1;
If S = 1
{
1. choose one process P from the 
sleeping list or let them move to 
ready state
2. wakeup(P) to finish down operation
}
}
Semaphore Implementation
The normal way for implementing a semaphore
Implement semaphore operations up and down as 
system call.
operating system briefly disabling all interrupts while it is 
testing the semaphore, updating it and putting the 
process to sleep.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
10
Solving the Producer-Consumer Problem using 
Semaphores
#define N 100
typedef int semaphore;
semaphore mutex = 1;  //mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of item
void producer ()
{
int item;
while (ture)
{
item = produce_item(); //produce item
down (&empty); //check empty space
down (&mutex); //check mutual exclusion
insert_item(item); //insert item
up(&mutex); //out from critical section
up(&full); //increase # of item
}
}
void consumer()
{
int item;
while (true)
{
down(&full); //check item in buffer
down(&mutex) //check mutual exclusion
item = remove_item(); //remove a item
up(&mutex); //out from critical section
up(&empty); //increase the empty space
consume_item(item);
}
}
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
11
Careless usage of Semaphore causes deadlock
#define N 100
typedef int semaphore;
semaphore mutex = 1; //mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of item
void producer ()
{
int item;
while (ture)
{
item = produce_item();
down (&mutex);
down (&empty);
insert_item(item);
up(&mutex);
up(&full);
}
}
void consumer()
{
int item;
while (true)
{
down(&full)
down(&mutex)
item = remove_item();
up(&mutex);
up(&empty);
consume_item(item);
}
}
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
12
' metadata={'source': '/tmp/tmplpxmqkix', 'file_path': '/tmp/tmplpxmqkix', 'page': 1, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}
2024-12-19 01:10:35 - INFO - Invoking chain
2024-12-19 01:10:37 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 01:10:37 - INFO - Response: {'cleaned_content': '9/17/2024\n\nReal-Time CPU Scheduling\n\n- Minimizing Latency\n- Preemptive Priority-Based Scheduling\n- Rate-Monotonic Scheduling\n- Earliest-Deadline-First Scheduling\n- Proportional Share Scheduling\n\nCriteria for selecting an algorithm\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nReal-Time CPU Scheduling\n\nCPU scheduling for real-time operating systems involves special issues. In general, we can distinguish between hard real-time systems and soft real-time systems.\n\nHard real-time systems: A task must be serviced by its deadline; service after the deadline has expired is equivalent to no service at all. Any missed deadline is considered a system failure.\n\n- An inkjet printer has a print head with control software for depositing the correct amount of ink onto a specific part of the paper. If a deadline is missed, then the print job is ruined.\n- Air France Flight 447 crashed into the ocean after a sensor malfunction caused a series of system errors.\n\nSoft real-time systems allow for frequently missed deadlines, and as long as tasks are timely executed, their results continue to have value. Completed tasks may have increasing value up to the deadline and decreasing value past it.\n\n- Weather stations have many sensors for reading temperature, humidity, wind speed, etc. The readings should be taken and transmitted at regular intervals; however, the sensors are not synchronized. Even though a sensor reading may be early or late compared with the others, it can still be relevant as long as it is close enough.\n- The sound system in a computer. If you miss a few bits, it is not a big deal, but if you miss too many, the system will eventually degrade.\n\nReal-Time CPU Scheduling (Minimizing Latency)\n\nA real-time system is typically waiting for an event in real time to occur. Events may arise either in software (as when a timer expires) or in hardware (when a remote-controlled vehicle detects that it is approaching an obstruction).\n\nWhen an event occurs, the system must respond to and service it as quickly as possible.\n\nEvent latency is the amount of time that elapses from when an event occurs to when it is serviced. Different events have different latency requirements in a system.\n\n- For an antilock brake system, the requirement is 3 to 5 milliseconds. If the antilock brake system does not respond within this time, a car accident might occur.\n\nTwo types of latencies affect the performance of real-time systems:\n\n1. Interrupt latency:\n   - When an interrupt occurs, the OS completes the instruction it is executing, determines the type of interrupt that occurred, and saves the state of the current process before servicing the interrupt using the specific interrupt service routine (ISR).\n   - Interrupt latency is the period of time from the arrival of an interrupt at the CPU to the start of the routine that services the interrupt.\n\n2. Dispatch latency: The amount of time required for the scheduling dispatcher to stop one process and start another.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park'}
2024-12-19 01:10:37 - INFO - Finished clean_files_chain
2024-12-19 01:10:37 - INFO - Successfully cleaned document 1 from 450Slides9.pdf
2024-12-19 01:10:37 - INFO - Document 2 (450Slides9.pdf) of 4
2024-12-19 01:10:37 - INFO - Starting clean_files_chain
2024-12-19 01:10:37 - INFO - Document: page_content='9/17/2024
2
Real-Time CPU Scheduling  
(Minimizing Latency)
Two types of latencies affect the performance of real-time systems
1. Interrupt latency –
2. Dispatch latency –
Dispatch latency is the amount of time required for the scheduling dispatcher 
to stop one process and start another
The most effective technique for keeping dispatch latency low is to provide 
preemptive kernels. For hard real-time systems, dispatch latency is typically 
measured in several microseconds.
Two components of conflict phase of dispatch latency:
Preemption of any process running in the kernel
Release by low-priority processes of resources needed by a high-priority process
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
7
Real-Time CPU Scheduling  
(Minimizing Latency)
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
8
Fig. Dispatch Latency
Real-Time CPU Scheduling  
(Preemptive Priority-Based Scheduling)
The most important feature of a real-time operating system is to 
respond immediately to a real-time process.
In Priority-Based scheduling, scheduler always select highest 
priority process; more important tasks are assigned higher 
priorities than those deemed less important.
With Preemptive, process currently running on the CPU will be 
preempted if a higher-priority process becomes available to run.
Preemptive, priority-based scheduler only guarantees soft real-time 
functionality
Since hard real-time system need consider deadline, the scheduler 
requires additional scheduling features.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
9
Real-Time CPU Scheduling  
Characteristics for a process require to consider for real-time CPU 
scheduler.
Period (p)- That is, process require the CPU at constant intervals (periods).
Deadline (d)
Processing time (t)–fixed processing time
The relationship of the processing time, the deadline, and the 
period can be expressed as 
0 ≤ t ≤ d ≤ p. 
The rate of a periodic task is 1∕p.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
10
Real-Time CPU Scheduling 
A process have to provide its deadline requirement to the scheduler. Then, the 
scheduler either admit the process guaranteeing that the process will complete 
on time, or rejects the request as impossible (admission-control algorithm)
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
11
Fig. Periodic task.
Real-Time CPU Scheduling  
(Rate-Monotonic Scheduling)
Rate-monotonic scheduling assumes that the processing time of a 
periodic process is the same for each CPU burst. That is, every 
time a process acquires the CPU, the duration of its CPU burst is 
the same. 
Upon entering the system, priority is assigned to a process based 
on length of period (p). The shorter the period, the higher the 
priority.
The rate-monotonic scheduling algorithm schedules periodic tasks 
using a static priority policy with preemption.
If a lower-priority process is running and a higher-priority process 
becomes available to run, it will preempt the lower-priority 
process.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
12
' metadata={'source': '/tmp/tmpedy24fk1', 'file_path': '/tmp/tmpedy24fk1', 'page': 1, 'total_pages': 4, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240917075958-04'00'", 'modDate': "D:20240917075958-04'00'", 'trapped': ''}
2024-12-19 01:10:37 - INFO - Invoking chain
2024-12-19 01:10:45 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 01:10:45 - INFO - Response: {'cleaned_content': 'Date: 9/17/2024\n\nInterprocess Communication (Race Condition)\n\nTwo approaches for mutual exclusion solutions:\n1. Busy wait – A process will wait until the resource becomes available or the CPU time term expires.\n2. Sleep and Wakeup – A process checks a resource; if it is not available, it goes to sleep. When the resource becomes available, the process will be woken up by the system or the process releases the resource.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\n---\n\nMutual Exclusion with Busy Waiting\n\nEach process has a time term. A process keeps checking the possibility of entering the critical section.\n\nMethods of Mutual Exclusion with Busy Waiting include:\n- Disabling Interrupts – non-preemptive kernel\n- Lock Variables\n- Strict Alternation\n- Peterson’s Solution\n- Hardware Solutions\n- Test and Set Lock\n- Memory Barriers\n- Atomic Variable\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\n---\n\nMutual Exclusion with Busy Waiting (Disabling Interrupt – Nonprimitive Kernel)\n\nDisabling Interrupt:\n- Once a process enters the critical section, interrupts are set to disable.\n- Other processes cannot gain CPU time until the process finishes its work in the critical section.\n- Since each user process has the power to control interrupts, it may cause a system crash.\n- A simple program can be created that disables the entire system since the user has control over system interrupts (vulnerable system).\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\n---\n\nExample: End of the system with Disabling Interrupt:\n1. A process enters the critical section.\n2. It disables all interrupts, meaning all other processes are sleeping until the job in the critical section is completed.\n3. If the process is blocked outside the critical section just before enabling all interrupts and never returns, it causes the end of the system.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\n---\n\nMutual Exclusion with Busy Waiting (Using Lock Variable)\n\nThere is a variable called "Lock":\n- A process can enter its critical section when Lock = 0.\n- Lock = 0 means no process is currently running in the critical section; the process sets Lock = 1 and enters the critical section.\n- Once a process finishes its job in the critical section, it sets Lock = 0, allowing other processes to enter the critical section.\n- Lock = 1 means there is a process running in the critical section; other processes do busy waiting until Lock becomes 0.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\n---\n\nCode Example:\nstatic int lock = 0; // lock variable is initially 0\nrepeat\n    while lock == 0 do\n        ; // (no-operation) // Busy waiting\n    lock = 1;\n    // Critical Section\n    lock = 0;\nuntil false\n// Remainder Section'}
2024-12-19 01:10:45 - INFO - Finished clean_files_chain
2024-12-19 01:10:45 - INFO - Successfully cleaned document 2 from 450Slides10.pdf
2024-12-19 01:10:45 - INFO - Document 3 (450Slides10.pdf) of 5
2024-12-19 01:10:45 - INFO - Starting clean_files_chain
2024-12-19 01:10:45 - INFO - Document: page_content='9/17/2024
3
Mutual Exclusion with Busy Waiting
(Using Lock Variable)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
13
static int lock = 0; //lock is initially 0
repeat
while lock 0 do
; (no-operation) //busy waiting
lock = 1;
lock = 0;
until false
Critical Section
Remainder Section
Scenario)
1.
Initially lock = 0.
2.
A process P1 tries get into critical section.
The process P1 check lock value = 0.
3.
Process P1 CPU time is over and go to
ready state, before updating lock = 1.
4.
Process P2 tries get into critical section.
P2 check lock value lock = 0
5.
P2 set lock = 1 and go to critical section.
6.
P2 CPU time is over and P1 is rescheduled.
7.
P1 already read lock = 0, P1 set lock = 1
and go to Critical section. Now P1 and P2
are in the critical section at the same
time
Violating condition #1: mutual exclusion
Mutual Exclusion with Busy Waiting
(Strict Alternation)
Variable turn can be i or j.
if turn = i, process Pi can go to the
critical section.
Once Pi finish its job in critical
section, Pi set turn = j, let process
Pj enter critical section
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
14
Critical Section
Remainder Section
turn is i or j
repeat
while turn i do
; (no-operation)
turn = j;
until false
Mutual Exclusion with Busy Waiting
(Strict Alternation)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
15
Critical Section
Remainder Section
turn is i or j
repeat
while turn i do
; (no-operation)
turn = j;
until false
Let assume initially turn = 0
1.
P0 is in CS while P1 is in remaining
section.
2.
P0 done C.S. and set turn = 1, P1 is
still in remaining section.
3.
P0 done remaining section and want
to go to C.S. but turn= 1.
4.
P1 has fatal error in remainder
section and trapped out by OS.
5.
P0 is waiting forever to enter the C.S.
Violating #2 and #3 condition
2.
No process running outside its critical
region may block other processes
3.
No process should have to wait forever to
enter critical region
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
Peterson’s solution provides a good algorithmic description of
solving the critical-section problem and illustrates some of the
complexities involved in designing software that addresses the
requirements of mutual exclusion, progress, and bounded waiting.
Peterson’s solution is restricted to two processes that alternate
execution between their critical sections and remainder sections.
The processes are numbered P0 and P1.
For convenience, when presenting Pi, we use Pj to denote the other
process; that is, j equals 1 −i.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
16
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
17
#define false 0
#define true 1
#define n 2
int turn
int interested[n]
void enter_region(int process);
{
int other;
other = 1 – process
interested[process] = true
turn = process;
while (turn ==process && interest[other]==true)
; /*no operation –busy waiting*/
}
void leave_region(int process)
{
interest[process] = false;
}
void main()
{
repeat
enter_region (int i)
Critical Section
leave_resion (int i)
Remainder Section
until false
}
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
1.
Initially, neither process is in the critical section
2.
A process P0 call enter_region (0)
a)
Set interested[0] = true;
b)
Set turn = 0
3.
go to critical section
4.
the process P1 call enter_region(1) to get into its critical section
a)
set interested[1] = true;
b)
set turn = 1;
5.
since interested[0] = true, it is keep looping for interest [0] =
false
6.
finally process P0 finish its critical section and call leave_region(0)
1.
set interested[0] = false
7.
now P1 find out interest[0] = false, P1 goes to its critical section
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
18
' metadata={'source': '/tmp/tmp50p_945n', 'file_path': '/tmp/tmp50p_945n', 'page': 2, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-19 01:10:45 - INFO - Invoking chain
2024-12-19 01:10:46 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 01:10:46 - INFO - Response: {'cleaned_content': 'Date: 9/26/2024\n\nSemaphores – by E. W. Dijkstra\n\nA semaphore is an integer variable which could have the following values:\n- 0: no wakeups are saved\n- +i: i wakeups are pending\n\nA semaphore is accessed only through two standard atomic operations: down (or P) and up (or V).\n\nConcept of Semaphores\n\nThe modification to the integer value of the semaphore in the down and up operations is executed indivisibly. This means that when a process is modifying the semaphore value, no other process can simultaneously modify that same semaphore value.\n\nSemaphore Operations\n\nThe following is the implementation of the semaphore operations:\n\nvoid down(S) {\n    if (S == 0) {\n        1. Add this process to the sleeping list\n        2. block;\n    }\n    S = S - 1;\n}\n\nvoid up(S) {\n    S = S + 1;\n    if (S == 1) {\n        1. Choose one process P from the sleeping list or let them move to ready state\n        2. wakeup(P) to finish down operation\n    }\n}\n\nSemaphore Implementation\n\nThe normal way of implementing a semaphore is to:\n- Implement semaphore operations up and down as system calls.\n- The operating system briefly disables all interrupts while it is testing the semaphore, updating it, and putting the process to sleep.\n\nSolving the Producer-Consumer Problem using Semaphores\n\n#define N 100\ntypedef int semaphore;\nsemaphore mutex = 1;  // mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of items\n\nvoid producer() {\n    int item;\n    while (true) {\n        item = produce_item(); // produce item\n        down(&empty); // check empty space\n        down(&mutex); // check mutual exclusion\n        insert_item(item); // insert item\n        up(&mutex); // out from critical section\n        up(&full); // increase # of items\n    }\n}\n\nvoid consumer() {\n    int item;\n    while (true) {\n        down(&full); // check item in buffer\n        down(&mutex); // check mutual exclusion\n        item = remove_item(); // remove an item\n        up(&mutex); // out from critical section\n        up(&empty); // increase the empty space\n        consume_item(item);\n    }\n}\n\nCareless usage of Semaphore causes deadlock\n\n#define N 100\ntypedef int semaphore;\nsemaphore mutex = 1; // mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of items\n\nvoid producer() {\n    int item;\n    while (true) {\n        item = produce_item();\n        down(&mutex);\n        down(&empty);\n        insert_item(item);\n        up(&mutex);\n        up(&full);\n    }\n}\n\nvoid consumer() {\n    int item;\n    while (true) {\n        down(&full);\n        down(&mutex);\n        item = remove_item();\n        up(&mutex);\n        up(&empty);\n        consume_item(item);\n    }\n}'}
2024-12-19 01:10:46 - INFO - Finished clean_files_chain
2024-12-19 01:10:46 - INFO - Successfully cleaned document 2 from 450Slides11.pdf
2024-12-19 01:10:46 - INFO - Document 3 (450Slides11.pdf) of 5
2024-12-19 01:10:46 - INFO - Starting clean_files_chain
2024-12-19 01:10:46 - INFO - Document: page_content='9/26/2024
3
Careless usage of Semaphore causes deadlock
#define N 100
typedef int semaphore;
semaphore mutex = 1; //mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of item
void producer ()
{
int item;
while (ture)
{
item = produce_item();
down (&empty);
down (&mutex);
insert_item(item);
up(&mutex);
up(&full);
}
}
void consumer()
{
int item;
while (true)
{
down(&mutex);
down(&full);
item = remove_item();
up(&mutex);
up(&empty);
consume_item(item);
}
}
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
13
Dining Philosophers Problem
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
14
Dining Philosophers Problem
Five silent philosophers sit at a round table with bowls of spaghetti. Chopsticks 
are placed between each pair of adjacent philosophers.
Each philosopher must alternately think and eat. However, a philosopher can 
only eat spaghetti when they have both left and right chopsticks. 
Each chopstick can be held by only one philosopher and so a philosopher can use 
the chopstick only if it is not being used by another philosopher. 
After an individual philosopher finishes eating, they need to put down both 
chopsticks so that the chopstick s become available to others. A philosopher can 
take the chopstick on their right or the one on their left as they become 
available, but cannot start eating before getting both chopsticks.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
15
Readers-Writers Problem
Process reader R and writers W are sharing resources at one time. 
Only one process (reader or writer) can access the shared 
resources at any time.
1. It is possible that a reader R1 might have the lock to a shared resource, and 
then another reader R2 requests access. It would be foolish for R2 to wait 
until R1 was done before starting its own read operation; instead R1 and R2
can read same resource at the same time since both are reading.
2. It is possible that a reader R1 might have the lock, a writer W be waiting for 
the lock, and then a reader R2 requests access. It would be unfair for R2 to 
jump in immediately, ahead of W; if that happened often 
enough, W would starve.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
16
Readers-Writers Problem
W2
R3
W1
R2
R1
W2
W1
R1
R2
R3
R4
R3
R2
W1
R1
W1
R1
R4
R2
R3
Unfair for W1 (starvation)
Might be better
Shared resource(database)
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
17
Mutexes
When the semaphore's ability to count is not needed, the simplified 
version of the semaphore, called mutex is used.
It is good for managing a mutual exclusion to some shared 
resources or pieces of code
It is useful in thread packages that are implemented in user’s 
space.
A mutex is a variable that can be in one of two state: unlocked (0), 
locked(1).
A mutex concept is same as binary semaphore which has value 0 
or 1.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
18
' metadata={'source': '/tmp/tmpye5dombc', 'file_path': '/tmp/tmpye5dombc', 'page': 2, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}
2024-12-19 01:10:46 - INFO - Invoking chain
2024-12-19 01:10:46 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 01:10:46 - INFO - Response: {'cleaned_content': '9/26/2024\n\nSemaphores – by E. W. Dijkstra\n\nA semaphore is an integer variable which could have the following values:\n\n0: no wakeups are saved\n+ i: i wakeups are pending\n\nA semaphore is accessed only through two standard atomic operations: down (or P) and up (or V).\n\nConcept of Semaphores\n\nModification to the integer value of the semaphore in the down and up operations are executed indivisibly. This means that when a process is modifying the semaphore value, no other process can simultaneously modify that same semaphore value.\n\nSemaphore Operation\n\nvoid down (S)\n{\n    if S == 0\n    {\n        1. Add this process to the sleeping list\n        2. block;\n    }\n    S = S - 1;\n}\n\nvoid up (S)\n{\n    S = S + 1;\n    if S == 1\n    {\n        1. choose one process P from the sleeping list or let them move to ready state\n        2. wakeup(P) to finish down operation\n    }\n}\n\nSemaphore Implementation\n\nThe normal way for implementing a semaphore is as follows:\n- Implement semaphore operations up and down as system calls.\n- The operating system briefly disables all interrupts while it is testing the semaphore, updating it, and putting the process to sleep.\n\nSolving the Producer-Consumer Problem using Semaphores\n\n#define N 100\n\ntypedef int semaphore;\nsemaphore mutex = 1;  // mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of items\n\nvoid producer ()\n{\n    int item;\n    while (true)\n    {\n        item = produce_item(); // produce item\n        down (&empty); // check empty space\n        down (&mutex); // check mutual exclusion\n        insert_item(item); // insert item\n        up(&mutex); // out from critical section\n        up(&full); // increase # of items\n    }\n}\n\nvoid consumer()\n{\n    int item;\n    while (true)\n    {\n        down(&full); // check item in buffer\n        down(&mutex); // check mutual exclusion\n        item = remove_item(); // remove an item\n        up(&mutex); // out from critical section\n        up(&empty); // increase the empty space\n        consume_item(item);\n    }\n}\n\nCareless usage of Semaphore causes deadlock\n\n#define N 100\n\ntypedef int semaphore;\nsemaphore mutex = 1; // mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of items\n\nvoid producer ()\n{\n    int item;\n    while (true)\n    {\n        item = produce_item();\n        down (&mutex);\n        down (&empty);\n        insert_item(item);\n        up(&mutex);\n        up(&full);\n    }\n}\n\nvoid consumer()\n{\n    int item;\n    while (true)\n    {\n        down(&full);\n        down(&mutex);\n        item = remove_item();\n        up(&mutex);\n        up(&empty);\n        consume_item(item);\n    }\n}'}
2024-12-19 01:10:46 - INFO - Finished clean_files_chain
2024-12-19 01:10:46 - INFO - Successfully cleaned document 2 from cosc450_11.pdf
2024-12-19 01:10:46 - INFO - Document 3 (cosc450_11.pdf) of 5
2024-12-19 01:10:46 - INFO - Starting clean_files_chain
2024-12-19 01:10:46 - INFO - Document: page_content='9/26/2024
3
Careless usage of Semaphore causes deadlock
#define N 100
typedef int semaphore;
semaphore mutex = 1; //mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of item
void producer ()
{
int item;
while (ture)
{
item = produce_item();
down (&empty);
down (&mutex);
insert_item(item);
up(&mutex);
up(&full);
}
}
void consumer()
{
int item;
while (true)
{
down(&mutex);
down(&full);
item = remove_item();
up(&mutex);
up(&empty);
consume_item(item);
}
}
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
13
Dining Philosophers Problem
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
14
Dining Philosophers Problem
Five silent philosophers sit at a round table with bowls of spaghetti. Chopsticks 
are placed between each pair of adjacent philosophers.
Each philosopher must alternately think and eat. However, a philosopher can 
only eat spaghetti when they have both left and right chopsticks. 
Each chopstick can be held by only one philosopher and so a philosopher can use 
the chopstick only if it is not being used by another philosopher. 
After an individual philosopher finishes eating, they need to put down both 
chopsticks so that the chopstick s become available to others. A philosopher can 
take the chopstick on their right or the one on their left as they become 
available, but cannot start eating before getting both chopsticks.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
15
Readers-Writers Problem
Process reader R and writers W are sharing resources at one time. 
Only one process (reader or writer) can access the shared 
resources at any time.
1. It is possible that a reader R1 might have the lock to a shared resource, and 
then another reader R2 requests access. It would be foolish for R2 to wait 
until R1 was done before starting its own read operation; instead R1 and R2
can read same resource at the same time since both are reading.
2. It is possible that a reader R1 might have the lock, a writer W be waiting for 
the lock, and then a reader R2 requests access. It would be unfair for R2 to 
jump in immediately, ahead of W; if that happened often 
enough, W would starve.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
16
Readers-Writers Problem
W2
R3
W1
R2
R1
W2
W1
R1
R2
R3
R4
R3
R2
W1
R1
W1
R1
R4
R2
R3
Unfair for W1 (starvation)
Might be better
Shared resource(database)
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
17
Mutexes
When the semaphore's ability to count is not needed, the simplified 
version of the semaphore, called mutex is used.
It is good for managing a mutual exclusion to some shared 
resources or pieces of code
It is useful in thread packages that are implemented in user’s 
space.
A mutex is a variable that can be in one of two state: unlocked (0), 
locked(1).
A mutex concept is same as binary semaphore which has value 0 
or 1.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
18
' metadata={'source': '/tmp/tmplpxmqkix', 'file_path': '/tmp/tmplpxmqkix', 'page': 2, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}
2024-12-19 01:10:46 - INFO - Invoking chain
2024-12-19 01:10:48 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 01:10:48 - INFO - Response: {'cleaned_content': '9/17/2024\n\nReal-Time CPU Scheduling (Minimizing Latency)\n\nTwo types of latencies affect the performance of real-time systems:\n1. Interrupt latency\n2. Dispatch latency\n\nDispatch latency is the amount of time required for the scheduling dispatcher to stop one process and start another. The most effective technique for keeping dispatch latency low is to provide preemptive kernels. For hard real-time systems, dispatch latency is typically measured in several microseconds.\n\nTwo components of the conflict phase of dispatch latency are:\n1. Preemption of any process running in the kernel\n2. Release by low-priority processes of resources needed by a high-priority process\n\nReal-Time CPU Scheduling (Preemptive Priority-Based Scheduling)\n\nThe most important feature of a real-time operating system is to respond immediately to a real-time process. In priority-based scheduling, the scheduler always selects the highest priority process; more important tasks are assigned higher priorities than those deemed less important. With preemptive scheduling, a process currently running on the CPU will be preempted if a higher-priority process becomes available to run. A preemptive, priority-based scheduler only guarantees soft real-time functionality. Since hard real-time systems need to consider deadlines, the scheduler requires additional scheduling features.\n\nCharacteristics for a process that must be considered for real-time CPU scheduling:\n- Period (p): The process requires the CPU at constant intervals (periods).\n- Deadline (d)\n- Processing time (t): Fixed processing time\n\nThe relationship of the processing time, the deadline, and the period can be expressed as:\n0 ≤ t ≤ d ≤ p.\n\nThe rate of a periodic task is 1/p.\n\nA process must provide its deadline requirement to the scheduler. Then, the scheduler either admits the process, guaranteeing that the process will complete on time, or rejects the request as impossible (admission-control algorithm).\n\nReal-Time CPU Scheduling (Rate-Monotonic Scheduling)\n\nRate-monotonic scheduling assumes that the processing time of a periodic process is the same for each CPU burst. That is, every time a process acquires the CPU, the duration of its CPU burst is the same. Upon entering the system, priority is assigned to a process based on the length of the period (p). The shorter the period, the higher the priority. The rate-monotonic scheduling algorithm schedules periodic tasks using a static priority policy with preemption. If a lower-priority process is running and a higher-priority process becomes available to run, it will preempt the lower-priority process.'}
2024-12-19 01:10:48 - INFO - Finished clean_files_chain
2024-12-19 01:10:48 - INFO - Successfully cleaned document 2 from 450Slides9.pdf
2024-12-19 01:10:48 - INFO - Document 3 (450Slides9.pdf) of 4
2024-12-19 01:10:48 - INFO - Starting clean_files_chain
2024-12-19 01:10:48 - INFO - Document: page_content='9/17/2024
3
Real-Time CPU Scheduling  
(Rate-Monotonic Scheduling)
Ex) Two process P1, P2
p1= 50, t1=20, d1= by the start of its next period
CPU utilization of P1= p1/t1=20/50 = 0.4
p2=100, t2=35, d2 = by the start of its next period
CPU utilization of P1= p2/t2=35/100 = 0.35
Since t1 t2, P1 has higher priority than P2
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
13
110
0
120
150
160
170
180
190
200
130
140
100
30
40
50
60
70
80
90
20
10
P2
P1
P1
P2
P2
P1
P1
P2
p2
p1
p1
p1
p2
P1 ,P2 deadline =200
P1 deadline =150
P1 deadline =50
P1 ,P2 deadline =100
Real-Time CPU Scheduling  
(Rate-Monotonic Scheduling)
Ex) Two process P1, P2
p1= 50, t1=25, d1= by the start of its next period
CPU utilization of P1= p1/t1=25/50 = 0.5
p2=80, t2=35, d2 = by the start of its next period
CPU utilization of P2 = p2/t2=35/80 = 0.4375
Since t1 t2, P1 has higher priority than P2
rate-monotonic scheduling cannot guarantee that they can be scheduled so that they 
meet their deadlines.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
14
110
0
120
150
160
170
180
190
200
130
140
100
30
40
50
60
70
80
90
20
10
P2
P1
P1
P2
p2
p1
P1 deadline =50
p2
p2
p1
p1
p1
P2 deadline =80
Real-Time CPU Scheduling  
(Earliest-Deadline-First Scheduling)
Earliest-deadline-firs (EDF) scheduling assigns priorities 
dynamically according to deadline. 
The earlier the deadline, the higher the priority; 
The later the deadline, the lower the priority
When a process becomes runnable (ready state), it must 
announce its deadline requirements to the system. 
Priorities have to be adjusted to reflect the deadline of 
the newly runnable process.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
15
P2
P1
P2
P1
P2
P1
Real-Time CPU Scheduling  
(Earliest-Deadline-First Scheduling)
Ex) Two process P1, P2
p1= 50, t1=25, d1= by the start of its next period
CPU utilization of P1= p1/t1=25/50 = 0.5
p2=80, t2=35, d2 = by the start of its next period
CPU utilization of P2 = p2/t2=35/80 = 0.4375
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
16
110
0
120
150
160
170
180
190
200
130
140
100
30
40
50
60
70
80
90
20
10
p1
P2
p2
p2
p1
p1
p1
p2
P1
P1
P2
P1
Real-Time CPU Scheduling  
(Earliest-Deadline-First Scheduling)
EDF scheduling is theoretically optimal—theoretically, it 
can schedule processes so that each process can meet its 
deadline requirements and CPU utilization will be 100 
percent. 
In practice, it is not possible to achieve this level of CPU 
utilization due to the cost of context switching between 
processes and interrupt handling.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
17
Real-Time CPU Scheduling  
(Proportional Share Scheduling)
Proportional share schedulers operate by allocating T shares 
among all processes.
An process can receive N shares of time, ensuring that the process 
will have N∕T of the total processor time.
Ex) There are three processes P1, P2, and P3. And, total of share T 
= 100.
P1 is assigned 50 shares, P2 is assigned 15 shares, and P3 is assigned 20 
shares.
Means that P1 will have 50 %, P2 will have 15 %, and P3 will have 20 % of 
total processor time.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
18
' metadata={'source': '/tmp/tmpedy24fk1', 'file_path': '/tmp/tmpedy24fk1', 'page': 2, 'total_pages': 4, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240917075958-04'00'", 'modDate': "D:20240917075958-04'00'", 'trapped': ''}
2024-12-19 01:10:48 - INFO - Invoking chain
2024-12-19 01:10:56 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 01:10:56 - INFO - Response: {'cleaned_content': "Date: 9/26/2024\n\nCareless usage of Semaphore causes deadlock\n\n#define N 100\n\ntypedef int semaphore;\nsemaphore mutex = 1; // mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of items\n\nvoid producer () {\n    int item;\n    while (true) {\n        item = produce_item();\n        down(&empty);\n        down(&mutex);\n        insert_item(item);\n        up(&mutex);\n        up(&full);\n    }\n}\n\nvoid consumer() {\n    int item;\n    while (true) {\n        down(&mutex);\n        down(&full);\n        item = remove_item();\n        up(&mutex);\n        up(&empty);\n        consume_item(item);\n    }\n}\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nDining Philosophers Problem\n\nFive silent philosophers sit at a round table with bowls of spaghetti. Chopsticks are placed between each pair of adjacent philosophers.\nEach philosopher must alternately think and eat. However, a philosopher can only eat spaghetti when they have both left and right chopsticks.\nEach chopstick can be held by only one philosopher and so a philosopher can use the chopstick only if it is not being used by another philosopher.\nAfter an individual philosopher finishes eating, they need to put down both chopsticks so that the chopsticks become available to others. A philosopher can take the chopstick on their right or the one on their left as they become available, but cannot start eating before getting both chopsticks.\n\nReaders-Writers Problem\n\nProcess reader R and writers W are sharing resources at one time. Only one process (reader or writer) can access the shared resources at any time.\n1. It is possible that a reader R1 might have the lock to a shared resource, and then another reader R2 requests access. It would be foolish for R2 to wait until R1 was done before starting its own read operation; instead, R1 and R2 can read the same resource at the same time since both are reading.\n2. It is possible that a reader R1 might have the lock, a writer W be waiting for the lock, and then a reader R2 requests access. It would be unfair for R2 to jump in immediately ahead of W; if that happened often enough, W would starve.\n\nMutexes\n\nWhen the semaphore's ability to count is not needed, the simplified version of the semaphore, called mutex, is used. It is good for managing mutual exclusion to some shared resources or pieces of code. It is useful in thread packages that are implemented in user space.\nA mutex is a variable that can be in one of two states: unlocked (0) or locked (1). A mutex concept is the same as a binary semaphore which has a value of 0 or 1."}
2024-12-19 01:10:56 - INFO - Finished clean_files_chain
2024-12-19 01:10:56 - INFO - Successfully cleaned document 3 from cosc450_11.pdf
2024-12-19 01:10:56 - INFO - Document 4 (cosc450_11.pdf) of 5
2024-12-19 01:10:56 - INFO - Starting clean_files_chain
2024-12-19 01:10:56 - INFO - Document: page_content='9/26/2024
4
Mutexes
mutexes mutex = 0
repeat
mutex_lock (mutex);
mutex_unlock (mutex);
until false
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
19
Critical Section
Remainder Section
Monitor

Monitor – High level synchronizing primitive 

A collection of procedures, variables, and data structures that are all grouped 
together in a special kind of module.

Only one process can be active in a monitor at any instant.

Compiler knows that monitors are special and can handle calls to monitor 
procedure differently from other procedure call (create special code for 
monitor).

When a process call a procedure inside a monitor, 
1.
check whether any process is active within monitor or not. 
2.
If so, the calling process will be suspended until the other process has left the 
monitor.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
20
Implementation of Monitor
Since monitor is a construct for a programming 
language, Monitor implementation is based on the 
compiler
Compiler knows monitor is special kind of module, 
compiler use mutex or binary semaphore for mutual 
exclusion.
Monitor provide an easy way to achieve mutual exclusion. 
But we need to consider, how a process can be blocked 
and how blocked process can be waked up?
Introduction of Condition variables
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
21
Implementation of Monitor
Conditional variables are used in the monitor. 
There are two operation on the conditional variables (wait, signal).
When a monitor procedure discovers that it cannot continue, it does wait 
on some condition variable (ex full). This action causes the calling 
process to block. – allows other process get into the monitor.
Other process (ex. consumer) can wake up its sleeping partner by doing 
a signal on the condition variable that its partner is waiting on.
If there are more than one processes are waiting on a condition variable, 
system scheduler choose one of them 
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
22
Implementation of Monitor
Once a process do a signal, what is next step for the process do a 
signal, to avoid having two active processes in the monitor at the 
same time?
Solution 1) by Hoare
Letting the newly awakened process run, suspending the one do the signal
Solution 2) by Brinch Hansen
A signal statement may appear only as the final statement in a monitor 
procedure.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
23
Producer-Consumer with Monitor
monitor ProducerConsumer
condition full, empty;
integer count;
procedure insert (item: integer);
begin
if count = N then
wait (full);
insert_item(item);
count :=count + 1;
if count = 1 then
signal (empty)
end;
function remove: integer;
begin
if count = 0 then
wait (empty);
remove = remove_item;
count := count – 1;
if count = N – 1 then
signal (full);
end;
count := 0;
end monitor
procedure producer
begin
while true do
begin
item = produce_item;
ProducerConsumer.insert(item)
end
end;
procedure consumer;
begin
while true do
begin
item = ProducerConsumer.remove;
consume_item(item)
end
end;
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
24
' metadata={'source': '/tmp/tmplpxmqkix', 'file_path': '/tmp/tmplpxmqkix', 'page': 3, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}
2024-12-19 01:10:56 - INFO - Invoking chain
2024-12-19 01:10:56 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 01:10:56 - INFO - Response: {'cleaned_content': "Date: 9/26/2024\n\nCareless usage of Semaphore causes deadlock\n\n#define N 100\n\ntypedef int semaphore;\nsemaphore mutex = 1; // mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of items\n\nvoid producer ()\n{\n    int item;\n    while (true)\n    {\n        item = produce_item();\n        down(&empty);\n        down(&mutex);\n        insert_item(item);\n        up(&mutex);\n        up(&full);\n    }\n}\n\nvoid consumer()\n{\n    int item;\n    while (true)\n    {\n        down(&mutex);\n        down(&full);\n        item = remove_item();\n        up(&mutex);\n        up(&empty);\n        consume_item(item);\n    }\n}\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\n---\n\nDining Philosophers Problem\n\nFive silent philosophers sit at a round table with bowls of spaghetti. Chopsticks are placed between each pair of adjacent philosophers.\n\nEach philosopher must alternately think and eat. However, a philosopher can only eat spaghetti when they have both left and right chopsticks. Each chopstick can be held by only one philosopher, and so a philosopher can use the chopstick only if it is not being used by another philosopher. After an individual philosopher finishes eating, they need to put down both chopsticks so that the chopsticks become available to others. A philosopher can take the chopstick on their right or the one on their left as they become available, but cannot start eating before getting both chopsticks.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\n---\n\nReaders-Writers Problem\n\nProcess readers (R) and writers (W) are sharing resources at one time. Only one process (reader or writer) can access the shared resources at any time.\n\n1. It is possible that a reader R1 might have the lock to a shared resource, and then another reader R2 requests access. It would be foolish for R2 to wait until R1 was done before starting its own read operation; instead, R1 and R2 can read the same resource at the same time since both are reading.\n\n2. It is possible that a reader R1 might have the lock, a writer W be waiting for the lock, and then a reader R2 requests access. It would be unfair for R2 to jump in immediately ahead of W; if that happened often enough, W would starve.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\n---\n\nMutexes\n\nWhen the semaphore's ability to count is not needed, the simplified version of the semaphore, called mutex, is used. It is good for managing mutual exclusion to some shared resources or pieces of code. It is useful in thread packages that are implemented in user space. A mutex is a variable that can be in one of two states: unlocked (0) or locked (1). A mutex concept is the same as a binary semaphore which has value 0 or 1."}
2024-12-19 01:10:56 - INFO - Finished clean_files_chain
2024-12-19 01:10:56 - INFO - Successfully cleaned document 3 from 450Slides11.pdf
2024-12-19 01:10:56 - INFO - Document 4 (450Slides11.pdf) of 5
2024-12-19 01:10:56 - INFO - Starting clean_files_chain
2024-12-19 01:10:56 - INFO - Document: page_content='9/26/2024
4
Mutexes
mutexes mutex = 0
repeat
mutex_lock (mutex);
mutex_unlock (mutex);
until false
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
19
Critical Section
Remainder Section
Monitor

Monitor – High level synchronizing primitive 

A collection of procedures, variables, and data structures that are all grouped 
together in a special kind of module.

Only one process can be active in a monitor at any instant.

Compiler knows that monitors are special and can handle calls to monitor 
procedure differently from other procedure call (create special code for 
monitor).

When a process call a procedure inside a monitor, 
1.
check whether any process is active within monitor or not. 
2.
If so, the calling process will be suspended until the other process has left the 
monitor.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
20
Implementation of Monitor
Since monitor is a construct for a programming 
language, Monitor implementation is based on the 
compiler
Compiler knows monitor is special kind of module, 
compiler use mutex or binary semaphore for mutual 
exclusion.
Monitor provide an easy way to achieve mutual exclusion. 
But we need to consider, how a process can be blocked 
and how blocked process can be waked up?
Introduction of Condition variables
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
21
Implementation of Monitor
Conditional variables are used in the monitor. 
There are two operation on the conditional variables (wait, signal).
When a monitor procedure discovers that it cannot continue, it does wait 
on some condition variable (ex full). This action causes the calling 
process to block. – allows other process get into the monitor.
Other process (ex. consumer) can wake up its sleeping partner by doing 
a signal on the condition variable that its partner is waiting on.
If there are more than one processes are waiting on a condition variable, 
system scheduler choose one of them 
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
22
Implementation of Monitor
Once a process do a signal, what is next step for the process do a 
signal, to avoid having two active processes in the monitor at the 
same time?
Solution 1) by Hoare
Letting the newly awakened process run, suspending the one do the signal
Solution 2) by Brinch Hansen
A signal statement may appear only as the final statement in a monitor 
procedure.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
23
Producer-Consumer with Monitor
monitor ProducerConsumer
condition full, empty;
integer count;
procedure insert (item: integer);
begin
if count = N then
wait (full);
insert_item(item);
count :=count + 1;
if count = 1 then
signal (empty)
end;
function remove: integer;
begin
if count = 0 then
wait (empty);
remove = remove_item;
count := count – 1;
if count = N – 1 then
signal (full);
end;
count := 0;
end monitor
procedure producer
begin
while true do
begin
item = produce_item;
ProducerConsumer.insert(item)
end
end;
procedure consumer;
begin
while true do
begin
item = ProducerConsumer.remove;
consume_item(item)
end
end;
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
24
' metadata={'source': '/tmp/tmpye5dombc', 'file_path': '/tmp/tmpye5dombc', 'page': 3, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}
2024-12-19 01:10:56 - INFO - Invoking chain
2024-12-19 01:10:59 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 01:10:59 - INFO - Response: {'cleaned_content': "9/17/2024\n\nMutual Exclusion with Busy Waiting (Using Lock Variable)\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nstatic int lock = 0; // lock is initially 0\nrepeat\n    while lock == 0 do\n        ; // (no-operation) // busy waiting\n    lock = 1;\n    lock = 0;\nuntil false\n\nCritical Section\nRemainder Section\n\nScenario:\n1. Initially lock = 0.\n2. A process P1 tries to get into the critical section.\n3. The process P1 checks lock value = 0.\n4. Process P1's CPU time is over and goes to the ready state, before updating lock = 1.\n5. Process P2 tries to get into the critical section.\n6. P2 checks lock value = 0.\n7. P2 sets lock = 1 and goes to the critical section.\n8. P2's CPU time is over and P1 is rescheduled.\n9. P1 has already read lock = 0, P1 sets lock = 1 and goes to the critical section. Now P1 and P2 are in the critical section at the same time.\n\nViolating condition #1: mutual exclusion\n\nMutual Exclusion with Busy Waiting (Strict Alternation)\n- Variable turn can be i or j.\n- If turn = i, process Pi can go to the critical section.\n- Once Pi finishes its job in the critical section, Pi sets turn = j, allowing process Pj to enter the critical section.\n\nCritical Section\nRemainder Section\n\nturn is i or j\nrepeat\n    while turn == i do\n        ; // (no-operation)\nuntil false\n\nLet’s assume initially turn = 0:\n1. P0 is in the critical section while P1 is in the remainder section.\n2. P0 finishes the critical section and sets turn = 1; P1 is still in the remainder section.\n3. P0 finishes the remainder section and wants to go to the critical section, but turn = 1.\n4. P1 has a fatal error in the remainder section and is trapped out by the operating system.\n5. P0 is waiting forever to enter the critical section.\n\nViolating conditions #2 and #3:\n2. No process running outside its critical region may block other processes.\n3. No process should have to wait forever to enter the critical region.\n\nMutual Exclusion with Busy Waiting (Peterson’s Solution)\n- Peterson’s solution provides a good algorithmic description of solving the critical-section problem and illustrates some of the complexities involved in designing software that addresses the requirements of mutual exclusion, progress, and bounded waiting.\n- Peterson’s solution is restricted to two processes that alternate execution between their critical sections and remainder sections.\n- The processes are numbered P0 and P1.\n- For convenience, when presenting Pi, we use Pj to denote the other process; that is, j equals 1 - i.\n\n#define false 0\n#define true 1\n#define n 2\nint turn;\nint interested[n];\n\nvoid enter_region(int process) {\n    int other;\n    other = 1 - process;\n    interested[process] = true;\n    turn = process;\n    while (turn == process && interested[other] == true)\n        ; // no operation – busy waiting\n}\n\nvoid leave_region(int process) {\n    interested[process] = false;\n}\n\nvoid main() {\n    repeat\n        enter_region(int i);\n        // Critical Section\n        leave_region(int i);\n        // Remainder Section\n    until false;\n}\n\nMutual Exclusion with Busy Waiting (Peterson’s Solution)\n1. Initially, neither process is in the critical section.\n2. A process P0 calls enter_region(0):\n   a) Set interested[0] = true;\n   b) Set turn = 0.\n3. Go to the critical section.\n4. The process P1 calls enter_region(1) to get into its critical section:\n   a) Set interested[1] = true;\n   b) Set turn = 1.\n5. Since interested[0] = true, it keeps looping for interested[0] = false.\n6. Finally, process P0 finishes its critical section and calls leave_region(0):\n   1. Set interested[0] = false.\n7. Now P1 finds out interested[0] = false, and P1 goes to its critical section."}
2024-12-19 01:10:59 - INFO - Finished clean_files_chain
2024-12-19 01:10:59 - INFO - Successfully cleaned document 3 from 450Slides10.pdf
2024-12-19 01:10:59 - INFO - Document 4 (450Slides10.pdf) of 5
2024-12-19 01:10:59 - INFO - Starting clean_files_chain
2024-12-19 01:10:59 - INFO - Document: page_content='9/17/2024
4
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
Prove for Peterson’s Solution)

Lets consider the case both P0 and P1 call enter_region(0) and enter_region(1) almost
simultaneously.

Lets interest[0]= true and interest[1] = true at the same time

But turn can be only turn = 0 or turn = 1 which ever store is done last is the one that
counts!!
Case 1) turn = 0
Inside enter_region(0)
◼
Since turn =0 and interest [1] = ture, P0 keep looping in no-operation until P1 set interested[1] =
false.
Inside enter_region(1)
◼
Since turn = 0 and interest[0] = true, P1 goes to its critical section.
Case 2) turn = 1
Inside enter_region(0)
◼
Since turn =1 and interest [1] = ture,. P0 goes to its critical section
Inside enter_region(1)
◼
Since turn = 1 and interest[0] = true, P1 keep looping in no-operation until P0 set interested[0] =
false.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
19
Mutual Exclusion with Busy Waiting
(Test and Set Lock – hardware solution)

Since TSL instruction is a hardware instruction. The operations of reading the
lock and storing into register are guaranteed to be indivisible.

Instruction test and set lock
TSL RX, LOCK
1. Read the content at the memory address of LOCK into register RX.
2. Store a non-zero value at the memory address of LOCK

The operations of reading the content of LOCK and storing into it are guaranteed
to be indivisible.

How to use Test and Set Lock instruction for solving race condition?
◼
When LOCK = 0, any process may set LOCK = 1 by using TSL instruction and go to
its critical section.
◼
When the process finish its critical section, set LOCK = 0 using the original move
instruction.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
20
Mutual Exclusion with Busy Waiting
(Test and Set Lock – hardware solution)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
21
Enter_region
TSL Register, LOCK
CMP Register, #0
JNE Enter_region
Set LOCK, #1
RET
Leave_region
MOVE LOCK, #0
RET
Repeat
Enter_region
Leave_region
until false
Critical Section
Remainder Section
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
Two general memory models
◼Strongly ordered Memory –a memory modification on one processor is
immediately visible to all other processors
◼Weakly ordered Memory – a memory modification on one processor may not
be immediately visible to other processors.
With Strongly ordered memory, computer architectures provide
instructions that can force any changes in memory to be
propagated to all other processors, thereby ensuring that memory
modifications are visible to threads (or processes) running on other
processors.
Such instructions are known as memory barriers or memory
fences.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
22
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
A memory barrier is a type of barrier instruction that causes a
central processing unit (CPU) or compiler to enforce an ordering
constraint on memory operations issued before and after the
barrier instruction.
This typically means that operations issued prior to the barrier are
guaranteed to be performed before operations issued after the
barrier.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
23
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
Ex)
Lets assume two threads (or processes) are running on different
part of program by sharing two variables. (bool flag = false; int x=0;)
Thread 1 might print 0 or 100 depends on the order of execution.
By using memory barrier instruction Thread1 always print 100.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
24
while (!flag)
print x;
x = 100
flag = true;
Thread 1
Thread 2
' metadata={'source': '/tmp/tmp50p_945n', 'file_path': '/tmp/tmp50p_945n', 'page': 3, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-19 01:10:59 - INFO - Invoking chain
2024-12-19 01:11:07 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 01:11:07 - INFO - Response: {'cleaned_content': '9/17/2024\n\nReal-Time CPU Scheduling (Rate-Monotonic Scheduling)\n\nExample: Two processes P1 and P2\n- P1 = 50, t1 = 20, d1 = by the start of its next period\n- CPU utilization of P1 = p1/t1 = 20/50 = 0.4\n\n- P2 = 100, t2 = 35, d2 = by the start of its next period\n- CPU utilization of P2 = p2/t2 = 35/100 = 0.35\n\nSince t1 < t2, P1 has higher priority than P2.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\n[Graphical representation is omitted for clarity]\n\nP1, P2 deadlines: 200\nP1 deadline: 150\nP1 deadline: 50\nP1, P2 deadline: 100\n\nReal-Time CPU Scheduling (Rate-Monotonic Scheduling)\n\nExample: Two processes P1 and P2\n- P1 = 50, t1 = 25, d1 = by the start of its next period\n- CPU utilization of P1 = p1/t1 = 25/50 = 0.5\n\n- P2 = 80, t2 = 35, d2 = by the start of its next period\n- CPU utilization of P2 = p2/t2 = 35/80 = 0.4375\n\nSince t1 < t2, P1 has higher priority than P2.\nRate-monotonic scheduling cannot guarantee that they can be scheduled so that they meet their deadlines.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\n[Graphical representation is omitted for clarity]\n\nP1 deadline: 50\nP2 deadline: 80\n\nReal-Time CPU Scheduling (Earliest-Deadline-First Scheduling)\n\nEarliest-deadline-first (EDF) scheduling assigns priorities dynamically according to deadlines.\n- The earlier the deadline, the higher the priority;\n- The later the deadline, the lower the priority.\n\nWhen a process becomes runnable (in the ready state), it must announce its deadline requirements to the system.\nPriorities have to be adjusted to reflect the deadline of the newly runnable process.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\n[Graphical representation is omitted for clarity]\n\nExample: Two processes P1 and P2\n- P1 = 50, t1 = 25, d1 = by the start of its next period\n- CPU utilization of P1 = p1/t1 = 25/50 = 0.5\n\n- P2 = 80, t2 = 35, d2 = by the start of its next period\n- CPU utilization of P2 = p2/t2 = 35/80 = 0.4375\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\n[Graphical representation is omitted for clarity]\n\nReal-Time CPU Scheduling (Earliest-Deadline-First Scheduling)\n\nEDF scheduling is theoretically optimal— it can schedule processes so that each process meets its deadline requirements and CPU utilization can reach 100 percent. However, in practice, achieving this level of CPU utilization is not possible due to the costs of context switching between processes and interrupt handling.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nReal-Time CPU Scheduling (Proportional Share Scheduling)\n\nProportional share schedulers operate by allocating T shares among all processes.\nA process can receive N shares of time, ensuring that the process will have N/T of the total processor time.\n\nExample: There are three processes P1, P2, and P3, with a total of shares T = 100.\n- P1 is assigned 50 shares, P2 is assigned 15 shares, and P3 is assigned 20 shares.\nThis means that P1 will have 50%, P2 will have 15%, and P3 will have 20% of total processor time.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park'}
2024-12-19 01:11:07 - INFO - Finished clean_files_chain
2024-12-19 01:11:07 - INFO - Successfully cleaned document 3 from 450Slides9.pdf
2024-12-19 01:11:07 - INFO - Document 4 (450Slides9.pdf) of 4
2024-12-19 01:11:07 - INFO - Starting clean_files_chain
2024-12-19 01:11:07 - INFO - Document: page_content='9/17/2024
4
Real-Time CPU Scheduling  
(Proportional Share Scheduling)
Proportional share schedulers must work in conjunction 
with an admission-control policy to guarantee that an 
application receives its allocated shares of time.
An admission-control policy will admit a process 
requesting a particular number of shares only if sufficient 
shares are available.
In previous example, we have allocated 50 + 15 + 20 = 85 
shares of the total of 100 shares. 
If a new process P4 requested 30 shares, the admission 
controller would deny P4 entry into the system.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
19
Scheduling Algorithm Evaluation
Criteria for selecting an algorithm.
CPU Utilization
Throughput
Response time
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
20
' metadata={'source': '/tmp/tmpedy24fk1', 'file_path': '/tmp/tmpedy24fk1', 'page': 3, 'total_pages': 4, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240917075958-04'00'", 'modDate': "D:20240917075958-04'00'", 'trapped': ''}
2024-12-19 01:11:07 - INFO - Invoking chain
2024-12-19 01:11:10 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 01:11:10 - INFO - Response: {'cleaned_content': 'Date: 9/26/2024\n\n**Mutexes**\n\nmutexes mutex = 0\nrepeat\n    mutex_lock(mutex);\n    mutex_unlock(mutex);\nuntil false\n\n**COSC450 Operating System, Fall 2024**\n**Dr. Sang-Eon Park**\n\n---\n\n**Critical Section**\n\n- **Remainder Section**\n- **Monitor**\n\n**Monitor** – A high-level synchronizing primitive:\n- A collection of procedures, variables, and data structures grouped together in a special kind of module.\n- Only one process can be active in a monitor at any instant.\n- The compiler recognizes that monitors are special and handles calls to monitor procedures differently from other procedure calls (creates special code for the monitor).\n- When a process calls a procedure inside a monitor:\n  1. It checks whether any process is active within the monitor or not.\n  2. If so, the calling process will be suspended until the other process has left the monitor.\n\n**COSC450 Operating System, Fall 2024**\n**Dr. Sang-Eon Park**\n\n---\n\n**Implementation of Monitor**\n\n- Since a monitor is a construct of a programming language, monitor implementation is based on the compiler.\n- The compiler knows a monitor is a special kind of module and uses mutex or binary semaphore for mutual exclusion.\n- Monitors provide an easy way to achieve mutual exclusion. However, we need to consider how a process can be blocked and how a blocked process can be awakened. This introduces condition variables.\n\n**COSC450 Operating System, Fall 2024**\n**Dr. Sang-Eon Park**\n\n---\n\n**Implementation of Monitor**\n\n- Conditional variables are used in the monitor.\n- There are two operations on the conditional variables: wait and signal.\n- When a monitor procedure discovers that it cannot continue, it waits on some condition variable (e.g., full). This action causes the calling process to block and allows other processes to enter the monitor.\n- Other processes (e.g., consumer) can wake up their sleeping partner by signaling the condition variable that their partner is waiting on.\n- If more than one process is waiting on a condition variable, the system scheduler chooses one of them.\n\n**COSC450 Operating System, Fall 2024**\n**Dr. Sang-Eon Park**\n\n---\n\n**Implementation of Monitor**\n\nOnce a process signals, what is the next step for the process that does the signal to avoid having two active processes in the monitor at the same time?\n\n**Solution 1) by Hoare:**\n- Letting the newly awakened process run while suspending the one that did the signal.\n\n**Solution 2) by Brinch Hansen:**\n- A signal statement may appear only as the final statement in a monitor procedure.\n\n**COSC450 Operating System, Fall 2024**\n**Dr. Sang-Eon Park**\n\n---\n\n**Producer-Consumer with Monitor**\n\n```\nmonitor ProducerConsumer\n    condition full, empty;\n    integer count;\n\n    procedure insert(item: integer);\n    begin\n        if count = N then\n            wait(full);\n        insert_item(item);\n        count := count + 1;\n        if count = 1 then\n            signal(empty);\n    end;\n\n    function remove: integer;\n    begin\n        if count = 0 then\n            wait(empty);\n        remove = remove_item;\n        count := count - 1;\n        if count = N - 1 then\n            signal(full);\n    end;\n\n    count := 0;\nend monitor\n\nprocedure producer\nbegin\n    while true do\n    begin\n        item = produce_item;\n        ProducerConsumer.insert(item);\n    end;\nend;\n\nprocedure consumer;\nbegin\n    while true do\n    begin\n        item = ProducerConsumer.remove;\n        consume_item(item);\n    end;\nend;\n```\n\n**COSC450 Operating System, Fall 2024**\n**Dr. Sang-Eon Park**'}
2024-12-19 01:11:10 - INFO - Finished clean_files_chain
2024-12-19 01:11:10 - INFO - Successfully cleaned document 4 from 450Slides11.pdf
2024-12-19 01:11:10 - INFO - Document 5 (450Slides11.pdf) of 5
2024-12-19 01:11:10 - INFO - Starting clean_files_chain
2024-12-19 01:11:10 - INFO - Document: page_content='9/26/2024
5
Message Passing
Message Passing is a method of interprocess communication by using two 
primitive system calls
send(destination, &message);
receive(source, &message);
Usually Message Passing is used between processes located in different system 
since it is slower than using semaphore or monitor in the same system.
If there is no message is available, the receiver will be blocked by system until 
one arrived.
If there is no message to send, the sender will be blocked by system until one 
become available.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
25
Message Passing
(Design Issues for Message Passing System)
Message can be lost
Solution: 
When a message is received, receiver send acknowledgement message.
If sender has not received the ack. message within a certain time interval, retransmits the 
message.
This solution cause new design issue. 
Receiver receive a message from sender, receiver send Ack. message. If the Ack. 
message lost, sender send same message again. Then receiver receive same 
message twice.
Solution:
Each message is assigned with sequence number.
Receiver site system can recognize duplicated message and discard one of them.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
26
Producer-Consumer Problem 
(with Message Passing)
#define N 100
/* number of slots in the buffer */
void producer ()
{
int item;
message m;
/* message buffer */
while (ture)
{
item = produce_item();
/* generate item to put in buffer */
receive(consumer, &m);
/* wait for an empty slot (ACK)*/
build_message(&m, item);
/* construct a message to send */
send(consumer, &m);
/* send item to consumer */
}
}
void consumer()
{
int item, i;
message m;
for (i=0; i < N; i++)
/* send N empty messages*/
send(producer, &m);
while (true)
{
receive(producer, &m);
/* receive a message from producer */
item = extract_item(&m);
/* extract a message */
send(producer, &m)
/* send an empty message to producer (ACK)*/
consume_item(item);
}
}
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
27
' metadata={'source': '/tmp/tmpye5dombc', 'file_path': '/tmp/tmpye5dombc', 'page': 4, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}
2024-12-19 01:11:10 - INFO - Invoking chain
2024-12-19 01:11:10 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 01:11:10 - INFO - Response: {'cleaned_content': 'Date: 9/17/2024\n\nReal-Time CPU Scheduling\n(Proportional Share Scheduling)\n\nProportional share schedulers must work in conjunction with an admission-control policy to guarantee that an application receives its allocated shares of time.\n\nAn admission-control policy will admit a process requesting a particular number of shares only if sufficient shares are available.\n\nIn a previous example, we allocated 50 + 15 + 20 = 85 shares of the total of 100 shares. If a new process P4 requested 30 shares, the admission controller would deny P4 entry into the system.\n\nScheduling Algorithm Evaluation\n\nCriteria for selecting an algorithm:\n- CPU Utilization\n- Throughput\n- Response time\n\nCourse: COSC450 Operating System, Fall 2024\nInstructor: Dr. Sang-Eon Park'}
2024-12-19 01:11:10 - INFO - Finished clean_files_chain
2024-12-19 01:11:10 - INFO - Successfully cleaned document 4 from 450Slides9.pdf
2024-12-19 01:11:12 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 01:11:12 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 01:11:12 - INFO - Response: {'cleaned_content': '9/26/2024\n\nMutexes\n\nmutexes mutex = 0\nrepeat\n    mutex_lock(mutex);\n    mutex_unlock(mutex);\nuntil false\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nCritical Section\nRemainder Section\n\nMonitor\n\nMonitor – High level synchronizing primitive \n- A collection of procedures, variables, and data structures that are all grouped together in a special kind of module.\n- Only one process can be active in a monitor at any instant.\n- The compiler knows that monitors are special and can handle calls to monitor procedures differently from other procedure calls (create special code for monitors).\n- When a process calls a procedure inside a monitor:\n    1. Check whether any process is active within the monitor or not.\n    2. If so, the calling process will be suspended until the other process has left the monitor.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nImplementation of Monitor\n- Since a monitor is a construct for a programming language, monitor implementation is based on the compiler.\n- The compiler knows that a monitor is a special kind of module and uses a mutex or binary semaphore for mutual exclusion.\n- The monitor provides an easy way to achieve mutual exclusion. But we need to consider how a process can be blocked and how a blocked process can be woken up.\n- Introduction of Condition variables.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nImplementation of Monitor\n- Conditional variables are used in the monitor.\n- There are two operations on the conditional variables: wait and signal.\n- When a monitor procedure discovers that it cannot continue, it waits on some condition variable (e.g., full). This action causes the calling process to block, allowing other processes to enter the monitor.\n- Other processes (e.g., consumer) can wake up their sleeping partner by signaling the condition variable that their partner is waiting on.\n- If there are more than one process waiting on a condition variable, the system scheduler chooses one of them.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nImplementation of Monitor\n- Once a process sends a signal, what is the next step for the process that sends the signal to avoid having two active processes in the monitor at the same time?\n\nSolution 1) by Hoare\n- Letting the newly awakened process run, suspending the one that sent the signal.\n\nSolution 2) by Brinch Hansen\n- A signal statement may appear only as the final statement in a monitor procedure.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nProducer-Consumer with Monitor\n\nmonitor ProducerConsumer\n    condition full, empty;\n    integer count;\n\n    procedure insert(item: integer);\n    begin\n        if count = N then\n            wait(full);\n        insert_item(item);\n        count := count + 1;\n        if count = 1 then\n            signal(empty);\n    end;\n\n    function remove: integer;\n    begin\n        if count = 0 then\n            wait(empty);\n        remove = remove_item;\n        count := count - 1;\n        if count = N - 1 then\n            signal(full);\n    end;\n\n    count := 0;\nend monitor\n\nprocedure producer\nbegin\n    while true do\n    begin\n        item = produce_item;\n        ProducerConsumer.insert(item);\n    end;\nend;\n\nprocedure consumer\nbegin\n    while true do\n    begin\n        item = ProducerConsumer.remove;\n        consume_item(item);\n    end;\nend;\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park'}
2024-12-19 01:11:12 - INFO - Finished clean_files_chain
2024-12-19 01:11:12 - INFO - Successfully cleaned document 4 from cosc450_11.pdf
2024-12-19 01:11:12 - INFO - Document 5 (cosc450_11.pdf) of 5
2024-12-19 01:11:12 - INFO - Starting clean_files_chain
2024-12-19 01:11:12 - INFO - Document: page_content='9/26/2024
5
Message Passing
Message Passing is a method of interprocess communication by using two 
primitive system calls
send(destination, &message);
receive(source, &message);
Usually Message Passing is used between processes located in different system 
since it is slower than using semaphore or monitor in the same system.
If there is no message is available, the receiver will be blocked by system until 
one arrived.
If there is no message to send, the sender will be blocked by system until one 
become available.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
25
Message Passing
(Design Issues for Message Passing System)
Message can be lost
Solution: 
When a message is received, receiver send acknowledgement message.
If sender has not received the ack. message within a certain time interval, retransmits the 
message.
This solution cause new design issue. 
Receiver receive a message from sender, receiver send Ack. message. If the Ack. 
message lost, sender send same message again. Then receiver receive same 
message twice.
Solution:
Each message is assigned with sequence number.
Receiver site system can recognize duplicated message and discard one of them.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
26
Producer-Consumer Problem 
(with Message Passing)
#define N 100
/* number of slots in the buffer */
void producer ()
{
int item;
message m;
/* message buffer */
while (ture)
{
item = produce_item();
/* generate item to put in buffer */
receive(consumer, &m);
/* wait for an empty slot (ACK)*/
build_message(&m, item);
/* construct a message to send */
send(consumer, &m);
/* send item to consumer */
}
}
void consumer()
{
int item, i;
message m;
for (i=0; i < N; i++)
/* send N empty messages*/
send(producer, &m);
while (true)
{
receive(producer, &m);
/* receive a message from producer */
item = extract_item(&m);
/* extract a message */
send(producer, &m)
/* send an empty message to producer (ACK)*/
consume_item(item);
}
}
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
27
' metadata={'source': '/tmp/tmplpxmqkix', 'file_path': '/tmp/tmplpxmqkix', 'page': 4, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}
2024-12-19 01:11:12 - INFO - Invoking chain
2024-12-19 01:11:12 - INFO - Response: {'cleaned_content': "9/17/2024\n\nMutual Exclusion with Busy Waiting (Peterson’s Solution)\n\nLet's consider the case where both P0 and P1 call enter_region(0) and enter_region(1) almost simultaneously.\n\nAssume interest[0] = true and interest[1] = true at the same time. However, turn can only be either turn = 0 or turn = 1; whichever store is done last is the one that counts!\n\nCase 1: turn = 0\nInside enter_region(0):\n- Since turn = 0 and interest[1] = true, P0 keeps looping in a no-operation state until P1 sets interest[1] = false.\n\nInside enter_region(1):\n- Since turn = 0 and interest[0] = true, P1 goes to its critical section.\n\nCase 2: turn = 1\nInside enter_region(0):\n- Since turn = 1 and interest[1] = true, P0 goes to its critical section.\n\nInside enter_region(1):\n- Since turn = 1 and interest[0] = true, P1 keeps looping in a no-operation state until P0 sets interest[0] = false.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Test and Set Lock – hardware solution)\n\nSince the Test and Set Lock (TSL) instruction is a hardware instruction, the operations of reading the lock and storing it into a register are guaranteed to be indivisible.\n\nInstruction: test and set lock\nTSL RX, LOCK\n1. Read the content at the memory address of LOCK into register RX.\n2. Store a non-zero value at the memory address of LOCK.\n\nThe operations of reading the content of LOCK and storing into it are guaranteed to be indivisible.\n\nHow to use Test and Set Lock instruction for solving race condition:\n- When LOCK = 0, any process may set LOCK = 1 by using the TSL instruction and go to its critical section.\n- When the process finishes its critical section, it sets LOCK = 0 using the original move instruction.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nEnter_region:\nTSL Register, LOCK\nCMP Register, #0\nJNE Enter_region\nSet LOCK, #1\nRET\n\nLeave_region:\nMOVE LOCK, #0\nRET\n\nRepeat\nEnter_region\nLeave_region\nuntil false\n\nCritical Section\nRemainder Section\n\nMutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)\n\nThere are two general memory models:\n1. Strongly ordered Memory – a memory modification on one processor is immediately visible to all other processors.\n2. Weakly ordered Memory – a memory modification on one processor may not be immediately visible to other processors.\n\nWith strongly ordered memory, computer architectures provide instructions that can force any changes in memory to be propagated to all other processors, ensuring that memory modifications are visible to threads (or processes) running on other processors. Such instructions are known as memory barriers or memory fences.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nA memory barrier is a type of barrier instruction that causes a central processing unit (CPU) or compiler to enforce an ordering constraint on memory operations issued before and after the barrier instruction. This typically means that operations issued prior to the barrier are guaranteed to be performed before operations issued after the barrier.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nExample:\nAssume two threads (or processes) are running on different parts of a program by sharing two variables: (bool flag = false; int x = 0;)\nThread 1 might print 0 or 100 depending on the order of execution. By using a memory barrier instruction, Thread 1 will always print 100.\n\nwhile (!flag)\n    print x;\n    x = 100;\n    flag = true;\n\nThread 1\nThread 2"}
2024-12-19 01:11:12 - INFO - Finished clean_files_chain
2024-12-19 01:11:12 - INFO - Successfully cleaned document 4 from 450Slides10.pdf
2024-12-19 01:11:12 - INFO - Document 5 (450Slides10.pdf) of 5
2024-12-19 01:11:12 - INFO - Starting clean_files_chain
2024-12-19 01:11:12 - INFO - Document: page_content='9/17/2024
5
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
Now it is guarantee that the value of flag is loaded before the value of x
Also it is guarantee that assignment to x occurs before the assignment to flag.
So Thread 1 always print 100
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
25
while (!flag)
memory_barrier();
print x;
x = 100;
memory_barrier();
flag = true;
Thread 1
Thread 2
Mutual Exclusion with Busy Waiting
(Atomic Variables– hardware solution)
We can avoid mutual exclusion by using atomic operations.
When a thread (or process) performs an atomic operation, the
other threads (or process) see it as happening instantaneously.
The advantage of atomic operations is that they are relatively quick
compared to locks, and do not suffer from deadlock and convoying.
The disadvantage is that they only do a limited set of operations,
and often these are not enough to synthesize more complicated
operations efficiently.
But nonetheless you should not pass up an opportunity to use an
atomic operation in place of mutual exclusion.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
26
Mutual Exclusion with Busy Waiting
(Priority Inversion Problem)
Peterson's solution, test and set lock, Memory Barrier, Atomic variable method –
busy waiting – (wasting CPU time)
Priority Inversion problem with busy waiting method
A computer with two processes PH with high priorities, and PL with low priorities.
The scheduling rules are such that PH get CPU time whenever it is in ready state.
(preemptive priority scheduling)
1. At a time T0: PL is in critical section, and PH is in block state.
2. At a time T1: PH change sate from block to ready state and try to enter the critical
section. PL still in critical section.
3. Based on scheduling rule, short-term scheduler select PH, PH hold CPU and try to enter
into critical section.
4. Since PL is in critical section, PH run busy waiting outside critical section forever since
PL does not have a chance to get CPU time to finish its critical section.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
27
Mutual Exclusion with Busy Waiting
(Priority Inversion Problem)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
28
Block
Running
Ready
T0 :
PL: running state in critical section
PH: block state
PH
PL
Block
Running
Ready
PH
PL
T1 : PH become ready state
PL: ready state in critical section
PH: ready state
CPU scheduler will select higher
priority process
Block
Running
Ready
PH
PL
Ti>1
PL: ready state in critical section
PH: busy waiting in running state
PH become ready state
Scheduler keep selecting
PH since higher priority
The scheduling rules : CPU scheduler will always select higher priority process.
' metadata={'source': '/tmp/tmp50p_945n', 'file_path': '/tmp/tmp50p_945n', 'page': 4, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-19 01:11:12 - INFO - Invoking chain
2024-12-19 01:11:18 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 01:11:18 - INFO - Response: {'cleaned_content': "9/26/2024\n\nMessage Passing\n\nMessage Passing is a method of interprocess communication that uses two primitive system calls:\n\n- send(destination, &message);\n- receive(source, &message);\n\nMessage Passing is usually used between processes located in different systems since it is slower than using semaphore or monitor within the same system.\n\nIf no message is available, the receiver will be blocked by the system until one arrives. Conversely, if there is no message to send, the sender will be blocked by the system until one becomes available.\n\nDesign Issues for Message Passing System:\n\n1. Messages can be lost.\n   - Solution:\n     - When a message is received, the receiver sends an acknowledgement message.\n     - If the sender has not received the acknowledgement message within a certain time interval, it retransmits the message.\n\n2. This solution causes a new design issue:\n   - If the receiver receives a message from the sender and sends an acknowledgement message, but the acknowledgement message is lost, the sender will send the same message again. Then the receiver will receive the same message twice.\n   - Solution:\n     - Each message is assigned a sequence number.\n     - The receiver's system can recognize duplicated messages and discard one of them.\n\nProducer-Consumer Problem (with Message Passing):\n\n#define N 100\n/* number of slots in the buffer */\n\nvoid producer() {\n    int item;\n    message m;\n    /* message buffer */\n    while (true) {\n        item = produce_item();\n        /* generate item to put in buffer */\n        receive(consumer, &m);\n        /* wait for an empty slot (ACK) */\n        build_message(&m, item);\n        /* construct a message to send */\n        send(consumer, &m);\n        /* send item to consumer */\n    }\n}\n\nvoid consumer() {\n    int item, i;\n    message m;\n    for (i = 0; i < N; i++) {\n        /* send N empty messages */\n        send(producer, &m);\n    }\n    while (true) {\n        receive(producer, &m);\n        /* receive a message from producer */\n        item = extract_item(&m);\n        /* extract a message */\n        send(producer, &m);\n        /* send an empty message to producer (ACK) */\n        consume_item(item);\n    }\n}"}
2024-12-19 01:11:18 - INFO - Finished clean_files_chain
2024-12-19 01:11:18 - INFO - Successfully cleaned document 5 from 450Slides11.pdf
2024-12-19 01:11:20 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 01:11:20 - INFO - Response: {'cleaned_content': "9/26/2024\n\nMessage Passing\n\nMessage Passing is a method of interprocess communication using two primitive system calls:\n1. send(destination, &message);\n2. receive(source, &message);\n\nMessage Passing is usually used between processes located in different systems since it is slower than using semaphore or monitor in the same system. If no message is available, the receiver will be blocked by the system until one arrives. If there is no message to send, the sender will be blocked by the system until one becomes available.\n\nDesign Issues for Message Passing System:\n- Messages can be lost.\n  - Solution: When a message is received, the receiver sends an acknowledgement message. If the sender has not received the acknowledgement message within a certain time interval, it retransmits the message. This solution causes a new design issue: the receiver receives a message from the sender, sends an acknowledgement message, and if the acknowledgement message is lost, the sender sends the same message again. Then the receiver receives the same message twice.\n  - Solution: Each message is assigned a sequence number. The receiver's system can recognize duplicated messages and discard one of them.\n\nProducer-Consumer Problem (with Message Passing)\n\n#define N 100 /* number of slots in the buffer */\n\nvoid producer() {\n    int item;\n    message m; /* message buffer */\n    while (true) {\n        item = produce_item(); /* generate item to put in buffer */\n        receive(consumer, &m); /* wait for an empty slot (ACK) */\n        build_message(&m, item); /* construct a message to send */\n        send(consumer, &m); /* send item to consumer */\n    }\n}\n\nvoid consumer() {\n    int item, i;\n    message m;\n    for (i = 0; i < N; i++) /* send N empty messages */\n        send(producer, &m);\n    while (true) {\n        receive(producer, &m); /* receive a message from producer */\n        item = extract_item(&m); /* extract a message */\n        send(producer, &m); /* send an empty message to producer (ACK) */\n        consume_item(item);\n    }\n}"}
2024-12-19 01:11:20 - INFO - Finished clean_files_chain
2024-12-19 01:11:20 - INFO - Successfully cleaned document 5 from cosc450_11.pdf
2024-12-19 01:11:20 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 01:11:20 - INFO - Response: {'cleaned_content': "9/17/2024\n\nMutual Exclusion with Busy Waiting\n(Memory Barriers – hardware solution)\n\n- It is guaranteed that the value of flag is loaded before the value of x.\n- It is also guaranteed that the assignment to x occurs before the assignment to flag.\n- Therefore, Thread 1 always prints 100.\n\n```plaintext\nwhile (!flag)\n    memory_barrier();\nprint x;\nx = 100;\nmemory_barrier();\nflag = true;\n```\n\nThread 1\nThread 2\n\nMutual Exclusion with Busy Waiting\n(Atomic Variables – hardware solution)\n\n- We can avoid mutual exclusion by using atomic operations.\n- When a thread (or process) performs an atomic operation, the other threads (or processes) see it as happening instantaneously.\n- The advantage of atomic operations is that they are relatively quick compared to locks, and do not suffer from deadlock and convoying.\n- The disadvantage is that they only perform a limited set of operations, often insufficient to synthesize more complicated operations efficiently.\n- However, one should not miss the opportunity to use an atomic operation instead of mutual exclusion.\n\nMutual Exclusion with Busy Waiting\n(Priority Inversion Problem)\n\n- Peterson's solution, test and set lock, memory barrier, and atomic variable method involve busy waiting, which wastes CPU time.\n\nPriority Inversion problem with busy waiting method:\n1. Consider a computer with two processes: PH (high priority) and PL (low priority).\n2. The scheduling rules ensure that PH gets CPU time whenever it is in a ready state (preemptive priority scheduling).\n3. At time T0: PL is in the critical section, while PH is in the blocked state.\n4. At time T1: PH changes state from blocked to ready and tries to enter the critical section, but PL is still in the critical section.\n5. Based on the scheduling rule, the short-term scheduler selects PH, which holds the CPU and attempts to enter the critical section.\n6. Since PL is in the critical section, PH runs busy waiting outside the critical section forever, as PL does not receive CPU time to finish its critical section.\n\nThe scheduling rules dictate that the CPU scheduler will always select the higher priority process."}
2024-12-19 01:11:20 - INFO - Finished clean_files_chain
2024-12-19 01:11:20 - INFO - Successfully cleaned document 5 from 450Slides10.pdf
2024-12-19 01:11:20 - INFO - Pages: []
2024-12-19 01:11:20 - INFO - Full response: 9/17/2024

Real-Time CPU Scheduling

- Minimizing Latency
- Preemptive Priority-Based Scheduling
- Rate-Monotonic Scheduling
- Earliest-Deadline-First Scheduling
- Proportional Share Scheduling

Criteria for selecting an algorithm

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Real-Time CPU Scheduling

CPU scheduling for real-time operating systems involves special issues. In general, we can distinguish between hard real-time systems and soft real-time systems.

Hard real-time systems: A task must be serviced by its deadline; service after the deadline has expired is equivalent to no service at all. Any missed deadline is considered a system failure.

- An inkjet printer has a print head with control software for depositing the correct amount of ink onto a specific part of the paper. If a deadline is missed, then the print job is ruined.
- Air France Flight 447 crashed into the ocean after a sensor malfunction caused a series of system errors.

Soft real-time systems allow for frequently missed deadlines, and as long as tasks are timely executed, their results continue to have value. Completed tasks may have increasing value up to the deadline and decreasing value past it.

- Weather stations have many sensors for reading temperature, humidity, wind speed, etc. The readings should be taken and transmitted at regular intervals; however, the sensors are not synchronized. Even though a sensor reading may be early or late compared with the others, it can still be relevant as long as it is close enough.
- The sound system in a computer. If you miss a few bits, it is not a big deal, but if you miss too many, the system will eventually degrade.

Real-Time CPU Scheduling (Minimizing Latency)

A real-time system is typically waiting for an event in real time to occur. Events may arise either in software (as when a timer expires) or in hardware (when a remote-controlled vehicle detects that it is approaching an obstruction).

When an event occurs, the system must respond to and service it as quickly as possible.

Event latency is the amount of time that elapses from when an event occurs to when it is serviced. Different events have different latency requirements in a system.

- For an antilock brake system, the requirement is 3 to 5 milliseconds. If the antilock brake system does not respond within this time, a car accident might occur.

Two types of latencies affect the performance of real-time systems:

1. Interrupt latency:
   - When an interrupt occurs, the OS completes the instruction it is executing, determines the type of interrupt that occurred, and saves the state of the current process before servicing the interrupt using the specific interrupt service routine (ISR).
   - Interrupt latency is the period of time from the arrival of an interrupt at the CPU to the start of the routine that services the interrupt.

2. Dispatch latency: The amount of time required for the scheduling dispatcher to stop one process and start another.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park9/17/2024

Real-Time CPU Scheduling (Minimizing Latency)

Two types of latencies affect the performance of real-time systems:
1. Interrupt latency
2. Dispatch latency

Dispatch latency is the amount of time required for the scheduling dispatcher to stop one process and start another. The most effective technique for keeping dispatch latency low is to provide preemptive kernels. For hard real-time systems, dispatch latency is typically measured in several microseconds.

Two components of the conflict phase of dispatch latency are:
1. Preemption of any process running in the kernel
2. Release by low-priority processes of resources needed by a high-priority process

Real-Time CPU Scheduling (Preemptive Priority-Based Scheduling)

The most important feature of a real-time operating system is to respond immediately to a real-time process. In priority-based scheduling, the scheduler always selects the highest priority process; more important tasks are assigned higher priorities than those deemed less important. With preemptive scheduling, a process currently running on the CPU will be preempted if a higher-priority process becomes available to run. A preemptive, priority-based scheduler only guarantees soft real-time functionality. Since hard real-time systems need to consider deadlines, the scheduler requires additional scheduling features.

Characteristics for a process that must be considered for real-time CPU scheduling:
- Period (p): The process requires the CPU at constant intervals (periods).
- Deadline (d)
- Processing time (t): Fixed processing time

The relationship of the processing time, the deadline, and the period can be expressed as:
0 ≤ t ≤ d ≤ p.

The rate of a periodic task is 1/p.

A process must provide its deadline requirement to the scheduler. Then, the scheduler either admits the process, guaranteeing that the process will complete on time, or rejects the request as impossible (admission-control algorithm).

Real-Time CPU Scheduling (Rate-Monotonic Scheduling)

Rate-monotonic scheduling assumes that the processing time of a periodic process is the same for each CPU burst. That is, every time a process acquires the CPU, the duration of its CPU burst is the same. Upon entering the system, priority is assigned to a process based on the length of the period (p). The shorter the period, the higher the priority. The rate-monotonic scheduling algorithm schedules periodic tasks using a static priority policy with preemption. If a lower-priority process is running and a higher-priority process becomes available to run, it will preempt the lower-priority process.9/17/2024

Real-Time CPU Scheduling (Rate-Monotonic Scheduling)

Example: Two processes P1 and P2
- P1 = 50, t1 = 20, d1 = by the start of its next period
- CPU utilization of P1 = p1/t1 = 20/50 = 0.4

- P2 = 100, t2 = 35, d2 = by the start of its next period
- CPU utilization of P2 = p2/t2 = 35/100 = 0.35

Since t1 < t2, P1 has higher priority than P2.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

[Graphical representation is omitted for clarity]

P1, P2 deadlines: 200
P1 deadline: 150
P1 deadline: 50
P1, P2 deadline: 100

Real-Time CPU Scheduling (Rate-Monotonic Scheduling)

Example: Two processes P1 and P2
- P1 = 50, t1 = 25, d1 = by the start of its next period
- CPU utilization of P1 = p1/t1 = 25/50 = 0.5

- P2 = 80, t2 = 35, d2 = by the start of its next period
- CPU utilization of P2 = p2/t2 = 35/80 = 0.4375

Since t1 < t2, P1 has higher priority than P2.
Rate-monotonic scheduling cannot guarantee that they can be scheduled so that they meet their deadlines.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

[Graphical representation is omitted for clarity]

P1 deadline: 50
P2 deadline: 80

Real-Time CPU Scheduling (Earliest-Deadline-First Scheduling)

Earliest-deadline-first (EDF) scheduling assigns priorities dynamically according to deadlines.
- The earlier the deadline, the higher the priority;
- The later the deadline, the lower the priority.

When a process becomes runnable (in the ready state), it must announce its deadline requirements to the system.
Priorities have to be adjusted to reflect the deadline of the newly runnable process.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

[Graphical representation is omitted for clarity]

Example: Two processes P1 and P2
- P1 = 50, t1 = 25, d1 = by the start of its next period
- CPU utilization of P1 = p1/t1 = 25/50 = 0.5

- P2 = 80, t2 = 35, d2 = by the start of its next period
- CPU utilization of P2 = p2/t2 = 35/80 = 0.4375

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

[Graphical representation is omitted for clarity]

Real-Time CPU Scheduling (Earliest-Deadline-First Scheduling)

EDF scheduling is theoretically optimal— it can schedule processes so that each process meets its deadline requirements and CPU utilization can reach 100 percent. However, in practice, achieving this level of CPU utilization is not possible due to the costs of context switching between processes and interrupt handling.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Real-Time CPU Scheduling (Proportional Share Scheduling)

Proportional share schedulers operate by allocating T shares among all processes.
A process can receive N shares of time, ensuring that the process will have N/T of the total processor time.

Example: There are three processes P1, P2, and P3, with a total of shares T = 100.
- P1 is assigned 50 shares, P2 is assigned 15 shares, and P3 is assigned 20 shares.
This means that P1 will have 50%, P2 will have 15%, and P3 will have 20% of total processor time.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon ParkDate: 9/17/2024

Real-Time CPU Scheduling
(Proportional Share Scheduling)

Proportional share schedulers must work in conjunction with an admission-control policy to guarantee that an application receives its allocated shares of time.

An admission-control policy will admit a process requesting a particular number of shares only if sufficient shares are available.

In a previous example, we allocated 50 + 15 + 20 = 85 shares of the total of 100 shares. If a new process P4 requested 30 shares, the admission controller would deny P4 entry into the system.

Scheduling Algorithm Evaluation

Criteria for selecting an algorithm:
- CPU Utilization
- Throughput
- Response time

Course: COSC450 Operating System, Fall 2024
Instructor: Dr. Sang-Eon Park9/26/2024

Review

Inter-Process Communication

- Race Condition
- Critical Section (or region)
- Solutions for Mutual Exclusion in a Critical Section
  - With Busy Waiting
    - Disabling Interrupts – non-preemptive kernel
    - Lock Variables – violating the first necessary condition (mutual exclusion)
    - Strict Alternation – violating the second necessary condition (block by a process outside critical section)
    - Peterson’s Solution
    - Hardware Solution
      - Test and Set Lock
      - Memory Barriers
      - Atomic Variable
    - Priority Inversion problems with busy waiting

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Preview

- Mutual Exclusion in a Critical Section
  - With Sleep and Wake up
- Producer Consumer Problem
- Race Condition Producer Consumer problem
- Semaphore
  - Concept of Semaphore
  - Semaphore Operation
  - Semaphore Implementation
  - Producer Consumer problem with semaphores
  - Careless Usage of semaphore causes deadlock
- Dining Philosophers Problem
- Reader’s and Writer’s Problem
- Mutexes
- Monitor
  - Implementation of Monitor
  - Producer Consumer with Monitor
- Message Passing
  - Producer Consumer with Message Passing

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Sleep and Wakeup

- Sleep and Wakeup:
  - A process checks a resource (critical section); if not available, it goes to sleep.
  - When the resource becomes available, the process will be woken up by the system or the process will release the resource.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

The Producer-Consumer Problem
Description

- Two processes share a common, fixed-sized buffer.
- Producer puts information into the buffer, and consumer takes it out.

Troubles arise:

- When the producer wants to put a new item in the buffer, but it is already full.
- When the consumer tries to take an item from the buffer, but the buffer is already empty.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

The Producer-Consumer Problem

- When the producer wants to put a new item in the buffer, but it is already full.
  - Solution: producer goes to sleep, awakened by consumer when consumer has removed one or more items.
- When the consumer tries to take an item from the buffer, but the buffer is already empty.
  - Solution: consumer goes to sleep, awakened by producer when producer puts one or more items into the buffer.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

The Producer-Consumer Problem

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

#define N 100 // buffer size
int count = 0; // number of items

void producer() {
    int item;
    while (true) {
        item = produce_item();
        if (count == N)
            sleep();
        insert_item(item);
        count = count + 1;
        if (count == 1)
            wakeup(consumer);
    }
}

void consumer() {
    int item;
    while (true) {
        if (count == 0)
            sleep();
        item = remove_item();
        count = count - 1;
        if (count == N - 1)
            wakeup(producer);
        consume_item(item);
    }
}Date: 9/26/2024

Semaphores – by E. W. Dijkstra

A semaphore is an integer variable which could have the following values:
- 0: no wakeups are saved
- +i: i wakeups are pending

A semaphore is accessed only through two standard atomic operations: down (or P) and up (or V).

Concept of Semaphores

The modification to the integer value of the semaphore in the down and up operations is executed indivisibly. This means that when a process is modifying the semaphore value, no other process can simultaneously modify that same semaphore value.

Semaphore Operations

The following is the implementation of the semaphore operations:

void down(S) {
    if (S == 0) {
        1. Add this process to the sleeping list
        2. block;
    }
    S = S - 1;
}

void up(S) {
    S = S + 1;
    if (S == 1) {
        1. Choose one process P from the sleeping list or let them move to ready state
        2. wakeup(P) to finish down operation
    }
}

Semaphore Implementation

The normal way of implementing a semaphore is to:
- Implement semaphore operations up and down as system calls.
- The operating system briefly disables all interrupts while it is testing the semaphore, updating it, and putting the process to sleep.

Solving the Producer-Consumer Problem using Semaphores

#define N 100
typedef int semaphore;
semaphore mutex = 1;  // mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of items

void producer() {
    int item;
    while (true) {
        item = produce_item(); // produce item
        down(&empty); // check empty space
        down(&mutex); // check mutual exclusion
        insert_item(item); // insert item
        up(&mutex); // out from critical section
        up(&full); // increase # of items
    }
}

void consumer() {
    int item;
    while (true) {
        down(&full); // check item in buffer
        down(&mutex); // check mutual exclusion
        item = remove_item(); // remove an item
        up(&mutex); // out from critical section
        up(&empty); // increase the empty space
        consume_item(item);
    }
}

Careless usage of Semaphore causes deadlock

#define N 100
typedef int semaphore;
semaphore mutex = 1; // mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of items

void producer() {
    int item;
    while (true) {
        item = produce_item();
        down(&mutex);
        down(&empty);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer() {
    int item;
    while (true) {
        down(&full);
        down(&mutex);
        item = remove_item();
        up(&mutex);
        up(&empty);
        consume_item(item);
    }
}Date: 9/26/2024

Careless usage of Semaphore causes deadlock

#define N 100

typedef int semaphore;
semaphore mutex = 1; // mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of items

void producer ()
{
    int item;
    while (true)
    {
        item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer()
{
    int item;
    while (true)
    {
        down(&mutex);
        down(&full);
        item = remove_item();
        up(&mutex);
        up(&empty);
        consume_item(item);
    }
}

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

---

Dining Philosophers Problem

Five silent philosophers sit at a round table with bowls of spaghetti. Chopsticks are placed between each pair of adjacent philosophers.

Each philosopher must alternately think and eat. However, a philosopher can only eat spaghetti when they have both left and right chopsticks. Each chopstick can be held by only one philosopher, and so a philosopher can use the chopstick only if it is not being used by another philosopher. After an individual philosopher finishes eating, they need to put down both chopsticks so that the chopsticks become available to others. A philosopher can take the chopstick on their right or the one on their left as they become available, but cannot start eating before getting both chopsticks.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

---

Readers-Writers Problem

Process readers (R) and writers (W) are sharing resources at one time. Only one process (reader or writer) can access the shared resources at any time.

1. It is possible that a reader R1 might have the lock to a shared resource, and then another reader R2 requests access. It would be foolish for R2 to wait until R1 was done before starting its own read operation; instead, R1 and R2 can read the same resource at the same time since both are reading.

2. It is possible that a reader R1 might have the lock, a writer W be waiting for the lock, and then a reader R2 requests access. It would be unfair for R2 to jump in immediately ahead of W; if that happened often enough, W would starve.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

---

Mutexes

When the semaphore's ability to count is not needed, the simplified version of the semaphore, called mutex, is used. It is good for managing mutual exclusion to some shared resources or pieces of code. It is useful in thread packages that are implemented in user space. A mutex is a variable that can be in one of two states: unlocked (0) or locked (1). A mutex concept is the same as a binary semaphore which has value 0 or 1.Date: 9/26/2024

**Mutexes**

mutexes mutex = 0
repeat
    mutex_lock(mutex);
    mutex_unlock(mutex);
until false

**COSC450 Operating System, Fall 2024**
**Dr. Sang-Eon Park**

---

**Critical Section**

- **Remainder Section**
- **Monitor**

**Monitor** – A high-level synchronizing primitive:
- A collection of procedures, variables, and data structures grouped together in a special kind of module.
- Only one process can be active in a monitor at any instant.
- The compiler recognizes that monitors are special and handles calls to monitor procedures differently from other procedure calls (creates special code for the monitor).
- When a process calls a procedure inside a monitor:
  1. It checks whether any process is active within the monitor or not.
  2. If so, the calling process will be suspended until the other process has left the monitor.

**COSC450 Operating System, Fall 2024**
**Dr. Sang-Eon Park**

---

**Implementation of Monitor**

- Since a monitor is a construct of a programming language, monitor implementation is based on the compiler.
- The compiler knows a monitor is a special kind of module and uses mutex or binary semaphore for mutual exclusion.
- Monitors provide an easy way to achieve mutual exclusion. However, we need to consider how a process can be blocked and how a blocked process can be awakened. This introduces condition variables.

**COSC450 Operating System, Fall 2024**
**Dr. Sang-Eon Park**

---

**Implementation of Monitor**

- Conditional variables are used in the monitor.
- There are two operations on the conditional variables: wait and signal.
- When a monitor procedure discovers that it cannot continue, it waits on some condition variable (e.g., full). This action causes the calling process to block and allows other processes to enter the monitor.
- Other processes (e.g., consumer) can wake up their sleeping partner by signaling the condition variable that their partner is waiting on.
- If more than one process is waiting on a condition variable, the system scheduler chooses one of them.

**COSC450 Operating System, Fall 2024**
**Dr. Sang-Eon Park**

---

**Implementation of Monitor**

Once a process signals, what is the next step for the process that does the signal to avoid having two active processes in the monitor at the same time?

**Solution 1) by Hoare:**
- Letting the newly awakened process run while suspending the one that did the signal.

**Solution 2) by Brinch Hansen:**
- A signal statement may appear only as the final statement in a monitor procedure.

**COSC450 Operating System, Fall 2024**
**Dr. Sang-Eon Park**

---

**Producer-Consumer with Monitor**

```
monitor ProducerConsumer
    condition full, empty;
    integer count;

    procedure insert(item: integer);
    begin
        if count = N then
            wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then
            signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then
            wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N - 1 then
            signal(full);
    end;

    count := 0;
end monitor

procedure producer
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end;
end;

procedure consumer;
begin
    while true do
    begin
        item = ProducerConsumer.remove;
        consume_item(item);
    end;
end;
```

**COSC450 Operating System, Fall 2024**
**Dr. Sang-Eon Park**9/26/2024

Message Passing

Message Passing is a method of interprocess communication that uses two primitive system calls:

- send(destination, &message);
- receive(source, &message);

Message Passing is usually used between processes located in different systems since it is slower than using semaphore or monitor within the same system.

If no message is available, the receiver will be blocked by the system until one arrives. Conversely, if there is no message to send, the sender will be blocked by the system until one becomes available.

Design Issues for Message Passing System:

1. Messages can be lost.
   - Solution:
     - When a message is received, the receiver sends an acknowledgement message.
     - If the sender has not received the acknowledgement message within a certain time interval, it retransmits the message.

2. This solution causes a new design issue:
   - If the receiver receives a message from the sender and sends an acknowledgement message, but the acknowledgement message is lost, the sender will send the same message again. Then the receiver will receive the same message twice.
   - Solution:
     - Each message is assigned a sequence number.
     - The receiver's system can recognize duplicated messages and discard one of them.

Producer-Consumer Problem (with Message Passing):

#define N 100
/* number of slots in the buffer */

void producer() {
    int item;
    message m;
    /* message buffer */
    while (true) {
        item = produce_item();
        /* generate item to put in buffer */
        receive(consumer, &m);
        /* wait for an empty slot (ACK) */
        build_message(&m, item);
        /* construct a message to send */
        send(consumer, &m);
        /* send item to consumer */
    }
}

void consumer() {
    int item, i;
    message m;
    for (i = 0; i < N; i++) {
        /* send N empty messages */
        send(producer, &m);
    }
    while (true) {
        receive(producer, &m);
        /* receive a message from producer */
        item = extract_item(&m);
        /* extract a message */
        send(producer, &m);
        /* send an empty message to producer (ACK) */
        consume_item(item);
    }
}9/26/2024

Review

Inter-Process Communication
- Race Condition
- Critical Section (or region)
- Solutions for Mutual Exclusion in a Critical Section
  - With Busy Waiting
    - Disabling Interrupts – non-preemptive kernel
    - Lock Variables – violating the first necessary condition (mutual exclusion)
    - Strict Alternation – violating the second necessary condition (block by a process outside critical section)
    - Peterson’s Solution
    - Hardware Solution
      - Test and Set Lock
      - Memory Barriers
      - Atomic Variable
- Priority Inversion problems with busy waiting

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Preview
- Mutual Exclusion in a Critical Section
  - With Sleep and Wake up
- Producer Consumer Problem
- Race Condition Producer Consumer problem
- Semaphore
  - Concept of Semaphore
  - Semaphore Operation
  - Semaphore Implementation
  - Producer Consumer problem with semaphores
  - Careless Usage of semaphore causes deadlock
- Dining Philosophers Problem
- Reader’s and Writer’s Problem
- Mutexes
- Monitor
  - Implementation of Monitor
  - Producer Consumer with Monitor
- Message Passing
  - Producer Consumer with Message Passing

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Sleep and Wakeup
- Sleep and Wakeup:
  - A process checks a resource (critical section); if not available, it goes to sleep.
  - When the resource becomes available, the process will be woken up by the system or the process releasing the resource.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

The Producer-Consumer Problem
Description
- Two processes share a common, fixed-sized buffer.
- Producer puts information into the buffer, and consumer takes it out.

Troubles arise:
- When the producer wants to put a new item in the buffer, but it is already full.
- When the consumer tries to take an item from the buffer, but the buffer is already empty.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

The Producer-Consumer Problem
- When the producer wants to put a new item in the buffer, but it is already full.
  - Solution: Producer goes to sleep, awakened by consumer when the consumer has removed one or more items.
- When the consumer tries to take an item from the buffer, but the buffer is already empty.
  - Solution: Consumer goes to sleep, awakened by the producer when the producer puts one or more items into the buffer.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

The Producer-Consumer Problem

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

#define N 100 // buffer size
int count = 0; // # of items

void producer() {
    int item;
    while (true) {
        item = produce_item();
        if (count == N) sleep();
        insert_item(item);
        count = count + 1;
        if (count == 1) wakeup(consumer);
    }
}

void consumer() {
    int item;
    while (true) {
        if (count == 0) sleep();
        item = remove_item();
        count = count - 1;
        if (count == N - 1) wakeup(producer);
        consume_item(item);
    }
}9/26/2024

Semaphores – by E. W. Dijkstra

A semaphore is an integer variable which could have the following values:

0: no wakeups are saved
+ i: i wakeups are pending

A semaphore is accessed only through two standard atomic operations: down (or P) and up (or V).

Concept of Semaphores

Modification to the integer value of the semaphore in the down and up operations are executed indivisibly. This means that when a process is modifying the semaphore value, no other process can simultaneously modify that same semaphore value.

Semaphore Operation

void down (S)
{
    if S == 0
    {
        1. Add this process to the sleeping list
        2. block;
    }
    S = S - 1;
}

void up (S)
{
    S = S + 1;
    if S == 1
    {
        1. choose one process P from the sleeping list or let them move to ready state
        2. wakeup(P) to finish down operation
    }
}

Semaphore Implementation

The normal way for implementing a semaphore is as follows:
- Implement semaphore operations up and down as system calls.
- The operating system briefly disables all interrupts while it is testing the semaphore, updating it, and putting the process to sleep.

Solving the Producer-Consumer Problem using Semaphores

#define N 100

typedef int semaphore;
semaphore mutex = 1;  // mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of items

void producer ()
{
    int item;
    while (true)
    {
        item = produce_item(); // produce item
        down (&empty); // check empty space
        down (&mutex); // check mutual exclusion
        insert_item(item); // insert item
        up(&mutex); // out from critical section
        up(&full); // increase # of items
    }
}

void consumer()
{
    int item;
    while (true)
    {
        down(&full); // check item in buffer
        down(&mutex); // check mutual exclusion
        item = remove_item(); // remove an item
        up(&mutex); // out from critical section
        up(&empty); // increase the empty space
        consume_item(item);
    }
}

Careless usage of Semaphore causes deadlock

#define N 100

typedef int semaphore;
semaphore mutex = 1; // mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of items

void producer ()
{
    int item;
    while (true)
    {
        item = produce_item();
        down (&mutex);
        down (&empty);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer()
{
    int item;
    while (true)
    {
        down(&full);
        down(&mutex);
        item = remove_item();
        up(&mutex);
        up(&empty);
        consume_item(item);
    }
}Date: 9/26/2024

Careless usage of Semaphore causes deadlock

#define N 100

typedef int semaphore;
semaphore mutex = 1; // mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of items

void producer () {
    int item;
    while (true) {
        item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer() {
    int item;
    while (true) {
        down(&mutex);
        down(&full);
        item = remove_item();
        up(&mutex);
        up(&empty);
        consume_item(item);
    }
}

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Dining Philosophers Problem

Five silent philosophers sit at a round table with bowls of spaghetti. Chopsticks are placed between each pair of adjacent philosophers.
Each philosopher must alternately think and eat. However, a philosopher can only eat spaghetti when they have both left and right chopsticks.
Each chopstick can be held by only one philosopher and so a philosopher can use the chopstick only if it is not being used by another philosopher.
After an individual philosopher finishes eating, they need to put down both chopsticks so that the chopsticks become available to others. A philosopher can take the chopstick on their right or the one on their left as they become available, but cannot start eating before getting both chopsticks.

Readers-Writers Problem

Process reader R and writers W are sharing resources at one time. Only one process (reader or writer) can access the shared resources at any time.
1. It is possible that a reader R1 might have the lock to a shared resource, and then another reader R2 requests access. It would be foolish for R2 to wait until R1 was done before starting its own read operation; instead, R1 and R2 can read the same resource at the same time since both are reading.
2. It is possible that a reader R1 might have the lock, a writer W be waiting for the lock, and then a reader R2 requests access. It would be unfair for R2 to jump in immediately ahead of W; if that happened often enough, W would starve.

Mutexes

When the semaphore's ability to count is not needed, the simplified version of the semaphore, called mutex, is used. It is good for managing mutual exclusion to some shared resources or pieces of code. It is useful in thread packages that are implemented in user space.
A mutex is a variable that can be in one of two states: unlocked (0) or locked (1). A mutex concept is the same as a binary semaphore which has a value of 0 or 1.9/26/2024

Mutexes

mutexes mutex = 0
repeat
    mutex_lock(mutex);
    mutex_unlock(mutex);
until false

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Critical Section
Remainder Section

Monitor

Monitor – High level synchronizing primitive 
- A collection of procedures, variables, and data structures that are all grouped together in a special kind of module.
- Only one process can be active in a monitor at any instant.
- The compiler knows that monitors are special and can handle calls to monitor procedures differently from other procedure calls (create special code for monitors).
- When a process calls a procedure inside a monitor:
    1. Check whether any process is active within the monitor or not.
    2. If so, the calling process will be suspended until the other process has left the monitor.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Implementation of Monitor
- Since a monitor is a construct for a programming language, monitor implementation is based on the compiler.
- The compiler knows that a monitor is a special kind of module and uses a mutex or binary semaphore for mutual exclusion.
- The monitor provides an easy way to achieve mutual exclusion. But we need to consider how a process can be blocked and how a blocked process can be woken up.
- Introduction of Condition variables.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Implementation of Monitor
- Conditional variables are used in the monitor.
- There are two operations on the conditional variables: wait and signal.
- When a monitor procedure discovers that it cannot continue, it waits on some condition variable (e.g., full). This action causes the calling process to block, allowing other processes to enter the monitor.
- Other processes (e.g., consumer) can wake up their sleeping partner by signaling the condition variable that their partner is waiting on.
- If there are more than one process waiting on a condition variable, the system scheduler chooses one of them.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Implementation of Monitor
- Once a process sends a signal, what is the next step for the process that sends the signal to avoid having two active processes in the monitor at the same time?

Solution 1) by Hoare
- Letting the newly awakened process run, suspending the one that sent the signal.

Solution 2) by Brinch Hansen
- A signal statement may appear only as the final statement in a monitor procedure.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Producer-Consumer with Monitor

monitor ProducerConsumer
    condition full, empty;
    integer count;

    procedure insert(item: integer);
    begin
        if count = N then
            wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then
            signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then
            wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N - 1 then
            signal(full);
    end;

    count := 0;
end monitor

procedure producer
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end;
end;

procedure consumer
begin
    while true do
    begin
        item = ProducerConsumer.remove;
        consume_item(item);
    end;
end;

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park9/26/2024

Message Passing

Message Passing is a method of interprocess communication using two primitive system calls:
1. send(destination, &message);
2. receive(source, &message);

Message Passing is usually used between processes located in different systems since it is slower than using semaphore or monitor in the same system. If no message is available, the receiver will be blocked by the system until one arrives. If there is no message to send, the sender will be blocked by the system until one becomes available.

Design Issues for Message Passing System:
- Messages can be lost.
  - Solution: When a message is received, the receiver sends an acknowledgement message. If the sender has not received the acknowledgement message within a certain time interval, it retransmits the message. This solution causes a new design issue: the receiver receives a message from the sender, sends an acknowledgement message, and if the acknowledgement message is lost, the sender sends the same message again. Then the receiver receives the same message twice.
  - Solution: Each message is assigned a sequence number. The receiver's system can recognize duplicated messages and discard one of them.

Producer-Consumer Problem (with Message Passing)

#define N 100 /* number of slots in the buffer */

void producer() {
    int item;
    message m; /* message buffer */
    while (true) {
        item = produce_item(); /* generate item to put in buffer */
        receive(consumer, &m); /* wait for an empty slot (ACK) */
        build_message(&m, item); /* construct a message to send */
        send(consumer, &m); /* send item to consumer */
    }
}

void consumer() {
    int item, i;
    message m;
    for (i = 0; i < N; i++) /* send N empty messages */
        send(producer, &m);
    while (true) {
        receive(producer, &m); /* receive a message from producer */
        item = extract_item(&m); /* extract a message */
        send(producer, &m); /* send an empty message to producer (ACK) */
        consume_item(item);
    }
}9/17/2024

Inter-Process Communication
- Race Condition
- Critical Section (or region)
- Solutions for Mutual Exclusion in a Critical Section
  - With Busy Waiting
    - Disabling Interrupts – non-preemptive kernel
    - Lock Variables – violating the first necessary condition (mutual exclusion)
    - Strict Alternation – violating the second necessary condition (block by a process outside critical section)
    - Peterson’s Solution
    - Hardware Solution
      - Test and Set Lock
      - Memory Barriers
      - Atomic Variable
  - Priority Inversion problems with busy waiting

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Interprocess Communication
Three issues in interprocess communication:
1. How one process can pass information to another (communication between processes) – with IPCS (shared memory, message queue, FIFO, PIPE, socket, …)
2. How to make sure two or more processes do not get into the critical section (mutual exclusion) – with mutex, semaphore
3. Proper sequencing (Synchronization) when dependencies are present (e.g., A creates outputs, B consumes the outputs)

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Race Condition
- A situation where two or more processes are reading or writing some shared data and the final result depends on who runs precisely when is called a race condition.

Critical section (critical region)
- The part of the program where the shared memory is accessed.

Mutual Exclusion in a critical section can avoid race conditions:
- If we could arrange matters such that no two processes were ever in their critical regions at the same time, we can avoid race conditions.

Slots for file names
- When a process wants to print a file, it enters a file name in a special spooler directory in the printer.
- The printer daemon periodically checks the spooler directory for any files that need to be printed.

Shared variable

Race Condition Example:
- Process A tries to send a job to the spooler, reads in = 7, times out, and goes to the ready state before updating in = in + 1.
- Process B tries to send a job to the spooler. It reads in = 7, loads its job name in slot 7, updates i = i + 1 = 8, and then goes to the blocked state waiting for the job.
- Process A is rescheduled by the scheduler. Process A already read in = 7, loads its job name in slot 7, updates i = i + 1 = 9, and then goes to the blocked state waiting for this job to finish.

How to avoid race conditions?
- Mutual exclusion – some way of making sure that if one process is using a shared variable or file, the other processes will be excluded from doing the same thing.

The choice of the algorithm for achieving mutual exclusion is a major design issue in any operating system.

A solution for the race condition should have the following four conditions:
1. No two processes may be simultaneously inside their critical regions – mutual exclusion.
2. No process running outside its critical region may block other processes.
3. No process should have to wait forever to enter the critical region.
4. No assumptions may be made about speeds or the number of CPUs.Date: 9/17/2024

Interprocess Communication (Race Condition)

Two approaches for mutual exclusion solutions:
1. Busy wait – A process will wait until the resource becomes available or the CPU time term expires.
2. Sleep and Wakeup – A process checks a resource; if it is not available, it goes to sleep. When the resource becomes available, the process will be woken up by the system or the process releases the resource.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

---

Mutual Exclusion with Busy Waiting

Each process has a time term. A process keeps checking the possibility of entering the critical section.

Methods of Mutual Exclusion with Busy Waiting include:
- Disabling Interrupts – non-preemptive kernel
- Lock Variables
- Strict Alternation
- Peterson’s Solution
- Hardware Solutions
- Test and Set Lock
- Memory Barriers
- Atomic Variable

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

---

Mutual Exclusion with Busy Waiting (Disabling Interrupt – Nonprimitive Kernel)

Disabling Interrupt:
- Once a process enters the critical section, interrupts are set to disable.
- Other processes cannot gain CPU time until the process finishes its work in the critical section.
- Since each user process has the power to control interrupts, it may cause a system crash.
- A simple program can be created that disables the entire system since the user has control over system interrupts (vulnerable system).

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

---

Example: End of the system with Disabling Interrupt:
1. A process enters the critical section.
2. It disables all interrupts, meaning all other processes are sleeping until the job in the critical section is completed.
3. If the process is blocked outside the critical section just before enabling all interrupts and never returns, it causes the end of the system.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

---

Mutual Exclusion with Busy Waiting (Using Lock Variable)

There is a variable called "Lock":
- A process can enter its critical section when Lock = 0.
- Lock = 0 means no process is currently running in the critical section; the process sets Lock = 1 and enters the critical section.
- Once a process finishes its job in the critical section, it sets Lock = 0, allowing other processes to enter the critical section.
- Lock = 1 means there is a process running in the critical section; other processes do busy waiting until Lock becomes 0.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

---

Code Example:
static int lock = 0; // lock variable is initially 0
repeat
    while lock == 0 do
        ; // (no-operation) // Busy waiting
    lock = 1;
    // Critical Section
    lock = 0;
until false
// Remainder Section9/17/2024

Mutual Exclusion with Busy Waiting (Using Lock Variable)
COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

static int lock = 0; // lock is initially 0
repeat
    while lock == 0 do
        ; // (no-operation) // busy waiting
    lock = 1;
    lock = 0;
until false

Critical Section
Remainder Section

Scenario:
1. Initially lock = 0.
2. A process P1 tries to get into the critical section.
3. The process P1 checks lock value = 0.
4. Process P1's CPU time is over and goes to the ready state, before updating lock = 1.
5. Process P2 tries to get into the critical section.
6. P2 checks lock value = 0.
7. P2 sets lock = 1 and goes to the critical section.
8. P2's CPU time is over and P1 is rescheduled.
9. P1 has already read lock = 0, P1 sets lock = 1 and goes to the critical section. Now P1 and P2 are in the critical section at the same time.

Violating condition #1: mutual exclusion

Mutual Exclusion with Busy Waiting (Strict Alternation)
- Variable turn can be i or j.
- If turn = i, process Pi can go to the critical section.
- Once Pi finishes its job in the critical section, Pi sets turn = j, allowing process Pj to enter the critical section.

Critical Section
Remainder Section

turn is i or j
repeat
    while turn == i do
        ; // (no-operation)
until false

Let’s assume initially turn = 0:
1. P0 is in the critical section while P1 is in the remainder section.
2. P0 finishes the critical section and sets turn = 1; P1 is still in the remainder section.
3. P0 finishes the remainder section and wants to go to the critical section, but turn = 1.
4. P1 has a fatal error in the remainder section and is trapped out by the operating system.
5. P0 is waiting forever to enter the critical section.

Violating conditions #2 and #3:
2. No process running outside its critical region may block other processes.
3. No process should have to wait forever to enter the critical region.

Mutual Exclusion with Busy Waiting (Peterson’s Solution)
- Peterson’s solution provides a good algorithmic description of solving the critical-section problem and illustrates some of the complexities involved in designing software that addresses the requirements of mutual exclusion, progress, and bounded waiting.
- Peterson’s solution is restricted to two processes that alternate execution between their critical sections and remainder sections.
- The processes are numbered P0 and P1.
- For convenience, when presenting Pi, we use Pj to denote the other process; that is, j equals 1 - i.

#define false 0
#define true 1
#define n 2
int turn;
int interested[n];

void enter_region(int process) {
    int other;
    other = 1 - process;
    interested[process] = true;
    turn = process;
    while (turn == process && interested[other] == true)
        ; // no operation – busy waiting
}

void leave_region(int process) {
    interested[process] = false;
}

void main() {
    repeat
        enter_region(int i);
        // Critical Section
        leave_region(int i);
        // Remainder Section
    until false;
}

Mutual Exclusion with Busy Waiting (Peterson’s Solution)
1. Initially, neither process is in the critical section.
2. A process P0 calls enter_region(0):
   a) Set interested[0] = true;
   b) Set turn = 0.
3. Go to the critical section.
4. The process P1 calls enter_region(1) to get into its critical section:
   a) Set interested[1] = true;
   b) Set turn = 1.
5. Since interested[0] = true, it keeps looping for interested[0] = false.
6. Finally, process P0 finishes its critical section and calls leave_region(0):
   1. Set interested[0] = false.
7. Now P1 finds out interested[0] = false, and P1 goes to its critical section.9/17/2024

Mutual Exclusion with Busy Waiting (Peterson’s Solution)

Let's consider the case where both P0 and P1 call enter_region(0) and enter_region(1) almost simultaneously.

Assume interest[0] = true and interest[1] = true at the same time. However, turn can only be either turn = 0 or turn = 1; whichever store is done last is the one that counts!

Case 1: turn = 0
Inside enter_region(0):
- Since turn = 0 and interest[1] = true, P0 keeps looping in a no-operation state until P1 sets interest[1] = false.

Inside enter_region(1):
- Since turn = 0 and interest[0] = true, P1 goes to its critical section.

Case 2: turn = 1
Inside enter_region(0):
- Since turn = 1 and interest[1] = true, P0 goes to its critical section.

Inside enter_region(1):
- Since turn = 1 and interest[0] = true, P1 keeps looping in a no-operation state until P0 sets interest[0] = false.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Test and Set Lock – hardware solution)

Since the Test and Set Lock (TSL) instruction is a hardware instruction, the operations of reading the lock and storing it into a register are guaranteed to be indivisible.

Instruction: test and set lock
TSL RX, LOCK
1. Read the content at the memory address of LOCK into register RX.
2. Store a non-zero value at the memory address of LOCK.

The operations of reading the content of LOCK and storing into it are guaranteed to be indivisible.

How to use Test and Set Lock instruction for solving race condition:
- When LOCK = 0, any process may set LOCK = 1 by using the TSL instruction and go to its critical section.
- When the process finishes its critical section, it sets LOCK = 0 using the original move instruction.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Enter_region:
TSL Register, LOCK
CMP Register, #0
JNE Enter_region
Set LOCK, #1
RET

Leave_region:
MOVE LOCK, #0
RET

Repeat
Enter_region
Leave_region
until false

Critical Section
Remainder Section

Mutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)

There are two general memory models:
1. Strongly ordered Memory – a memory modification on one processor is immediately visible to all other processors.
2. Weakly ordered Memory – a memory modification on one processor may not be immediately visible to other processors.

With strongly ordered memory, computer architectures provide instructions that can force any changes in memory to be propagated to all other processors, ensuring that memory modifications are visible to threads (or processes) running on other processors. Such instructions are known as memory barriers or memory fences.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

A memory barrier is a type of barrier instruction that causes a central processing unit (CPU) or compiler to enforce an ordering constraint on memory operations issued before and after the barrier instruction. This typically means that operations issued prior to the barrier are guaranteed to be performed before operations issued after the barrier.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Example:
Assume two threads (or processes) are running on different parts of a program by sharing two variables: (bool flag = false; int x = 0;)
Thread 1 might print 0 or 100 depending on the order of execution. By using a memory barrier instruction, Thread 1 will always print 100.

while (!flag)
    print x;
    x = 100;
    flag = true;

Thread 1
Thread 29/17/2024

Mutual Exclusion with Busy Waiting
(Memory Barriers – hardware solution)

- It is guaranteed that the value of flag is loaded before the value of x.
- It is also guaranteed that the assignment to x occurs before the assignment to flag.
- Therefore, Thread 1 always prints 100.

```plaintext
while (!flag)
    memory_barrier();
print x;
x = 100;
memory_barrier();
flag = true;
```

Thread 1
Thread 2

Mutual Exclusion with Busy Waiting
(Atomic Variables – hardware solution)

- We can avoid mutual exclusion by using atomic operations.
- When a thread (or process) performs an atomic operation, the other threads (or processes) see it as happening instantaneously.
- The advantage of atomic operations is that they are relatively quick compared to locks, and do not suffer from deadlock and convoying.
- The disadvantage is that they only perform a limited set of operations, often insufficient to synthesize more complicated operations efficiently.
- However, one should not miss the opportunity to use an atomic operation instead of mutual exclusion.

Mutual Exclusion with Busy Waiting
(Priority Inversion Problem)

- Peterson's solution, test and set lock, memory barrier, and atomic variable method involve busy waiting, which wastes CPU time.

Priority Inversion problem with busy waiting method:
1. Consider a computer with two processes: PH (high priority) and PL (low priority).
2. The scheduling rules ensure that PH gets CPU time whenever it is in a ready state (preemptive priority scheduling).
3. At time T0: PL is in the critical section, while PH is in the blocked state.
4. At time T1: PH changes state from blocked to ready and tries to enter the critical section, but PL is still in the critical section.
5. Based on the scheduling rule, the short-term scheduler selects PH, which holds the CPU and attempts to enter the critical section.
6. Since PL is in the critical section, PH runs busy waiting outside the critical section forever, as PL does not receive CPU time to finish its critical section.

The scheduling rules dictate that the CPU scheduler will always select the higher priority process.
2024-12-19 01:11:20 - INFO - Processing pages: 0, full_response: Yes
2024-12-19 01:11:20 - INFO - Created 1 tasks for question generation
2024-12-19 01:11:20 - INFO - Starting question_generate_chain
2024-12-19 01:11:20 - INFO - Setting up question generation chain
2024-12-19 01:11:20 - INFO - Chain type: <class 'langchain_core.runnables.base.RunnableSequence'>
2024-12-19 01:11:20 - INFO - Question generation chain setup complete
2024-12-19 01:12:13 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 01:12:13 - INFO - Generated 8 questions for Operating Systems with the following questions: [QAPair(question='What is the main difference between hard real-time systems and soft real-time systems?', answer='In hard real-time systems, missing a deadline is considered a system failure, while in soft real-time systems, deadlines can be missed occasionally without critical consequences.', q_type='multiple_choice', choices=['Hard real-time systems have no deadlines.', 'Soft real-time systems are more reliable than hard real-time systems.', 'In hard real-time systems, missing a deadline is considered a system failure, while in soft real-time systems, deadlines can be missed occasionally without critical consequences.', 'Both types of systems handle deadlines in the same way.']), QAPair(question='Which of the following scheduling algorithms is theoretically optimal and can achieve 100% CPU utilization?', answer='Earliest-Deadline-First scheduling.', q_type='multiple_choice', choices=['Rate-Monotonic Scheduling', 'Earliest-Deadline-First Scheduling', 'Proportional Share Scheduling', 'Preemptive Priority-Based Scheduling']), QAPair(question='True or False: Interrupt latency is the time taken from the arrival of an interrupt at the CPU to the start of the routine that services the interrupt.', answer='True', q_type='TF', choices=['True', 'False']), QAPair(question='True or False: Dispatch latency refers to the time it takes for a process to finish execution and enter the waiting state.', answer='False', q_type='TF', choices=['True', 'False']), QAPair(question='Explain the process of Rate-Monotonic Scheduling and its priority assignment.', answer='Rate-Monotonic Scheduling assigns priorities to periodic processes based on the length of their period. The shorter the period, the higher the priority. This scheduling method assumes that the processing time of a periodic process is consistent across CPU bursts. It uses static priority policies with preemption, meaning a higher-priority process can interrupt a lower-priority one.', q_type='written', choices=[]), QAPair(question='Describe the Producer-Consumer problem and provide a solution using semaphores.', answer="The Producer-Consumer problem involves two processes sharing a fixed-size buffer where the producer generates data and the consumer reads it. Problems arise when the buffer is full (producer must wait) or empty (consumer must wait). Using semaphores, the producer can signal when it has produced an item using a 'full' semaphore and wait using an 'empty' semaphore when the buffer is full. The consumer does the opposite, signaling when it has consumed an item using 'empty' and waiting on 'full' when the buffer is empty.", q_type='written', choices=[]), QAPair(question='What are the main characteristics of a real-time CPU scheduling process, and how are they expressed mathematically?', answer='Real-time CPU scheduling processes are characterized by their period (p), deadline (d), and processing time (t). These characteristics are mathematically expressed as: 0 ≤ t ≤ d ≤ p. This relationship indicates that the processing time must be less than or equal to the deadline, which in turn must be less than or equal to the period.', q_type='written', choices=[]), QAPair(question='Discuss the implications of priority inversion in operating systems and how it can affect real-time systems.', answer='Priority inversion occurs when a lower-priority process holds a resource needed by a higher-priority process, causing the high-priority process to be blocked. This can lead to scenarios where the high-priority process waits indefinitely while a low-priority process runs, violating real-time constraints. To mitigate this, various techniques such as priority inheritance can be employed, allowing the lower-priority process to temporarily elevate its priority to finish execution and release the resource.', q_type='written', choices=[])]
2024-12-19 01:12:13 - INFO - Finished question_generate_chain
2024-12-19 01:12:13 - INFO - Completed question generation. Number of results: 1
2024-12-19 01:12:13 - INFO - Generated test list with 1 tests
2024-12-19 01:12:13 - INFO - Preparing judge_kwargs with 9 parameters
2024-12-19 01:12:13 - INFO - FINAL TEST:
{
    "questions": [
        {
            "question": "What is the main difference between hard real-time systems and soft real-time systems?",
            "answer": "In hard real-time systems, missing a deadline is considered a system failure, while in soft real-time systems, deadlines can be missed occasionally without critical consequences.",
            "q_type": "multiple_choice",
            "choices": [
                "Hard real-time systems have no deadlines.",
                "Soft real-time systems are more reliable than hard real-time systems.",
                "In hard real-time systems, missing a deadline is considered a system failure, while in soft real-time systems, deadlines can be missed occasionally without critical consequences.",
                "Both types of systems handle deadlines in the same way."
            ]
        },
        {
            "question": "Which of the following scheduling algorithms is theoretically optimal and can achieve 100% CPU utilization?",
            "answer": "Earliest-Deadline-First scheduling.",
            "q_type": "multiple_choice",
            "choices": [
                "Rate-Monotonic Scheduling",
                "Earliest-Deadline-First Scheduling",
                "Proportional Share Scheduling",
                "Preemptive Priority-Based Scheduling"
            ]
        },
        {
            "question": "True or False: Interrupt latency is the time taken from the arrival of an interrupt at the CPU to the start of the routine that services the interrupt.",
            "answer": "True",
            "q_type": "TF",
            "choices": [
                "True",
                "False"
            ]
        },
        {
            "question": "True or False: Dispatch latency refers to the time it takes for a process to finish execution and enter the waiting state.",
            "answer": "False",
            "q_type": "TF",
            "choices": [
                "True",
                "False"
            ]
        },
        {
            "question": "Explain the process of Rate-Monotonic Scheduling and its priority assignment.",
            "answer": "Rate-Monotonic Scheduling assigns priorities to periodic processes based on the length of their period. The shorter the period, the higher the priority. This scheduling method assumes that the processing time of a periodic process is consistent across CPU bursts. It uses static priority policies with preemption, meaning a higher-priority process can interrupt a lower-priority one.",
            "q_type": "written",
            "choices": []
        },
        {
            "question": "Describe the Producer-Consumer problem and provide a solution using semaphores.",
            "answer": "The Producer-Consumer problem involves two processes sharing a fixed-size buffer where the producer generates data and the consumer reads it. Problems arise when the buffer is full (producer must wait) or empty (consumer must wait). Using semaphores, the producer can signal when it has produced an item using a 'full' semaphore and wait using an 'empty' semaphore when the buffer is full. The consumer does the opposite, signaling when it has consumed an item using 'empty' and waiting on 'full' when the buffer is empty.",
            "q_type": "written",
            "choices": []
        },
        {
            "question": "What are the main characteristics of a real-time CPU scheduling process, and how are they expressed mathematically?",
            "answer": "Real-time CPU scheduling processes are characterized by their period (p), deadline (d), and processing time (t). These characteristics are mathematically expressed as: 0 \u2264 t \u2264 d \u2264 p. This relationship indicates that the processing time must be less than or equal to the deadline, which in turn must be less than or equal to the period.",
            "q_type": "written",
            "choices": []
        },
        {
            "question": "Discuss the implications of priority inversion in operating systems and how it can affect real-time systems.",
            "answer": "Priority inversion occurs when a lower-priority process holds a resource needed by a higher-priority process, causing the high-priority process to be blocked. This can lead to scenarios where the high-priority process waits indefinitely while a low-priority process runs, violating real-time constraints. To mitigate this, various techniques such as priority inheritance can be employed, allowing the lower-priority process to temporarily elevate its priority to finish execution and release the resource.",
            "q_type": "written",
            "choices": []
        }
    ]
}
2024-12-19 01:12:13 - INFO - All tasks completed. Number of results: 4
2024-12-19 01:12:13 - INFO - Generated 1 tests
2024-12-19 01:12:13 - INFO - Cleaning up temp files
2024-12-19 01:12:13 - INFO - Deleted temp file: /tmp/tmplpxmqkix
2024-12-19 01:12:13 - INFO - Deleted temp file: /tmp/tmp50p_945n
2024-12-19 01:12:13 - INFO - Deleted temp file: /tmp/tmpedy24fk1
2024-12-19 01:12:13 - INFO - Deleted temp file: /tmp/tmpye5dombc
2024-12-19 01:12:13 - INFO - Temp files cleaned
2024-12-19 01:12:13 - INFO - Run function completed
2024-12-19 01:12:13 - INFO - Test generated successfully
2024-12-19 01:13:36 - INFO - GET request received for index page
2024-12-19 01:13:52 - INFO - GET request received for index page
2024-12-19 01:15:17 - INFO - GET request received for index page
2024-12-19 01:15:17 - INFO - GET request received for index page
2024-12-19 01:15:39 - INFO - GET request received for index page
2024-12-19 01:16:32 - INFO - GET request received for index page
2024-12-19 01:27:52 - INFO - GET request received for index page
2024-12-19 01:28:30 - INFO - GET request received for index page
2024-12-19 01:31:15 - INFO - GET request received for index page
2024-12-19 02:42:45 - INFO - GET request received for index page
2024-12-19 02:43:06 - INFO - GET request received for index page
2024-12-19 02:43:10 - INFO - GET request received for index page
2024-12-19 02:43:11 - INFO - GET request received for index page
2024-12-19 02:48:59 - INFO - GET request received for index page
2024-12-19 02:49:03 - INFO - GET request received for index page
2024-12-19 02:49:29 - INFO - GET request received for index page
2024-12-19 02:52:13 - INFO - GET request received for index page
2024-12-19 02:54:49 - INFO - GET request received for index page
2024-12-19 02:55:30 - INFO - GET request received for index page
2024-12-19 02:56:05 - INFO - GET request received for index page
2024-12-19 02:58:01 - INFO - POST request received for /generate
2024-12-19 02:58:01 - INFO - Form data: title='Family Tree' course='A' professor='X' number_of_written_questions=1 number_of_mcq_questions=2 number_of_TF_questions=2 level='Normal' school_type='Undergraduate' difficulty='easy' testing_philosophy='E' url_1=None url_2=None subject_material=[UploadFile(filename='OBrienFamilyNotes.pdf', size=1043503, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="OBrienFamilyNotes.pdf"', 'content-type': 'application/pdf'}))]
2024-12-19 02:58:01 - INFO - Starting run function
2024-12-19 02:58:01 - INFO - Form data accessed
2024-12-19 02:58:01 - INFO - Form Title: Family Tree
2024-12-19 02:58:01 - INFO - Form Course: A
2024-12-19 02:58:01 - INFO - Form Professor: X
2024-12-19 02:58:01 - INFO - Form Number of MCQ Questions: 2
2024-12-19 02:58:01 - INFO - Form Number of TF Questions: 2
2024-12-19 02:58:01 - INFO - Form Number of Written Questions: 1
2024-12-19 02:58:01 - INFO - Form School Type: Undergraduate
2024-12-19 02:58:01 - INFO - Form Difficulty: easy
2024-12-19 02:58:01 - INFO - Form Testing Philosophy: E
2024-12-19 02:58:01 - INFO - Moving to files...
2024-12-19 02:58:01 - INFO - Starting to process files
2024-12-19 02:58:01 - INFO - Processing file: OBrienFamilyNotes.pdf
2024-12-19 02:58:01 - INFO - Getting loader for file: UploadFile(filename='OBrienFamilyNotes.pdf', size=1043503, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="OBrienFamilyNotes.pdf"', 'content-type': 'application/pdf'}))
2024-12-19 02:58:01 - INFO - File extension: .pdf
2024-12-19 02:58:01 - INFO - Processing PDF file: OBrienFamilyNotes.pdf
2024-12-19 02:58:01 - INFO - Using loader type: PyMuPDFLoader for UploadFile(filename='OBrienFamilyNotes.pdf', size=1043503, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="OBrienFamilyNotes.pdf"', 'content-type': 'application/pdf'}))
2024-12-19 02:58:01 - INFO - URLs: []
2024-12-19 02:58:01 - INFO - Processing 1 files and 0 URLs
2024-12-19 02:58:01 - INFO - Processing OBrienFamilyNotes.pdf
2024-12-19 02:58:01 - INFO - Using loader type: PyMuPDFLoader for OBrienFamilyNotes.pdf
2024-12-19 02:58:01 - INFO - Processing OBrienFamilyNotes.pdf as a regular document using PyMuPDFLoader
2024-12-19 02:58:01 - INFO - Successfully loaded 8 documents from: OBrienFamilyNotes.pdf
2024-12-19 02:58:01 - INFO - Docs: [Document(metadata={'source': '/tmp/tmpv68pbahk', 'file_path': '/tmp/tmpv68pbahk', 'page': 0, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}, page_content="Page 1\nJoseph Albert O'Brien*\nb:\n24 Apr 1932 in Bronx,  \nBronx, New York\nm: 07 Oct 1956\nd:\n07 Jan 2011 in  \nAnnapolis, Anne  \nArundel, Maryland\nJoseph A O'Brien*\nb:\nAbt. 1905 in New  \nYork\nm: 02 Aug 1931 in  \nBronx, New York; St.  \nAnselm's Church - 68  \nTinton Ave\nd:\n20 Nov 1945 in  \nBronx, New York\nGenevieve Godziemski*\nb:\n01 Nov 1911 in New  \nYork\nd:\n23 Jul 1989 in  \nHollywood, Broward,  \nFlorida; Age at Death:  \n77\nJoseph Albert Obrien*\nb:\n20 Jan 1875 in New  \nYork\nm: 17 Dec 1901 in  \nManhattan, New York;  \nBased on information  \nfrom 1910 Census\nd:\nBef. 1940 in Bronx,  \nNew York; Wife was a  \nwidow in the 1940  \nCensus.\nMary T Flanagan*\nb:\nAbt. 1879 in New  \nYork\nd:\n07 Jan 1952 in  \nBronx, New York\nWalter (Wladislaw) \nGodziemski \n(Godzembsky)\nb:\n05 Mar 1877 in  \nPoland\nm: 02 Sep 1906 in New  \nYork\nd:\n19 Aug 1943 in  \nRichmond, New York\nMariana (Mary) Zwalina*\nb:\n15 Mar 1878 in  \nKolna, Podlaskie,  \nPoland\nd:\n02 Oct 1960 in \nBronx, New York\n3\n2\nPedigree Chart for  \nJoseph Albert O'Brien*\n"), Document(metadata={'source': '/tmp/tmpv68pbahk', 'file_path': '/tmp/tmpv68pbahk', 'page': 1, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}, page_content="Page 2\nJoseph Albert Obrien*\nb:\n20 Jan 1875 in New  \nYork\nm: 17 Dec 1901 in  \nManhattan, New York;  \nBased on information  \nfrom 1910 Census\nd:\nBef. 1940 in Bronx,  \nNew York; Wife was a  \nwidow in the 1940  \nCensus.\nJohn O'Brien\nb:\nAbt. 1848 in New  \nYork\nm:\nd:\nAnnie O'Brien\nb:\nJun 1855 in New  \nYork\nd:\n1\n"), Document(metadata={'source': '/tmp/tmpv68pbahk', 'file_path': '/tmp/tmpv68pbahk', 'page': 2, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}, page_content='Page 3\nMary T Flanagan*\nb:\nAbt. 1879 in New  \nYork\nm: 17 Dec 1901 in  \nManhattan, New York;  \nBased on information  \nfrom 1910 Census\nd:\n07 Jan 1952 in  \nBronx, New York\nPeter Flanagan\nb:\nm:\nd:\nEllen Flanagan\nb:\nScotland\nd:\n1\n'), Document(metadata={'source': '/tmp/tmpv68pbahk', 'file_path': '/tmp/tmpv68pbahk', 'page': 3, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}, page_content="Individual Report for Joseph Albert Obrien*\nSex:\nAnnie O'Brien\nMother:\nJohn O'Brien\nFather:\nMale\nJoseph Albert Obrien*1-10\nIndividual Summary:\nIndividual Facts:\nBirth:\n20 Jan 1875 in New York1-4, 6-8, 10\nResidence:\n1880 in New York City, New York, New York; Age: 5Marital Status: Single;\nRelation to Head of House: Son5\nResidence:\n1900 in Manhattan, New York, New York; Age: 23Marital Status: Single;\nRelation to Head of House: Son4\nResidence:\n1905 in Manhattan, New York, New York; Relation to Head of House:\nHead10\nResidence:\n1910 in Bronx Assembly District 32, New York, New York, USA; Age:\n34Marital Status: Married; Relation to Head of House: Head1\nResidence:\n01 Jun 1915 in New York, Bronx, New York, United States8\nResidence:\n1917 in Bronx, Bronx, New York7\nResidence:\n1920 in Bronx Assembly District 3, Bronx, New York, USA; Age: 44Marital\nStatus: Married; Relation to Head of House: Head2\nResidence:\n01 Jun 1925 in New York, Bronx, New York; Age: 50Relation to Head of\nHouse: Head3\nResidence:\n1930 in Bronx, Bronx, New York; Age: 53Marital Status: Married; Relation to\nHead of House: Head6\nDeath:\nBef. 1940 in Bronx, New York; Wife was a widow in the 1940 Census.\nShared Facts:\nMary T Flanagan*\nMarriage:\n17 Dec 1901 in Manhattan, New York; Based on information from 1910\nCensus\nChildren:\nEdna Mary O'Brien\nJoseph A O'Brien*\nWilliam Francis O'Brien\nRaymond O'Brien V\nJohn Edward Obrien\nEdwin Obrien\nEileen R O'Brien\nNotes:\nPerson Notes:\n[no notes]\nSources:\n1 Ancestry.com, 1910 United States Federal Census (Online publication - Provo, UT, USA:\nAncestry.com Operations Inc, 2006.Original data - Thirteenth Census of the United States,\n1910 (NARA microfilm publication T624, 1,178 rolls). Records of the Bureau of the Census,\nRecord Group 29. National Archives, Was), Ancestry.com, http://www.Ancestry.com, Year:\n1910; Census Place: Bronx Assembly District 32, New York, New York; Roll: T624_997;\nPage: 1A; Enumeration District: 1451; FHL microfilm: 1375010.\n2 Ancestry.com, 1920 United States Federal Census (Online publication - Provo, UT, USA:\nAncestry.com Operations Inc, 2010. Images reproduced by FamilySearch.Original data -\nFourteenth Census of the United States, 1920. (NARA microfilm publication T625, 2076\nrolls). Records of the Bureau of the Census, Reco), iOS Application, http://www.iOS\nApplication, Year: 1920; Census Place: Bronx Assembly District 3, Bronx, New York.\n3 Ancestry.com, New York, State Census, 1925 (Ancestry.com Operations, Inc.),\nAncestry.com, http://www.Ancestry.com, New York State Archives; Albany, New York; State\nPopulation Census Schedules, 1925; Election District: 03; Assembly District: 06; City: New\nYork; County: Bronx; Page: 16.\n"), Document(metadata={'source': '/tmp/tmpv68pbahk', 'file_path': '/tmp/tmpv68pbahk', 'page': 4, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}, page_content='Sources:\n4 Ancestry.com, 1900 United States Federal Census (Online publication - Provo, UT, USA:\nAncestry.com Operations Inc, 2004.Original data - United States of America, Bureau of the\nCensus. Twelfth Census of the United States, 1900. Washington, D.C.: National Archives and\nRecords Administration, 1900. T623, 18), Ancestry.com, http://www.Ancestry.com, Year:\n1900; Census Place: Manhattan, New York, New York; Roll: 1123; Page: 9B; Enumeration\nDistrict: 0933; FHL microfilm: 1241123.\n5 Ancestry.com and The Church of Jesus Christ of Latter-day Saints, 1880 United States\nFederal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2010.\n1880 U.S. Census Index provided by The Church of Jesus Christ of Latter-day Saints ©\nCopyright 1999 Intellectual Reserve, Inc. All rights reserved. All use is subject to the limited\n), Ancestry.com, http://www.Ancestry.com, Year: 1880; Census Place: New York City, New\nYork, New York; Roll: 898; Family History Film: 1254898; Page: 513D; Enumeration District:\n636; Image: 0387.\n6 Ancestry.com, 1930 United States Federal Census (Online publication - Provo, UT, USA:\nAncestry.com Operations Inc, 2002.Original data - United States of America, Bureau of the\nCensus. Fifteenth Census of the United States, 1930. Washington, D.C.: National Archives\nand Records Administration, 1930. T626.), Ancestry.com, http://www.Ancestry.com, Year:\n1930; Census Place: Bronx, Bronx, New York; Roll: 1470; Page: 16B; Enumeration District:\n220; Image: 179.0; FHL microfilm: 2341205.\n7 U.S., World War I Draft Registration Cards, 1917-1918 (Ancestry.com. U.S., World War I\nDraft Registration Cards, 1917-1918 [database on-line]. Provo, UT, USA: Ancestry.com\nOperations Inc, 2005.), Ancestry.com, http://www.Ancestry.com, Registration State: New\nYork; Registration County: Bronx; Roll: 1753937; Draft Board: 4.\n8 Ancestry.com, New York, State Census, 1915 (Online publication - Provo, UT, USA:\nAncestry.com Operations, Inc., 2012.Original data - State population census schedules,\n1915. Albany, New York: New York State Archives.Original data: State population census\nschedules, 1915. Albany, New York: New York S), Ancestry.com, http://www.Ancestry.com,\nSource Citation: New York State Archives; Albany, New York; State Population Census\nSchedules, 1915; Election District: 30; Assembly District: 32; City: New York; County: Bronx;\nPage: 96. Name: Joseph Albert Obrien birth date: 20 Jan 1875 birth place: New York\nresidence date: 1 June 1915 residence place: New York, Bronx, New York, United States.\n9 Ancestry.com, New York, New York, Marriage Indexes 1866-1937 (Ancestry.com Operations,\nInc.), Ancestry.com, http://www.Ancestry.com.\n10 Ancestry.com, New York, State Census, 1905 (Ancestry.com Operations, Inc.),\nAncestry.com, http://www.Ancestry.com, New York State Archives; Albany, New York; State\nPopulation Census Schedules, 1905; Election District: A.D. 33 E.D. 18; City: Manhattan;\nCounty: New York; Page: 57.\n'), Document(metadata={'source': '/tmp/tmpv68pbahk', 'file_path': '/tmp/tmpv68pbahk', 'page': 5, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}, page_content="Family View Report for Joseph Albert Obrien*\nJohn O'Brien\n1848 -\nJoseph Albert Obrien*\n1875 - 1940\nJames Coffey\n? O'Brien\nAnnie O'Brien\n1855 -\nMary T Flanagan*\nAbt. 1879\nNew York\n07 Jan 1952\nBronx, New York\nBorn:\nDied:\nMarriage:\n17 Dec 1901 in Manhattan, New York; Based on information from 1910 Census\nJoseph Albert Obrien*\n20 Jan 1875\nNew York\nBef. 1940\nBronx, New York\nBorn:\nDied:\nDeath\nChildren:\nSex Birth\nF\nEdna Mary O'Brien\n21 Mar 1902\nManhattan, New York\nM\nJoseph A O'Brien*\n20 Nov 1945\nBronx, New York\nAbt. 1905\nNew York\nM\nWilliam Francis O'Brien\n17 Aug 1995\nCranbury, Middlesex, New Jersey\n20 May 1906\nBronx, New York\nM\nRaymond O'Brien V\nAbt. 1908\nNew York\nM\nJohn Edward Obrien\nAbt. 1910\nNew York\nM\nEdwin Obrien\nAbt. 1914\nNew York\nF\nEileen R O'Brien\n05 Jan 2013\nNew York\n23 Nov 1919\nNew York\n"), Document(metadata={'source': '/tmp/tmpv68pbahk', 'file_path': '/tmp/tmpv68pbahk', 'page': 6, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}, page_content="Individual Report for John O'Brien\nSex:\nMother:\nFather:\nMale\nJohn O'Brien1\nIndividual Summary:\nIndividual Facts:\nBirth:\nAbt. 1848 in New York1\nResidence:\n1880 in New York City, New York, New York; Age: 32Marital Status:\nMarried; Relation to Head of House: Self; Occupation: Plumber1\nShared Facts:\nAnnie O'Brien\n[no facts]\nChildren:\nJoseph Albert Obrien*\nMary R O'Brien\nJohn A O'Brien\nHelen Bridget O'Brien\nAnnie O'Brien\nWilliam F O'Brien\nGertrude O'Brien\nNotes:\nPerson Notes:\n[no notes]\nSources:\n1 Ancestry.com and The Church of Jesus Christ of Latter-day Saints, 1880 United States\nFederal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2010.\n1880 U.S. Census Index provided by The Church of Jesus Christ of Latter-day Saints ©\nCopyright 1999 Intellectual Reserve, Inc. All rights reserved. All use is subject to the limited\n), Ancestry.com, http://www.Ancestry.com, Year: 1880; Census Place: New York City, New\nYork, New York; Roll: 898; Family History Film: 1254898; Page: 513D; Enumeration District:\n636; Image: 0387.\n"), Document(metadata={'source': '/tmp/tmpv68pbahk', 'file_path': '/tmp/tmpv68pbahk', 'page': 7, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}, page_content='')] for OBrienFamilyNotes.pdf using PyMuPDFLoader
2024-12-19 02:58:01 - INFO - Document 1 (OBrienFamilyNotes.pdf) of 8
2024-12-19 02:58:01 - INFO - Starting clean_files_chain
2024-12-19 02:58:01 - INFO - Document: page_content='Page 1
Joseph Albert O'Brien*
b:
24 Apr 1932 in Bronx,  
Bronx, New York
m: 07 Oct 1956
d:
07 Jan 2011 in  
Annapolis, Anne  
Arundel, Maryland
Joseph A O'Brien*
b:
Abt. 1905 in New  
York
m: 02 Aug 1931 in  
Bronx, New York; St.  
Anselm's Church - 68  
Tinton Ave
d:
20 Nov 1945 in  
Bronx, New York
Genevieve Godziemski*
b:
01 Nov 1911 in New  
York
d:
23 Jul 1989 in  
Hollywood, Broward,  
Florida; Age at Death:  
77
Joseph Albert Obrien*
b:
20 Jan 1875 in New  
York
m: 17 Dec 1901 in  
Manhattan, New York;  
Based on information  
from 1910 Census
d:
Bef. 1940 in Bronx,  
New York; Wife was a  
widow in the 1940  
Census.
Mary T Flanagan*
b:
Abt. 1879 in New  
York
d:
07 Jan 1952 in  
Bronx, New York
Walter (Wladislaw) 
Godziemski 
(Godzembsky)
b:
05 Mar 1877 in  
Poland
m: 02 Sep 1906 in New  
York
d:
19 Aug 1943 in  
Richmond, New York
Mariana (Mary) Zwalina*
b:
15 Mar 1878 in  
Kolna, Podlaskie,  
Poland
d:
02 Oct 1960 in 
Bronx, New York
3
2
Pedigree Chart for  
Joseph Albert O'Brien*
' metadata={'source': '/tmp/tmpv68pbahk', 'file_path': '/tmp/tmpv68pbahk', 'page': 0, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}
2024-12-19 02:58:01 - INFO - Invoking chain
2024-12-19 02:58:07 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 02:58:07 - INFO - Response: {'cleaned_content': "Page 1\n\nJoseph Albert O'Brien\n- Born: 24 Apr 1932 in Bronx, New York\n- Married: 07 Oct 1956\n- Died: 07 Jan 2011 in Annapolis, Anne Arundel, Maryland\n\nJoseph A O'Brien\n- Born: Approximately 1905 in New York\n- Married: 02 Aug 1931 in Bronx, New York; St. Anselm's Church - 68 Tinton Ave\n- Died: 20 Nov 1945 in Bronx, New York\n\nGenevieve Godziemski\n- Born: 01 Nov 1911 in New York\n- Died: 23 Jul 1989 in Hollywood, Broward, Florida; Age at Death: 77\n\nJoseph Albert O'Brien\n- Born: 20 Jan 1875 in New York\n- Married: 17 Dec 1901 in Manhattan, New York; Based on information from 1910 Census\n- Died: Before 1940 in Bronx, New York; Wife was a widow in the 1940 Census.\n\nMary T Flanagan\n- Born: Approximately 1879 in New York\n- Died: 07 Jan 1952 in Bronx, New York\n\nWalter (Wladislaw) Godziemski (Godzembsky)\n- Born: 05 Mar 1877 in Poland\n- Married: 02 Sep 1906 in New York\n- Died: 19 Aug 1943 in Richmond, New York\n\nMariana (Mary) Zwalina\n- Born: 15 Mar 1878 in Kolna, Podlaskie, Poland\n- Died: 02 Oct 1960 in Bronx, New York\n\nPedigree Chart for Joseph Albert O'Brien"}
2024-12-19 02:58:07 - INFO - Finished clean_files_chain
2024-12-19 02:58:07 - INFO - Successfully cleaned document 1 from OBrienFamilyNotes.pdf
2024-12-19 02:58:07 - INFO - Document 2 (OBrienFamilyNotes.pdf) of 8
2024-12-19 02:58:07 - INFO - Starting clean_files_chain
2024-12-19 02:58:07 - INFO - Document: page_content='Page 2
Joseph Albert Obrien*
b:
20 Jan 1875 in New  
York
m: 17 Dec 1901 in  
Manhattan, New York;  
Based on information  
from 1910 Census
d:
Bef. 1940 in Bronx,  
New York; Wife was a  
widow in the 1940  
Census.
John O'Brien
b:
Abt. 1848 in New  
York
m:
d:
Annie O'Brien
b:
Jun 1855 in New  
York
d:
1
' metadata={'source': '/tmp/tmpv68pbahk', 'file_path': '/tmp/tmpv68pbahk', 'page': 1, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}
2024-12-19 02:58:07 - INFO - Invoking chain
2024-12-19 02:58:09 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 02:58:09 - INFO - Response: {'cleaned_content': "Joseph Albert O'Brien\nBorn: 20 January 1875 in New York\nMarried: 17 December 1901 in Manhattan, New York\nBased on information from the 1910 Census\nDied: Before 1940 in Bronx, New York; Wife was a widow in the 1940 Census.\n\nJohn O'Brien\nBorn: Approximately 1848 in New York\nMarried: \nDied: \n\nAnnie O'Brien\nBorn: June 1855 in New York\nDied: "}
2024-12-19 02:58:09 - INFO - Finished clean_files_chain
2024-12-19 02:58:09 - INFO - Successfully cleaned document 2 from OBrienFamilyNotes.pdf
2024-12-19 02:58:09 - INFO - Document 3 (OBrienFamilyNotes.pdf) of 8
2024-12-19 02:58:09 - INFO - Starting clean_files_chain
2024-12-19 02:58:09 - INFO - Document: page_content='Page 3
Mary T Flanagan*
b:
Abt. 1879 in New  
York
m: 17 Dec 1901 in  
Manhattan, New York;  
Based on information  
from 1910 Census
d:
07 Jan 1952 in  
Bronx, New York
Peter Flanagan
b:
m:
d:
Ellen Flanagan
b:
Scotland
d:
1
' metadata={'source': '/tmp/tmpv68pbahk', 'file_path': '/tmp/tmpv68pbahk', 'page': 2, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}
2024-12-19 02:58:09 - INFO - Invoking chain
2024-12-19 02:58:11 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 02:58:11 - INFO - Response: {'cleaned_content': 'Page 3\n\nMary T. Flanagan\nBorn: Approximately 1879 in New York\nMarried: 17 December 1901 in Manhattan, New York; Based on information from the 1910 Census\nDied: 07 January 1952 in Bronx, New York\n\nPeter Flanagan\nBorn: \nMarried: \nDied: \n\nEllen Flanagan\nBorn: Scotland\nDied: 1'}
2024-12-19 02:58:11 - INFO - Finished clean_files_chain
2024-12-19 02:58:11 - INFO - Successfully cleaned document 3 from OBrienFamilyNotes.pdf
2024-12-19 02:58:11 - INFO - Document 4 (OBrienFamilyNotes.pdf) of 8
2024-12-19 02:58:11 - INFO - Starting clean_files_chain
2024-12-19 02:58:11 - INFO - Document: page_content='Individual Report for Joseph Albert Obrien*
Sex:
Annie O'Brien
Mother:
John O'Brien
Father:
Male
Joseph Albert Obrien*1-10
Individual Summary:
Individual Facts:
Birth:
20 Jan 1875 in New York1-4, 6-8, 10
Residence:
1880 in New York City, New York, New York; Age: 5Marital Status: Single;
Relation to Head of House: Son5
Residence:
1900 in Manhattan, New York, New York; Age: 23Marital Status: Single;
Relation to Head of House: Son4
Residence:
1905 in Manhattan, New York, New York; Relation to Head of House:
Head10
Residence:
1910 in Bronx Assembly District 32, New York, New York, USA; Age:
34Marital Status: Married; Relation to Head of House: Head1
Residence:
01 Jun 1915 in New York, Bronx, New York, United States8
Residence:
1917 in Bronx, Bronx, New York7
Residence:
1920 in Bronx Assembly District 3, Bronx, New York, USA; Age: 44Marital
Status: Married; Relation to Head of House: Head2
Residence:
01 Jun 1925 in New York, Bronx, New York; Age: 50Relation to Head of
House: Head3
Residence:
1930 in Bronx, Bronx, New York; Age: 53Marital Status: Married; Relation to
Head of House: Head6
Death:
Bef. 1940 in Bronx, New York; Wife was a widow in the 1940 Census.
Shared Facts:
Mary T Flanagan*
Marriage:
17 Dec 1901 in Manhattan, New York; Based on information from 1910
Census
Children:
Edna Mary O'Brien
Joseph A O'Brien*
William Francis O'Brien
Raymond O'Brien V
John Edward Obrien
Edwin Obrien
Eileen R O'Brien
Notes:
Person Notes:
[no notes]
Sources:
1 Ancestry.com, 1910 United States Federal Census (Online publication - Provo, UT, USA:
Ancestry.com Operations Inc, 2006.Original data - Thirteenth Census of the United States,
1910 (NARA microfilm publication T624, 1,178 rolls). Records of the Bureau of the Census,
Record Group 29. National Archives, Was), Ancestry.com, http://www.Ancestry.com, Year:
1910; Census Place: Bronx Assembly District 32, New York, New York; Roll: T624_997;
Page: 1A; Enumeration District: 1451; FHL microfilm: 1375010.
2 Ancestry.com, 1920 United States Federal Census (Online publication - Provo, UT, USA:
Ancestry.com Operations Inc, 2010. Images reproduced by FamilySearch.Original data -
Fourteenth Census of the United States, 1920. (NARA microfilm publication T625, 2076
rolls). Records of the Bureau of the Census, Reco), iOS Application, http://www.iOS
Application, Year: 1920; Census Place: Bronx Assembly District 3, Bronx, New York.
3 Ancestry.com, New York, State Census, 1925 (Ancestry.com Operations, Inc.),
Ancestry.com, http://www.Ancestry.com, New York State Archives; Albany, New York; State
Population Census Schedules, 1925; Election District: 03; Assembly District: 06; City: New
York; County: Bronx; Page: 16.
' metadata={'source': '/tmp/tmpv68pbahk', 'file_path': '/tmp/tmpv68pbahk', 'page': 3, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}
2024-12-19 02:58:11 - INFO - Invoking chain
2024-12-19 02:58:22 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 02:58:22 - INFO - Response: {'cleaned_content': "Individual Report for Joseph Albert O'Brien\n\nSex: Male\nMother: Annie O'Brien\nFather: John O'Brien\n\nIndividual Summary:\n\nIndividual Facts:\n- Birth: 20 Jan 1875 in New York\n- Residence: 1880 in New York City, New York; Age: 5; Marital Status: Single; Relation to Head of House: Son\n- Residence: 1900 in Manhattan, New York; Age: 23; Marital Status: Single; Relation to Head of House: Son\n- Residence: 1905 in Manhattan, New York; Relation to Head of House: Head\n- Residence: 1910 in Bronx Assembly District 32, New York; Age: 34; Marital Status: Married; Relation to Head of House: Head\n- Residence: 01 Jun 1915 in Bronx, New York, USA\n- Residence: 1917 in Bronx, New York\n- Residence: 1920 in Bronx Assembly District 3, New York; Age: 44; Marital Status: Married; Relation to Head of House: Head\n- Residence: 01 Jun 1925 in Bronx, New York; Age: 50; Relation to Head of House: Head\n- Residence: 1930 in Bronx, New York; Age: 53; Marital Status: Married; Relation to Head of House: Head\n- Death: Before 1940 in Bronx, New York; Wife was a widow in the 1940 Census.\n\nShared Facts:\n- Marriage: 17 Dec 1901 in Manhattan, New York; Based on information from the 1910 Census\n- Children:\n  - Edna Mary O'Brien\n  - Joseph A O'Brien\n  - William Francis O'Brien\n  - Raymond O'Brien V\n  - John Edward O'Brien\n  - Edwin O'Brien\n  - Eileen R O'Brien\n\nNotes:\n- Person Notes: [no notes]\n\nSources:\n1. Ancestry.com, 1910 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2006. Original data - Thirteenth Census of the United States, 1910 (NARA microfilm publication T624, 1,178 rolls). Records of the Bureau of the Census, Record Group 29. National Archives, Washington, D.C.), Ancestry.com. Year: 1910; Census Place: Bronx Assembly District 32, New York; Roll: T624_997; Page: 1A; Enumeration District: 1451; FHL microfilm: 1375010.\n2. Ancestry.com, 1920 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2010. Images reproduced by FamilySearch. Original data - Fourteenth Census of the United States, 1920. (NARA microfilm publication T625, 2076 rolls). Records of the Bureau of the Census), iOS Application, http://www.iOSApplication. Year: 1920; Census Place: Bronx Assembly District 3, Bronx, New York.\n3. Ancestry.com, New York, State Census, 1925 (Ancestry.com Operations, Inc.), Ancestry.com, http://www.Ancestry.com, New York State Archives; Albany, New York; State Population Census Schedules, 1925; Election District: 03; Assembly District: 06; City: New York; County: Bronx; Page: 16."}
2024-12-19 02:58:22 - INFO - Finished clean_files_chain
2024-12-19 02:58:22 - INFO - Successfully cleaned document 4 from OBrienFamilyNotes.pdf
2024-12-19 02:58:22 - INFO - Document 5 (OBrienFamilyNotes.pdf) of 8
2024-12-19 02:58:22 - INFO - Starting clean_files_chain
2024-12-19 02:58:22 - INFO - Document: page_content='Sources:
4 Ancestry.com, 1900 United States Federal Census (Online publication - Provo, UT, USA:
Ancestry.com Operations Inc, 2004.Original data - United States of America, Bureau of the
Census. Twelfth Census of the United States, 1900. Washington, D.C.: National Archives and
Records Administration, 1900. T623, 18), Ancestry.com, http://www.Ancestry.com, Year:
1900; Census Place: Manhattan, New York, New York; Roll: 1123; Page: 9B; Enumeration
District: 0933; FHL microfilm: 1241123.
5 Ancestry.com and The Church of Jesus Christ of Latter-day Saints, 1880 United States
Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2010.
1880 U.S. Census Index provided by The Church of Jesus Christ of Latter-day Saints ©
Copyright 1999 Intellectual Reserve, Inc. All rights reserved. All use is subject to the limited
), Ancestry.com, http://www.Ancestry.com, Year: 1880; Census Place: New York City, New
York, New York; Roll: 898; Family History Film: 1254898; Page: 513D; Enumeration District:
636; Image: 0387.
6 Ancestry.com, 1930 United States Federal Census (Online publication - Provo, UT, USA:
Ancestry.com Operations Inc, 2002.Original data - United States of America, Bureau of the
Census. Fifteenth Census of the United States, 1930. Washington, D.C.: National Archives
and Records Administration, 1930. T626.), Ancestry.com, http://www.Ancestry.com, Year:
1930; Census Place: Bronx, Bronx, New York; Roll: 1470; Page: 16B; Enumeration District:
220; Image: 179.0; FHL microfilm: 2341205.
7 U.S., World War I Draft Registration Cards, 1917-1918 (Ancestry.com. U.S., World War I
Draft Registration Cards, 1917-1918 [database on-line]. Provo, UT, USA: Ancestry.com
Operations Inc, 2005.), Ancestry.com, http://www.Ancestry.com, Registration State: New
York; Registration County: Bronx; Roll: 1753937; Draft Board: 4.
8 Ancestry.com, New York, State Census, 1915 (Online publication - Provo, UT, USA:
Ancestry.com Operations, Inc., 2012.Original data - State population census schedules,
1915. Albany, New York: New York State Archives.Original data: State population census
schedules, 1915. Albany, New York: New York S), Ancestry.com, http://www.Ancestry.com,
Source Citation: New York State Archives; Albany, New York; State Population Census
Schedules, 1915; Election District: 30; Assembly District: 32; City: New York; County: Bronx;
Page: 96. Name: Joseph Albert Obrien birth date: 20 Jan 1875 birth place: New York
residence date: 1 June 1915 residence place: New York, Bronx, New York, United States.
9 Ancestry.com, New York, New York, Marriage Indexes 1866-1937 (Ancestry.com Operations,
Inc.), Ancestry.com, http://www.Ancestry.com.
10 Ancestry.com, New York, State Census, 1905 (Ancestry.com Operations, Inc.),
Ancestry.com, http://www.Ancestry.com, New York State Archives; Albany, New York; State
Population Census Schedules, 1905; Election District: A.D. 33 E.D. 18; City: Manhattan;
County: New York; Page: 57.
' metadata={'source': '/tmp/tmpv68pbahk', 'file_path': '/tmp/tmpv68pbahk', 'page': 4, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}
2024-12-19 02:58:22 - INFO - Invoking chain
2024-12-19 02:58:35 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 02:58:35 - INFO - Response: {'cleaned_content': 'Sources:\n\n1. Ancestry.com, 1900 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2004. Original data - United States of America, Bureau of the Census. Twelfth Census of the United States, 1900. Washington, D.C.: National Archives and Records Administration, 1900. T623, 18). Ancestry.com, http://www.Ancestry.com, Year: 1900; Census Place: Manhattan, New York, New York; Roll: 1123; Page: 9B; Enumeration District: 0933; FHL microfilm: 1241123.\n\n2. Ancestry.com and The Church of Jesus Christ of Latter-day Saints, 1880 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2010. 1880 U.S. Census Index provided by The Church of Jesus Christ of Latter-day Saints © Copyright 1999 Intellectual Reserve, Inc. All rights reserved. All use is subject to the limited). Ancestry.com, http://www.Ancestry.com, Year: 1880; Census Place: New York City, New York, New York; Roll: 898; Family History Film: 1254898; Page: 513D; Enumeration District: 636; Image: 0387.\n\n3. Ancestry.com, 1930 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2002. Original data - United States of America, Bureau of the Census. Fifteenth Census of the United States, 1930. Washington, D.C.: National Archives and Records Administration, 1930. T626). Ancestry.com, http://www.Ancestry.com, Year: 1930; Census Place: Bronx, Bronx, New York; Roll: 1470; Page: 16B; Enumeration District: 220; Image: 179.0; FHL microfilm: 2341205.\n\n4. U.S., World War I Draft Registration Cards, 1917-1918 (Ancestry.com. U.S., World War I Draft Registration Cards, 1917-1918 [database on-line]. Provo, UT, USA: Ancestry.com Operations Inc, 2005). Ancestry.com, http://www.Ancestry.com, Registration State: New York; Registration County: Bronx; Roll: 1753937; Draft Board: 4.\n\n5. Ancestry.com, New York, State Census, 1915 (Online publication - Provo, UT, USA: Ancestry.com Operations, Inc., 2012. Original data - State population census schedules, 1915. Albany, New York: New York State Archives. Original data: State population census schedules, 1915. Albany, New York: New York State Archives). Ancestry.com, http://www.Ancestry.com, Source Citation: New York State Archives; Albany, New York; State Population Census Schedules, 1915; Election District: 30; Assembly District: 32; City: New York; County: Bronx; Page: 96. Name: Joseph Albert Obrien, birth date: 20 Jan 1875, birth place: New York, residence date: 1 June 1915, residence place: New York, Bronx, New York, United States.\n\n6. Ancestry.com, New York, New York, Marriage Indexes 1866-1937 (Ancestry.com Operations, Inc.). Ancestry.com, http://www.Ancestry.com.\n\n7. Ancestry.com, New York, State Census, 1905 (Ancestry.com Operations, Inc.). Ancestry.com, http://www.Ancestry.com, New York State Archives; Albany, New York; State Population Census Schedules, 1905; Election District: A.D. 33 E.D. 18; City: Manhattan; County: New York; Page: 57.'}
2024-12-19 02:58:35 - INFO - Finished clean_files_chain
2024-12-19 02:58:35 - INFO - Successfully cleaned document 5 from OBrienFamilyNotes.pdf
2024-12-19 02:58:35 - INFO - Document 6 (OBrienFamilyNotes.pdf) of 8
2024-12-19 02:58:35 - INFO - Starting clean_files_chain
2024-12-19 02:58:35 - INFO - Document: page_content='Family View Report for Joseph Albert Obrien*
John O'Brien
1848 -
Joseph Albert Obrien*
1875 - 1940
James Coffey
? O'Brien
Annie O'Brien
1855 -
Mary T Flanagan*
Abt. 1879
New York
07 Jan 1952
Bronx, New York
Born:
Died:
Marriage:
17 Dec 1901 in Manhattan, New York; Based on information from 1910 Census
Joseph Albert Obrien*
20 Jan 1875
New York
Bef. 1940
Bronx, New York
Born:
Died:
Death
Children:
Sex Birth
F
Edna Mary O'Brien
21 Mar 1902
Manhattan, New York
M
Joseph A O'Brien*
20 Nov 1945
Bronx, New York
Abt. 1905
New York
M
William Francis O'Brien
17 Aug 1995
Cranbury, Middlesex, New Jersey
20 May 1906
Bronx, New York
M
Raymond O'Brien V
Abt. 1908
New York
M
John Edward Obrien
Abt. 1910
New York
M
Edwin Obrien
Abt. 1914
New York
F
Eileen R O'Brien
05 Jan 2013
New York
23 Nov 1919
New York
' metadata={'source': '/tmp/tmpv68pbahk', 'file_path': '/tmp/tmpv68pbahk', 'page': 5, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}
2024-12-19 02:58:35 - INFO - Invoking chain
2024-12-19 02:58:40 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 02:58:40 - INFO - Response: {'cleaned_content': "Family View Report for Joseph Albert O'Brien\n\nJohn O'Brien\n1848 - \n\nJoseph Albert O'Brien\n1875 - 1940\n\nJames Coffey\n? O'Brien\n\nAnnie O'Brien\n1855 - \n\nMary T. Flanagan\nAbout 1879\n\nNew York\n\nDate of Birth: 20 January 1875, New York\nDate of Death: Before 1940, Bronx, New York\nMarriage: 17 December 1901 in Manhattan, New York (Based on information from the 1910 Census)\n\nChildren:\n\n1. Edna Mary O'Brien\n   - Birth: 21 March 1902, Manhattan, New York\n   - Sex: Female\n\n2. Joseph A. O'Brien\n   - Birth: About 1905, New York\n   - Death: 20 November 1945, Bronx, New York\n   - Sex: Male\n\n3. William Francis O'Brien\n   - Birth: 20 May 1906, Bronx, New York\n   - Death: 17 August 1995, Cranbury, Middlesex, New Jersey\n   - Sex: Male\n\n4. Raymond O'Brien V\n   - Birth: About 1908, New York\n   - Sex: Male\n\n5. John Edward O'Brien\n   - Birth: About 1910, New York\n   - Sex: Male\n\n6. Edwin O'Brien\n   - Birth: About 1914, New York\n   - Sex: Male\n\n7. Eileen R. O'Brien\n   - Birth: 23 November 1919, New York\n   - Death: 5 January 2013, New York\n   - Sex: Female"}
2024-12-19 02:58:40 - INFO - Finished clean_files_chain
2024-12-19 02:58:40 - INFO - Successfully cleaned document 6 from OBrienFamilyNotes.pdf
2024-12-19 02:58:40 - INFO - Document 7 (OBrienFamilyNotes.pdf) of 8
2024-12-19 02:58:40 - INFO - Starting clean_files_chain
2024-12-19 02:58:40 - INFO - Document: page_content='Individual Report for John O'Brien
Sex:
Mother:
Father:
Male
John O'Brien1
Individual Summary:
Individual Facts:
Birth:
Abt. 1848 in New York1
Residence:
1880 in New York City, New York, New York; Age: 32Marital Status:
Married; Relation to Head of House: Self; Occupation: Plumber1
Shared Facts:
Annie O'Brien
[no facts]
Children:
Joseph Albert Obrien*
Mary R O'Brien
John A O'Brien
Helen Bridget O'Brien
Annie O'Brien
William F O'Brien
Gertrude O'Brien
Notes:
Person Notes:
[no notes]
Sources:
1 Ancestry.com and The Church of Jesus Christ of Latter-day Saints, 1880 United States
Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2010.
1880 U.S. Census Index provided by The Church of Jesus Christ of Latter-day Saints ©
Copyright 1999 Intellectual Reserve, Inc. All rights reserved. All use is subject to the limited
), Ancestry.com, http://www.Ancestry.com, Year: 1880; Census Place: New York City, New
York, New York; Roll: 898; Family History Film: 1254898; Page: 513D; Enumeration District:
636; Image: 0387.
' metadata={'source': '/tmp/tmpv68pbahk', 'file_path': '/tmp/tmpv68pbahk', 'page': 6, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}
2024-12-19 02:58:40 - INFO - Invoking chain
2024-12-19 02:58:45 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 02:58:45 - INFO - Response: {'cleaned_content': "Individual Report for John O'Brien\n\nSex: Male\n\nMother: [no facts]\nFather: John O'Brien\n\nIndividual Summary:\n\nIndividual Facts:\n- Birth: Approximately 1848 in New York\n- Residence: In 1880, New York City, New York, Age: 32\n- Marital Status: Married\n- Relation to Head of House: Self\n- Occupation: Plumber\n\nShared Facts:\n- Annie O'Brien\n\nChildren:\n- Joseph Albert Obrien\n- Mary R O'Brien\n- John A O'Brien\n- Helen Bridget O'Brien\n- Annie O'Brien\n- William F O'Brien\n- Gertrude O'Brien\n\nNotes:\n- Person Notes: [no notes]\n\nSources:\n1. Ancestry.com and The Church of Jesus Christ of Latter-day Saints, 1880 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2010). 1880 U.S. Census Index provided by The Church of Jesus Christ of Latter-day Saints © Copyright 1999 Intellectual Reserve, Inc. All rights reserved. All use is subject to the limited rights. Ancestry.com, http://www.Ancestry.com, Year: 1880; Census Place: New York City, New York; Roll: 898; Family History Film: 1254898; Page: 513D; Enumeration District: 636; Image: 0387."}
2024-12-19 02:58:45 - INFO - Finished clean_files_chain
2024-12-19 02:58:45 - INFO - Successfully cleaned document 7 from OBrienFamilyNotes.pdf
2024-12-19 02:58:45 - INFO - Document 8 (OBrienFamilyNotes.pdf) of 8
2024-12-19 02:58:45 - INFO - Starting clean_files_chain
2024-12-19 02:58:45 - INFO - Document: page_content='' metadata={'source': '/tmp/tmpv68pbahk', 'file_path': '/tmp/tmpv68pbahk', 'page': 7, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}
2024-12-19 02:58:45 - INFO - Invoking chain
2024-12-19 02:58:46 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 02:58:46 - INFO - Response: {'cleaned_content': ''}
2024-12-19 02:58:46 - INFO - Finished clean_files_chain
2024-12-19 02:58:46 - INFO - Successfully cleaned document 8 from OBrienFamilyNotes.pdf
2024-12-19 02:58:46 - INFO - Pages: []
2024-12-19 02:58:46 - INFO - Full response: Page 1

Joseph Albert O'Brien
- Born: 24 Apr 1932 in Bronx, New York
- Married: 07 Oct 1956
- Died: 07 Jan 2011 in Annapolis, Anne Arundel, Maryland

Joseph A O'Brien
- Born: Approximately 1905 in New York
- Married: 02 Aug 1931 in Bronx, New York; St. Anselm's Church - 68 Tinton Ave
- Died: 20 Nov 1945 in Bronx, New York

Genevieve Godziemski
- Born: 01 Nov 1911 in New York
- Died: 23 Jul 1989 in Hollywood, Broward, Florida; Age at Death: 77

Joseph Albert O'Brien
- Born: 20 Jan 1875 in New York
- Married: 17 Dec 1901 in Manhattan, New York; Based on information from 1910 Census
- Died: Before 1940 in Bronx, New York; Wife was a widow in the 1940 Census.

Mary T Flanagan
- Born: Approximately 1879 in New York
- Died: 07 Jan 1952 in Bronx, New York

Walter (Wladislaw) Godziemski (Godzembsky)
- Born: 05 Mar 1877 in Poland
- Married: 02 Sep 1906 in New York
- Died: 19 Aug 1943 in Richmond, New York

Mariana (Mary) Zwalina
- Born: 15 Mar 1878 in Kolna, Podlaskie, Poland
- Died: 02 Oct 1960 in Bronx, New York

Pedigree Chart for Joseph Albert O'BrienJoseph Albert O'Brien
Born: 20 January 1875 in New York
Married: 17 December 1901 in Manhattan, New York
Based on information from the 1910 Census
Died: Before 1940 in Bronx, New York; Wife was a widow in the 1940 Census.

John O'Brien
Born: Approximately 1848 in New York
Married: 
Died: 

Annie O'Brien
Born: June 1855 in New York
Died: Page 3

Mary T. Flanagan
Born: Approximately 1879 in New York
Married: 17 December 1901 in Manhattan, New York; Based on information from the 1910 Census
Died: 07 January 1952 in Bronx, New York

Peter Flanagan
Born: 
Married: 
Died: 

Ellen Flanagan
Born: Scotland
Died: 1Individual Report for Joseph Albert O'Brien

Sex: Male
Mother: Annie O'Brien
Father: John O'Brien

Individual Summary:

Individual Facts:
- Birth: 20 Jan 1875 in New York
- Residence: 1880 in New York City, New York; Age: 5; Marital Status: Single; Relation to Head of House: Son
- Residence: 1900 in Manhattan, New York; Age: 23; Marital Status: Single; Relation to Head of House: Son
- Residence: 1905 in Manhattan, New York; Relation to Head of House: Head
- Residence: 1910 in Bronx Assembly District 32, New York; Age: 34; Marital Status: Married; Relation to Head of House: Head
- Residence: 01 Jun 1915 in Bronx, New York, USA
- Residence: 1917 in Bronx, New York
- Residence: 1920 in Bronx Assembly District 3, New York; Age: 44; Marital Status: Married; Relation to Head of House: Head
- Residence: 01 Jun 1925 in Bronx, New York; Age: 50; Relation to Head of House: Head
- Residence: 1930 in Bronx, New York; Age: 53; Marital Status: Married; Relation to Head of House: Head
- Death: Before 1940 in Bronx, New York; Wife was a widow in the 1940 Census.

Shared Facts:
- Marriage: 17 Dec 1901 in Manhattan, New York; Based on information from the 1910 Census
- Children:
  - Edna Mary O'Brien
  - Joseph A O'Brien
  - William Francis O'Brien
  - Raymond O'Brien V
  - John Edward O'Brien
  - Edwin O'Brien
  - Eileen R O'Brien

Notes:
- Person Notes: [no notes]

Sources:
1. Ancestry.com, 1910 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2006. Original data - Thirteenth Census of the United States, 1910 (NARA microfilm publication T624, 1,178 rolls). Records of the Bureau of the Census, Record Group 29. National Archives, Washington, D.C.), Ancestry.com. Year: 1910; Census Place: Bronx Assembly District 32, New York; Roll: T624_997; Page: 1A; Enumeration District: 1451; FHL microfilm: 1375010.
2. Ancestry.com, 1920 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2010. Images reproduced by FamilySearch. Original data - Fourteenth Census of the United States, 1920. (NARA microfilm publication T625, 2076 rolls). Records of the Bureau of the Census), iOS Application, http://www.iOSApplication. Year: 1920; Census Place: Bronx Assembly District 3, Bronx, New York.
3. Ancestry.com, New York, State Census, 1925 (Ancestry.com Operations, Inc.), Ancestry.com, http://www.Ancestry.com, New York State Archives; Albany, New York; State Population Census Schedules, 1925; Election District: 03; Assembly District: 06; City: New York; County: Bronx; Page: 16.Sources:

1. Ancestry.com, 1900 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2004. Original data - United States of America, Bureau of the Census. Twelfth Census of the United States, 1900. Washington, D.C.: National Archives and Records Administration, 1900. T623, 18). Ancestry.com, http://www.Ancestry.com, Year: 1900; Census Place: Manhattan, New York, New York; Roll: 1123; Page: 9B; Enumeration District: 0933; FHL microfilm: 1241123.

2. Ancestry.com and The Church of Jesus Christ of Latter-day Saints, 1880 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2010. 1880 U.S. Census Index provided by The Church of Jesus Christ of Latter-day Saints © Copyright 1999 Intellectual Reserve, Inc. All rights reserved. All use is subject to the limited). Ancestry.com, http://www.Ancestry.com, Year: 1880; Census Place: New York City, New York, New York; Roll: 898; Family History Film: 1254898; Page: 513D; Enumeration District: 636; Image: 0387.

3. Ancestry.com, 1930 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2002. Original data - United States of America, Bureau of the Census. Fifteenth Census of the United States, 1930. Washington, D.C.: National Archives and Records Administration, 1930. T626). Ancestry.com, http://www.Ancestry.com, Year: 1930; Census Place: Bronx, Bronx, New York; Roll: 1470; Page: 16B; Enumeration District: 220; Image: 179.0; FHL microfilm: 2341205.

4. U.S., World War I Draft Registration Cards, 1917-1918 (Ancestry.com. U.S., World War I Draft Registration Cards, 1917-1918 [database on-line]. Provo, UT, USA: Ancestry.com Operations Inc, 2005). Ancestry.com, http://www.Ancestry.com, Registration State: New York; Registration County: Bronx; Roll: 1753937; Draft Board: 4.

5. Ancestry.com, New York, State Census, 1915 (Online publication - Provo, UT, USA: Ancestry.com Operations, Inc., 2012. Original data - State population census schedules, 1915. Albany, New York: New York State Archives. Original data: State population census schedules, 1915. Albany, New York: New York State Archives). Ancestry.com, http://www.Ancestry.com, Source Citation: New York State Archives; Albany, New York; State Population Census Schedules, 1915; Election District: 30; Assembly District: 32; City: New York; County: Bronx; Page: 96. Name: Joseph Albert Obrien, birth date: 20 Jan 1875, birth place: New York, residence date: 1 June 1915, residence place: New York, Bronx, New York, United States.

6. Ancestry.com, New York, New York, Marriage Indexes 1866-1937 (Ancestry.com Operations, Inc.). Ancestry.com, http://www.Ancestry.com.

7. Ancestry.com, New York, State Census, 1905 (Ancestry.com Operations, Inc.). Ancestry.com, http://www.Ancestry.com, New York State Archives; Albany, New York; State Population Census Schedules, 1905; Election District: A.D. 33 E.D. 18; City: Manhattan; County: New York; Page: 57.Family View Report for Joseph Albert O'Brien

John O'Brien
1848 - 

Joseph Albert O'Brien
1875 - 1940

James Coffey
? O'Brien

Annie O'Brien
1855 - 

Mary T. Flanagan
About 1879

New York

Date of Birth: 20 January 1875, New York
Date of Death: Before 1940, Bronx, New York
Marriage: 17 December 1901 in Manhattan, New York (Based on information from the 1910 Census)

Children:

1. Edna Mary O'Brien
   - Birth: 21 March 1902, Manhattan, New York
   - Sex: Female

2. Joseph A. O'Brien
   - Birth: About 1905, New York
   - Death: 20 November 1945, Bronx, New York
   - Sex: Male

3. William Francis O'Brien
   - Birth: 20 May 1906, Bronx, New York
   - Death: 17 August 1995, Cranbury, Middlesex, New Jersey
   - Sex: Male

4. Raymond O'Brien V
   - Birth: About 1908, New York
   - Sex: Male

5. John Edward O'Brien
   - Birth: About 1910, New York
   - Sex: Male

6. Edwin O'Brien
   - Birth: About 1914, New York
   - Sex: Male

7. Eileen R. O'Brien
   - Birth: 23 November 1919, New York
   - Death: 5 January 2013, New York
   - Sex: FemaleIndividual Report for John O'Brien

Sex: Male

Mother: [no facts]
Father: John O'Brien

Individual Summary:

Individual Facts:
- Birth: Approximately 1848 in New York
- Residence: In 1880, New York City, New York, Age: 32
- Marital Status: Married
- Relation to Head of House: Self
- Occupation: Plumber

Shared Facts:
- Annie O'Brien

Children:
- Joseph Albert Obrien
- Mary R O'Brien
- John A O'Brien
- Helen Bridget O'Brien
- Annie O'Brien
- William F O'Brien
- Gertrude O'Brien

Notes:
- Person Notes: [no notes]

Sources:
1. Ancestry.com and The Church of Jesus Christ of Latter-day Saints, 1880 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2010). 1880 U.S. Census Index provided by The Church of Jesus Christ of Latter-day Saints © Copyright 1999 Intellectual Reserve, Inc. All rights reserved. All use is subject to the limited rights. Ancestry.com, http://www.Ancestry.com, Year: 1880; Census Place: New York City, New York; Roll: 898; Family History Film: 1254898; Page: 513D; Enumeration District: 636; Image: 0387.
2024-12-19 02:58:46 - INFO - Processing pages: 0, full_response: Yes
2024-12-19 02:58:46 - INFO - Created 1 tasks for question generation
2024-12-19 02:58:46 - INFO - Starting question_generate_chain
2024-12-19 02:58:46 - INFO - Setting up question generation chain
2024-12-19 02:58:46 - INFO - Chain type: <class 'langchain_core.runnables.base.RunnableSequence'>
2024-12-19 02:58:46 - INFO - Question generation chain setup complete
2024-12-19 02:58:54 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 02:58:54 - INFO - Generated 5 questions for A with the following questions: [QAPair(question="What is the birth date of Joseph Albert O'Brien?", answer='20 January 1875', q_type='multiple_choice', choices=['24 April 1932', '20 January 1875', '01 November 1911', '05 March 1877']), QAPair(question='Who was married on 02 August 1931 in Bronx, New York?', answer="Joseph A O'Brien", q_type='multiple_choice', choices=['Walter Godziemski', "Joseph A O'Brien", "John O'Brien", "William Francis O'Brien"]), QAPair(question='Mary T. Flanagan died on 07 January 1952.', answer='True', q_type='TF', choices=['True', 'False']), QAPair(question="Joseph Albert O'Brien was married to Mary T. Flanagan.", answer='False', q_type='TF', choices=['True', 'False']), QAPair(question="List the names of Joseph Albert O'Brien's children.", answer="Edna Mary O'Brien, Joseph A O'Brien, William Francis O'Brien, Raymond O'Brien V, John Edward O'Brien, Edwin O'Brien, Eileen R O'Brien.", q_type='written', choices=[])]
2024-12-19 02:58:54 - INFO - Finished question_generate_chain
2024-12-19 02:58:54 - INFO - Completed question generation. Number of results: 1
2024-12-19 02:58:54 - INFO - Generated test list with 1 tests
2024-12-19 02:58:54 - INFO - Preparing judge_kwargs with 9 parameters
2024-12-19 02:58:54 - INFO - FINAL TEST:
{
    "questions": [
        {
            "question": "What is the birth date of Joseph Albert O'Brien?",
            "answer": "20 January 1875",
            "q_type": "multiple_choice",
            "choices": [
                "24 April 1932",
                "20 January 1875",
                "01 November 1911",
                "05 March 1877"
            ]
        },
        {
            "question": "Who was married on 02 August 1931 in Bronx, New York?",
            "answer": "Joseph A O'Brien",
            "q_type": "multiple_choice",
            "choices": [
                "Walter Godziemski",
                "Joseph A O'Brien",
                "John O'Brien",
                "William Francis O'Brien"
            ]
        },
        {
            "question": "Mary T. Flanagan died on 07 January 1952.",
            "answer": "True",
            "q_type": "TF",
            "choices": [
                "True",
                "False"
            ]
        },
        {
            "question": "Joseph Albert O'Brien was married to Mary T. Flanagan.",
            "answer": "False",
            "q_type": "TF",
            "choices": [
                "True",
                "False"
            ]
        },
        {
            "question": "List the names of Joseph Albert O'Brien's children.",
            "answer": "Edna Mary O'Brien, Joseph A O'Brien, William Francis O'Brien, Raymond O'Brien V, John Edward O'Brien, Edwin O'Brien, Eileen R O'Brien.",
            "q_type": "written",
            "choices": []
        }
    ]
}
2024-12-19 02:58:54 - INFO - All tasks completed. Number of results: 1
2024-12-19 02:58:54 - INFO - Generated 1 tests
2024-12-19 02:58:54 - INFO - Cleaning up temp files
2024-12-19 02:58:54 - INFO - Deleted temp file: /tmp/tmpv68pbahk
2024-12-19 02:58:54 - INFO - Temp files cleaned
2024-12-19 02:58:54 - INFO - Run function completed
2024-12-19 02:58:54 - INFO - Test generated successfully
2024-12-19 03:00:08 - INFO - GET request received for index page
2024-12-19 03:04:49 - INFO - POST request received for /generate
2024-12-19 03:04:49 - INFO - Form data: title='A' course='C' professor='D' number_of_written_questions=0 number_of_mcq_questions=6 number_of_TF_questions=0 level='Honors' school_type='Undergraduate' difficulty='hard selected' testing_philosophy='Re' url_1=None url_2=None subject_material=[UploadFile(filename='OBrienFamilyNotes.pdf', size=1043503, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="OBrienFamilyNotes.pdf"', 'content-type': 'application/pdf'}))]
2024-12-19 03:04:49 - INFO - Starting run function
2024-12-19 03:04:49 - INFO - Form data accessed
2024-12-19 03:04:49 - INFO - Form Title: A
2024-12-19 03:04:49 - INFO - Form Course: C
2024-12-19 03:04:49 - INFO - Form Professor: D
2024-12-19 03:04:49 - INFO - Form Number of MCQ Questions: 6
2024-12-19 03:04:49 - INFO - Form Number of TF Questions: 0
2024-12-19 03:04:49 - INFO - Form Number of Written Questions: 0
2024-12-19 03:04:49 - INFO - Form School Type: Undergraduate
2024-12-19 03:04:49 - INFO - Form Difficulty: hard selected
2024-12-19 03:04:49 - INFO - Form Testing Philosophy: Re
2024-12-19 03:04:49 - INFO - Moving to files...
2024-12-19 03:04:49 - INFO - Starting to process files
2024-12-19 03:04:49 - INFO - Processing file: OBrienFamilyNotes.pdf
2024-12-19 03:04:49 - INFO - Getting loader for file: UploadFile(filename='OBrienFamilyNotes.pdf', size=1043503, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="OBrienFamilyNotes.pdf"', 'content-type': 'application/pdf'}))
2024-12-19 03:04:49 - INFO - File extension: .pdf
2024-12-19 03:04:49 - INFO - Processing PDF file: OBrienFamilyNotes.pdf
2024-12-19 03:04:49 - INFO - Using loader type: PyMuPDFLoader for UploadFile(filename='OBrienFamilyNotes.pdf', size=1043503, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="OBrienFamilyNotes.pdf"', 'content-type': 'application/pdf'}))
2024-12-19 03:04:49 - INFO - URLs: []
2024-12-19 03:04:49 - INFO - Processing 1 files and 0 URLs
2024-12-19 03:04:49 - INFO - Processing OBrienFamilyNotes.pdf
2024-12-19 03:04:49 - INFO - Using loader type: PyMuPDFLoader for OBrienFamilyNotes.pdf
2024-12-19 03:04:49 - INFO - Processing OBrienFamilyNotes.pdf as a regular document using PyMuPDFLoader
2024-12-19 03:04:49 - INFO - Successfully loaded 8 documents from: OBrienFamilyNotes.pdf
2024-12-19 03:04:49 - INFO - Docs: [Document(metadata={'source': '/tmp/tmp5j809av7', 'file_path': '/tmp/tmp5j809av7', 'page': 0, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}, page_content="Page 1\nJoseph Albert O'Brien*\nb:\n24 Apr 1932 in Bronx,  \nBronx, New York\nm: 07 Oct 1956\nd:\n07 Jan 2011 in  \nAnnapolis, Anne  \nArundel, Maryland\nJoseph A O'Brien*\nb:\nAbt. 1905 in New  \nYork\nm: 02 Aug 1931 in  \nBronx, New York; St.  \nAnselm's Church - 68  \nTinton Ave\nd:\n20 Nov 1945 in  \nBronx, New York\nGenevieve Godziemski*\nb:\n01 Nov 1911 in New  \nYork\nd:\n23 Jul 1989 in  \nHollywood, Broward,  \nFlorida; Age at Death:  \n77\nJoseph Albert Obrien*\nb:\n20 Jan 1875 in New  \nYork\nm: 17 Dec 1901 in  \nManhattan, New York;  \nBased on information  \nfrom 1910 Census\nd:\nBef. 1940 in Bronx,  \nNew York; Wife was a  \nwidow in the 1940  \nCensus.\nMary T Flanagan*\nb:\nAbt. 1879 in New  \nYork\nd:\n07 Jan 1952 in  \nBronx, New York\nWalter (Wladislaw) \nGodziemski \n(Godzembsky)\nb:\n05 Mar 1877 in  \nPoland\nm: 02 Sep 1906 in New  \nYork\nd:\n19 Aug 1943 in  \nRichmond, New York\nMariana (Mary) Zwalina*\nb:\n15 Mar 1878 in  \nKolna, Podlaskie,  \nPoland\nd:\n02 Oct 1960 in \nBronx, New York\n3\n2\nPedigree Chart for  \nJoseph Albert O'Brien*\n"), Document(metadata={'source': '/tmp/tmp5j809av7', 'file_path': '/tmp/tmp5j809av7', 'page': 1, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}, page_content="Page 2\nJoseph Albert Obrien*\nb:\n20 Jan 1875 in New  \nYork\nm: 17 Dec 1901 in  \nManhattan, New York;  \nBased on information  \nfrom 1910 Census\nd:\nBef. 1940 in Bronx,  \nNew York; Wife was a  \nwidow in the 1940  \nCensus.\nJohn O'Brien\nb:\nAbt. 1848 in New  \nYork\nm:\nd:\nAnnie O'Brien\nb:\nJun 1855 in New  \nYork\nd:\n1\n"), Document(metadata={'source': '/tmp/tmp5j809av7', 'file_path': '/tmp/tmp5j809av7', 'page': 2, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}, page_content='Page 3\nMary T Flanagan*\nb:\nAbt. 1879 in New  \nYork\nm: 17 Dec 1901 in  \nManhattan, New York;  \nBased on information  \nfrom 1910 Census\nd:\n07 Jan 1952 in  \nBronx, New York\nPeter Flanagan\nb:\nm:\nd:\nEllen Flanagan\nb:\nScotland\nd:\n1\n'), Document(metadata={'source': '/tmp/tmp5j809av7', 'file_path': '/tmp/tmp5j809av7', 'page': 3, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}, page_content="Individual Report for Joseph Albert Obrien*\nSex:\nAnnie O'Brien\nMother:\nJohn O'Brien\nFather:\nMale\nJoseph Albert Obrien*1-10\nIndividual Summary:\nIndividual Facts:\nBirth:\n20 Jan 1875 in New York1-4, 6-8, 10\nResidence:\n1880 in New York City, New York, New York; Age: 5Marital Status: Single;\nRelation to Head of House: Son5\nResidence:\n1900 in Manhattan, New York, New York; Age: 23Marital Status: Single;\nRelation to Head of House: Son4\nResidence:\n1905 in Manhattan, New York, New York; Relation to Head of House:\nHead10\nResidence:\n1910 in Bronx Assembly District 32, New York, New York, USA; Age:\n34Marital Status: Married; Relation to Head of House: Head1\nResidence:\n01 Jun 1915 in New York, Bronx, New York, United States8\nResidence:\n1917 in Bronx, Bronx, New York7\nResidence:\n1920 in Bronx Assembly District 3, Bronx, New York, USA; Age: 44Marital\nStatus: Married; Relation to Head of House: Head2\nResidence:\n01 Jun 1925 in New York, Bronx, New York; Age: 50Relation to Head of\nHouse: Head3\nResidence:\n1930 in Bronx, Bronx, New York; Age: 53Marital Status: Married; Relation to\nHead of House: Head6\nDeath:\nBef. 1940 in Bronx, New York; Wife was a widow in the 1940 Census.\nShared Facts:\nMary T Flanagan*\nMarriage:\n17 Dec 1901 in Manhattan, New York; Based on information from 1910\nCensus\nChildren:\nEdna Mary O'Brien\nJoseph A O'Brien*\nWilliam Francis O'Brien\nRaymond O'Brien V\nJohn Edward Obrien\nEdwin Obrien\nEileen R O'Brien\nNotes:\nPerson Notes:\n[no notes]\nSources:\n1 Ancestry.com, 1910 United States Federal Census (Online publication - Provo, UT, USA:\nAncestry.com Operations Inc, 2006.Original data - Thirteenth Census of the United States,\n1910 (NARA microfilm publication T624, 1,178 rolls). Records of the Bureau of the Census,\nRecord Group 29. National Archives, Was), Ancestry.com, http://www.Ancestry.com, Year:\n1910; Census Place: Bronx Assembly District 32, New York, New York; Roll: T624_997;\nPage: 1A; Enumeration District: 1451; FHL microfilm: 1375010.\n2 Ancestry.com, 1920 United States Federal Census (Online publication - Provo, UT, USA:\nAncestry.com Operations Inc, 2010. Images reproduced by FamilySearch.Original data -\nFourteenth Census of the United States, 1920. (NARA microfilm publication T625, 2076\nrolls). Records of the Bureau of the Census, Reco), iOS Application, http://www.iOS\nApplication, Year: 1920; Census Place: Bronx Assembly District 3, Bronx, New York.\n3 Ancestry.com, New York, State Census, 1925 (Ancestry.com Operations, Inc.),\nAncestry.com, http://www.Ancestry.com, New York State Archives; Albany, New York; State\nPopulation Census Schedules, 1925; Election District: 03; Assembly District: 06; City: New\nYork; County: Bronx; Page: 16.\n"), Document(metadata={'source': '/tmp/tmp5j809av7', 'file_path': '/tmp/tmp5j809av7', 'page': 4, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}, page_content='Sources:\n4 Ancestry.com, 1900 United States Federal Census (Online publication - Provo, UT, USA:\nAncestry.com Operations Inc, 2004.Original data - United States of America, Bureau of the\nCensus. Twelfth Census of the United States, 1900. Washington, D.C.: National Archives and\nRecords Administration, 1900. T623, 18), Ancestry.com, http://www.Ancestry.com, Year:\n1900; Census Place: Manhattan, New York, New York; Roll: 1123; Page: 9B; Enumeration\nDistrict: 0933; FHL microfilm: 1241123.\n5 Ancestry.com and The Church of Jesus Christ of Latter-day Saints, 1880 United States\nFederal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2010.\n1880 U.S. Census Index provided by The Church of Jesus Christ of Latter-day Saints ©\nCopyright 1999 Intellectual Reserve, Inc. All rights reserved. All use is subject to the limited\n), Ancestry.com, http://www.Ancestry.com, Year: 1880; Census Place: New York City, New\nYork, New York; Roll: 898; Family History Film: 1254898; Page: 513D; Enumeration District:\n636; Image: 0387.\n6 Ancestry.com, 1930 United States Federal Census (Online publication - Provo, UT, USA:\nAncestry.com Operations Inc, 2002.Original data - United States of America, Bureau of the\nCensus. Fifteenth Census of the United States, 1930. Washington, D.C.: National Archives\nand Records Administration, 1930. T626.), Ancestry.com, http://www.Ancestry.com, Year:\n1930; Census Place: Bronx, Bronx, New York; Roll: 1470; Page: 16B; Enumeration District:\n220; Image: 179.0; FHL microfilm: 2341205.\n7 U.S., World War I Draft Registration Cards, 1917-1918 (Ancestry.com. U.S., World War I\nDraft Registration Cards, 1917-1918 [database on-line]. Provo, UT, USA: Ancestry.com\nOperations Inc, 2005.), Ancestry.com, http://www.Ancestry.com, Registration State: New\nYork; Registration County: Bronx; Roll: 1753937; Draft Board: 4.\n8 Ancestry.com, New York, State Census, 1915 (Online publication - Provo, UT, USA:\nAncestry.com Operations, Inc., 2012.Original data - State population census schedules,\n1915. Albany, New York: New York State Archives.Original data: State population census\nschedules, 1915. Albany, New York: New York S), Ancestry.com, http://www.Ancestry.com,\nSource Citation: New York State Archives; Albany, New York; State Population Census\nSchedules, 1915; Election District: 30; Assembly District: 32; City: New York; County: Bronx;\nPage: 96. Name: Joseph Albert Obrien birth date: 20 Jan 1875 birth place: New York\nresidence date: 1 June 1915 residence place: New York, Bronx, New York, United States.\n9 Ancestry.com, New York, New York, Marriage Indexes 1866-1937 (Ancestry.com Operations,\nInc.), Ancestry.com, http://www.Ancestry.com.\n10 Ancestry.com, New York, State Census, 1905 (Ancestry.com Operations, Inc.),\nAncestry.com, http://www.Ancestry.com, New York State Archives; Albany, New York; State\nPopulation Census Schedules, 1905; Election District: A.D. 33 E.D. 18; City: Manhattan;\nCounty: New York; Page: 57.\n'), Document(metadata={'source': '/tmp/tmp5j809av7', 'file_path': '/tmp/tmp5j809av7', 'page': 5, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}, page_content="Family View Report for Joseph Albert Obrien*\nJohn O'Brien\n1848 -\nJoseph Albert Obrien*\n1875 - 1940\nJames Coffey\n? O'Brien\nAnnie O'Brien\n1855 -\nMary T Flanagan*\nAbt. 1879\nNew York\n07 Jan 1952\nBronx, New York\nBorn:\nDied:\nMarriage:\n17 Dec 1901 in Manhattan, New York; Based on information from 1910 Census\nJoseph Albert Obrien*\n20 Jan 1875\nNew York\nBef. 1940\nBronx, New York\nBorn:\nDied:\nDeath\nChildren:\nSex Birth\nF\nEdna Mary O'Brien\n21 Mar 1902\nManhattan, New York\nM\nJoseph A O'Brien*\n20 Nov 1945\nBronx, New York\nAbt. 1905\nNew York\nM\nWilliam Francis O'Brien\n17 Aug 1995\nCranbury, Middlesex, New Jersey\n20 May 1906\nBronx, New York\nM\nRaymond O'Brien V\nAbt. 1908\nNew York\nM\nJohn Edward Obrien\nAbt. 1910\nNew York\nM\nEdwin Obrien\nAbt. 1914\nNew York\nF\nEileen R O'Brien\n05 Jan 2013\nNew York\n23 Nov 1919\nNew York\n"), Document(metadata={'source': '/tmp/tmp5j809av7', 'file_path': '/tmp/tmp5j809av7', 'page': 6, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}, page_content="Individual Report for John O'Brien\nSex:\nMother:\nFather:\nMale\nJohn O'Brien1\nIndividual Summary:\nIndividual Facts:\nBirth:\nAbt. 1848 in New York1\nResidence:\n1880 in New York City, New York, New York; Age: 32Marital Status:\nMarried; Relation to Head of House: Self; Occupation: Plumber1\nShared Facts:\nAnnie O'Brien\n[no facts]\nChildren:\nJoseph Albert Obrien*\nMary R O'Brien\nJohn A O'Brien\nHelen Bridget O'Brien\nAnnie O'Brien\nWilliam F O'Brien\nGertrude O'Brien\nNotes:\nPerson Notes:\n[no notes]\nSources:\n1 Ancestry.com and The Church of Jesus Christ of Latter-day Saints, 1880 United States\nFederal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2010.\n1880 U.S. Census Index provided by The Church of Jesus Christ of Latter-day Saints ©\nCopyright 1999 Intellectual Reserve, Inc. All rights reserved. All use is subject to the limited\n), Ancestry.com, http://www.Ancestry.com, Year: 1880; Census Place: New York City, New\nYork, New York; Roll: 898; Family History Film: 1254898; Page: 513D; Enumeration District:\n636; Image: 0387.\n"), Document(metadata={'source': '/tmp/tmp5j809av7', 'file_path': '/tmp/tmp5j809av7', 'page': 7, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}, page_content='')] for OBrienFamilyNotes.pdf using PyMuPDFLoader
2024-12-19 03:04:49 - INFO - Document 1 (OBrienFamilyNotes.pdf) of 8
2024-12-19 03:04:49 - INFO - Starting clean_files_chain
2024-12-19 03:04:49 - INFO - Document: page_content='Page 1
Joseph Albert O'Brien*
b:
24 Apr 1932 in Bronx,  
Bronx, New York
m: 07 Oct 1956
d:
07 Jan 2011 in  
Annapolis, Anne  
Arundel, Maryland
Joseph A O'Brien*
b:
Abt. 1905 in New  
York
m: 02 Aug 1931 in  
Bronx, New York; St.  
Anselm's Church - 68  
Tinton Ave
d:
20 Nov 1945 in  
Bronx, New York
Genevieve Godziemski*
b:
01 Nov 1911 in New  
York
d:
23 Jul 1989 in  
Hollywood, Broward,  
Florida; Age at Death:  
77
Joseph Albert Obrien*
b:
20 Jan 1875 in New  
York
m: 17 Dec 1901 in  
Manhattan, New York;  
Based on information  
from 1910 Census
d:
Bef. 1940 in Bronx,  
New York; Wife was a  
widow in the 1940  
Census.
Mary T Flanagan*
b:
Abt. 1879 in New  
York
d:
07 Jan 1952 in  
Bronx, New York
Walter (Wladislaw) 
Godziemski 
(Godzembsky)
b:
05 Mar 1877 in  
Poland
m: 02 Sep 1906 in New  
York
d:
19 Aug 1943 in  
Richmond, New York
Mariana (Mary) Zwalina*
b:
15 Mar 1878 in  
Kolna, Podlaskie,  
Poland
d:
02 Oct 1960 in 
Bronx, New York
3
2
Pedigree Chart for  
Joseph Albert O'Brien*
' metadata={'source': '/tmp/tmp5j809av7', 'file_path': '/tmp/tmp5j809av7', 'page': 0, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}
2024-12-19 03:04:49 - INFO - Invoking chain
2024-12-19 03:04:56 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 03:04:56 - INFO - Response: {'cleaned_content': "Page 1\n\nJoseph Albert O'Brien\n- Born: 24 April 1932 in Bronx, New York\n- Married: 07 October 1956\n- Died: 07 January 2011 in Annapolis, Anne Arundel, Maryland\n\nJoseph A O'Brien\n- Born: Approximately 1905 in New York\n- Married: 02 August 1931 in Bronx, New York; St. Anselm's Church - 68 Tinton Ave\n- Died: 20 November 1945 in Bronx, New York\n\nGenevieve Godziemski\n- Born: 01 November 1911 in New York\n- Died: 23 July 1989 in Hollywood, Broward, Florida; Age at Death: 77\n\nJoseph Albert O'Brien\n- Born: 20 January 1875 in New York\n- Married: 17 December 1901 in Manhattan, New York; Based on information from the 1910 Census\n- Died: Before 1940 in Bronx, New York; Wife was a widow in the 1940 Census.\n\nMary T Flanagan\n- Born: Approximately 1879 in New York\n- Died: 07 January 1952 in Bronx, New York\n\nWalter (Wladislaw) Godziemski (Godzembsky)\n- Born: 05 March 1877 in Poland\n- Married: 02 September 1906 in New York\n- Died: 19 August 1943 in Richmond, New York\n\nMariana (Mary) Zwalina\n- Born: 15 March 1878 in Kolna, Podlaskie, Poland\n- Died: 02 October 1960 in Bronx, New York\n\nPedigree Chart for Joseph Albert O'Brien"}
2024-12-19 03:04:56 - INFO - Finished clean_files_chain
2024-12-19 03:04:56 - INFO - Successfully cleaned document 1 from OBrienFamilyNotes.pdf
2024-12-19 03:04:56 - INFO - Document 2 (OBrienFamilyNotes.pdf) of 8
2024-12-19 03:04:56 - INFO - Starting clean_files_chain
2024-12-19 03:04:56 - INFO - Document: page_content='Page 2
Joseph Albert Obrien*
b:
20 Jan 1875 in New  
York
m: 17 Dec 1901 in  
Manhattan, New York;  
Based on information  
from 1910 Census
d:
Bef. 1940 in Bronx,  
New York; Wife was a  
widow in the 1940  
Census.
John O'Brien
b:
Abt. 1848 in New  
York
m:
d:
Annie O'Brien
b:
Jun 1855 in New  
York
d:
1
' metadata={'source': '/tmp/tmp5j809av7', 'file_path': '/tmp/tmp5j809av7', 'page': 1, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}
2024-12-19 03:04:56 - INFO - Invoking chain
2024-12-19 03:04:59 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 03:04:59 - INFO - Response: {'cleaned_content': "Joseph Albert O'Brien\n\nBorn: 20 January 1875 in New York\nMarried: 17 December 1901 in Manhattan, New York\nBased on information from the 1910 Census\nDied: Before 1940 in Bronx, New York; Wife was a widow in the 1940 Census.\n\nJohn O'Brien\n\nBorn: Approximately 1848 in New York\nMarried:\nDied:\n\nAnnie O'Brien\n\nBorn: June 1855 in New York\nDied:"}
2024-12-19 03:04:59 - INFO - Finished clean_files_chain
2024-12-19 03:04:59 - INFO - Successfully cleaned document 2 from OBrienFamilyNotes.pdf
2024-12-19 03:04:59 - INFO - Document 3 (OBrienFamilyNotes.pdf) of 8
2024-12-19 03:04:59 - INFO - Starting clean_files_chain
2024-12-19 03:04:59 - INFO - Document: page_content='Page 3
Mary T Flanagan*
b:
Abt. 1879 in New  
York
m: 17 Dec 1901 in  
Manhattan, New York;  
Based on information  
from 1910 Census
d:
07 Jan 1952 in  
Bronx, New York
Peter Flanagan
b:
m:
d:
Ellen Flanagan
b:
Scotland
d:
1
' metadata={'source': '/tmp/tmp5j809av7', 'file_path': '/tmp/tmp5j809av7', 'page': 2, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}
2024-12-19 03:04:59 - INFO - Invoking chain
2024-12-19 03:05:01 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 03:05:01 - INFO - Response: {'cleaned_content': 'Page 3\n\nMary T. Flanagan\n- Born: Approximately 1879 in New York\n- Married: December 17, 1901 in Manhattan, New York (Based on information from the 1910 Census)\n- Died: January 7, 1952 in Bronx, New York\n\nPeter Flanagan\n- Born: \n- Married: \n- Died: \n\nEllen Flanagan\n- Born: Scotland\n- Died: '}
2024-12-19 03:05:01 - INFO - Finished clean_files_chain
2024-12-19 03:05:01 - INFO - Successfully cleaned document 3 from OBrienFamilyNotes.pdf
2024-12-19 03:05:01 - INFO - Document 4 (OBrienFamilyNotes.pdf) of 8
2024-12-19 03:05:01 - INFO - Starting clean_files_chain
2024-12-19 03:05:01 - INFO - Document: page_content='Individual Report for Joseph Albert Obrien*
Sex:
Annie O'Brien
Mother:
John O'Brien
Father:
Male
Joseph Albert Obrien*1-10
Individual Summary:
Individual Facts:
Birth:
20 Jan 1875 in New York1-4, 6-8, 10
Residence:
1880 in New York City, New York, New York; Age: 5Marital Status: Single;
Relation to Head of House: Son5
Residence:
1900 in Manhattan, New York, New York; Age: 23Marital Status: Single;
Relation to Head of House: Son4
Residence:
1905 in Manhattan, New York, New York; Relation to Head of House:
Head10
Residence:
1910 in Bronx Assembly District 32, New York, New York, USA; Age:
34Marital Status: Married; Relation to Head of House: Head1
Residence:
01 Jun 1915 in New York, Bronx, New York, United States8
Residence:
1917 in Bronx, Bronx, New York7
Residence:
1920 in Bronx Assembly District 3, Bronx, New York, USA; Age: 44Marital
Status: Married; Relation to Head of House: Head2
Residence:
01 Jun 1925 in New York, Bronx, New York; Age: 50Relation to Head of
House: Head3
Residence:
1930 in Bronx, Bronx, New York; Age: 53Marital Status: Married; Relation to
Head of House: Head6
Death:
Bef. 1940 in Bronx, New York; Wife was a widow in the 1940 Census.
Shared Facts:
Mary T Flanagan*
Marriage:
17 Dec 1901 in Manhattan, New York; Based on information from 1910
Census
Children:
Edna Mary O'Brien
Joseph A O'Brien*
William Francis O'Brien
Raymond O'Brien V
John Edward Obrien
Edwin Obrien
Eileen R O'Brien
Notes:
Person Notes:
[no notes]
Sources:
1 Ancestry.com, 1910 United States Federal Census (Online publication - Provo, UT, USA:
Ancestry.com Operations Inc, 2006.Original data - Thirteenth Census of the United States,
1910 (NARA microfilm publication T624, 1,178 rolls). Records of the Bureau of the Census,
Record Group 29. National Archives, Was), Ancestry.com, http://www.Ancestry.com, Year:
1910; Census Place: Bronx Assembly District 32, New York, New York; Roll: T624_997;
Page: 1A; Enumeration District: 1451; FHL microfilm: 1375010.
2 Ancestry.com, 1920 United States Federal Census (Online publication - Provo, UT, USA:
Ancestry.com Operations Inc, 2010. Images reproduced by FamilySearch.Original data -
Fourteenth Census of the United States, 1920. (NARA microfilm publication T625, 2076
rolls). Records of the Bureau of the Census, Reco), iOS Application, http://www.iOS
Application, Year: 1920; Census Place: Bronx Assembly District 3, Bronx, New York.
3 Ancestry.com, New York, State Census, 1925 (Ancestry.com Operations, Inc.),
Ancestry.com, http://www.Ancestry.com, New York State Archives; Albany, New York; State
Population Census Schedules, 1925; Election District: 03; Assembly District: 06; City: New
York; County: Bronx; Page: 16.
' metadata={'source': '/tmp/tmp5j809av7', 'file_path': '/tmp/tmp5j809av7', 'page': 3, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}
2024-12-19 03:05:01 - INFO - Invoking chain
2024-12-19 03:05:16 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 03:05:16 - INFO - Response: {'cleaned_content': "Individual Report for Joseph Albert O'Brien\n\nSex: Male\nMother: Annie O'Brien\nFather: John O'Brien\n\nIndividual Summary:\n\nIndividual Facts:\n- Birth: 20 Jan 1875 in New York\n- Residence (1880): New York City, New York; Age: 5; Marital Status: Single; Relation to Head of House: Son\n- Residence (1900): Manhattan, New York; Age: 23; Marital Status: Single; Relation to Head of House: Son\n- Residence (1905): Manhattan, New York; Relation to Head of House: Head\n- Residence (1910): Bronx Assembly District 32, New York; Age: 34; Marital Status: Married; Relation to Head of House: Head\n- Residence (01 Jun 1915): New York, Bronx, New York, United States\n- Residence (1917): Bronx, New York\n- Residence (1920): Bronx Assembly District 3, Bronx, New York; Age: 44; Marital Status: Married; Relation to Head of House: Head\n- Residence (01 Jun 1925): New York, Bronx, New York; Age: 50; Relation to Head of House: Head\n- Residence (1930): Bronx, New York; Age: 53; Marital Status: Married; Relation to Head of House: Head\n- Death: Before 1940 in Bronx, New York; Wife was a widow in the 1940 Census.\n\nShared Facts:\n- Marriage: 17 Dec 1901 in Manhattan, New York; Based on information from the 1910 Census\n- Children:\n  - Edna Mary O'Brien\n  - Joseph A O'Brien\n  - William Francis O'Brien\n  - Raymond O'Brien V\n  - John Edward O'Brien\n  - Edwin O'Brien\n  - Eileen R O'Brien\n\nNotes:\n- Person Notes: [no notes]\n\nSources:\n1. Ancestry.com, 1910 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2006. Original data - Thirteenth Census of the United States, 1910 (NARA microfilm publication T624, 1,178 rolls). Records of the Bureau of the Census, Record Group 29. National Archives, Washington, D.C.), Ancestry.com, http://www.Ancestry.com, Year: 1910; Census Place: Bronx Assembly District 32, New York, New York; Roll: T624_997; Page: 1A; Enumeration District: 1451; FHL microfilm: 1375010.\n2. Ancestry.com, 1920 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2010. Images reproduced by FamilySearch. Original data - Fourteenth Census of the United States, 1920. (NARA microfilm publication T625, 2076 rolls). Records of the Bureau of the Census), iOS Application, http://www.iOSApplication, Year: 1920; Census Place: Bronx Assembly District 3, Bronx, New York.\n3. Ancestry.com, New York, State Census, 1925 (Ancestry.com Operations, Inc.), Ancestry.com, http://www.Ancestry.com, New York State Archives; Albany, New York; State Population Census Schedules, 1925; Election District: 03; Assembly District: 06; City: New York; County: Bronx; Page: 16."}
2024-12-19 03:05:16 - INFO - Finished clean_files_chain
2024-12-19 03:05:16 - INFO - Successfully cleaned document 4 from OBrienFamilyNotes.pdf
2024-12-19 03:05:16 - INFO - Document 5 (OBrienFamilyNotes.pdf) of 8
2024-12-19 03:05:16 - INFO - Starting clean_files_chain
2024-12-19 03:05:16 - INFO - Document: page_content='Sources:
4 Ancestry.com, 1900 United States Federal Census (Online publication - Provo, UT, USA:
Ancestry.com Operations Inc, 2004.Original data - United States of America, Bureau of the
Census. Twelfth Census of the United States, 1900. Washington, D.C.: National Archives and
Records Administration, 1900. T623, 18), Ancestry.com, http://www.Ancestry.com, Year:
1900; Census Place: Manhattan, New York, New York; Roll: 1123; Page: 9B; Enumeration
District: 0933; FHL microfilm: 1241123.
5 Ancestry.com and The Church of Jesus Christ of Latter-day Saints, 1880 United States
Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2010.
1880 U.S. Census Index provided by The Church of Jesus Christ of Latter-day Saints ©
Copyright 1999 Intellectual Reserve, Inc. All rights reserved. All use is subject to the limited
), Ancestry.com, http://www.Ancestry.com, Year: 1880; Census Place: New York City, New
York, New York; Roll: 898; Family History Film: 1254898; Page: 513D; Enumeration District:
636; Image: 0387.
6 Ancestry.com, 1930 United States Federal Census (Online publication - Provo, UT, USA:
Ancestry.com Operations Inc, 2002.Original data - United States of America, Bureau of the
Census. Fifteenth Census of the United States, 1930. Washington, D.C.: National Archives
and Records Administration, 1930. T626.), Ancestry.com, http://www.Ancestry.com, Year:
1930; Census Place: Bronx, Bronx, New York; Roll: 1470; Page: 16B; Enumeration District:
220; Image: 179.0; FHL microfilm: 2341205.
7 U.S., World War I Draft Registration Cards, 1917-1918 (Ancestry.com. U.S., World War I
Draft Registration Cards, 1917-1918 [database on-line]. Provo, UT, USA: Ancestry.com
Operations Inc, 2005.), Ancestry.com, http://www.Ancestry.com, Registration State: New
York; Registration County: Bronx; Roll: 1753937; Draft Board: 4.
8 Ancestry.com, New York, State Census, 1915 (Online publication - Provo, UT, USA:
Ancestry.com Operations, Inc., 2012.Original data - State population census schedules,
1915. Albany, New York: New York State Archives.Original data: State population census
schedules, 1915. Albany, New York: New York S), Ancestry.com, http://www.Ancestry.com,
Source Citation: New York State Archives; Albany, New York; State Population Census
Schedules, 1915; Election District: 30; Assembly District: 32; City: New York; County: Bronx;
Page: 96. Name: Joseph Albert Obrien birth date: 20 Jan 1875 birth place: New York
residence date: 1 June 1915 residence place: New York, Bronx, New York, United States.
9 Ancestry.com, New York, New York, Marriage Indexes 1866-1937 (Ancestry.com Operations,
Inc.), Ancestry.com, http://www.Ancestry.com.
10 Ancestry.com, New York, State Census, 1905 (Ancestry.com Operations, Inc.),
Ancestry.com, http://www.Ancestry.com, New York State Archives; Albany, New York; State
Population Census Schedules, 1905; Election District: A.D. 33 E.D. 18; City: Manhattan;
County: New York; Page: 57.
' metadata={'source': '/tmp/tmp5j809av7', 'file_path': '/tmp/tmp5j809av7', 'page': 4, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}
2024-12-19 03:05:16 - INFO - Invoking chain
2024-12-19 03:05:33 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 03:05:33 - INFO - Response: {'cleaned_content': 'Sources:\n\n1. Ancestry.com, 1900 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2004. Original data - United States of America, Bureau of the Census. Twelfth Census of the United States, 1900. Washington, D.C.: National Archives and Records Administration, 1900. T623, 18), Ancestry.com, http://www.Ancestry.com, Year: 1900; Census Place: Manhattan, New York, New York; Roll: 1123; Page: 9B; Enumeration District: 0933; FHL microfilm: 1241123.\n\n2. Ancestry.com and The Church of Jesus Christ of Latter-day Saints, 1880 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2010. 1880 U.S. Census Index provided by The Church of Jesus Christ of Latter-day Saints © Copyright 1999 Intellectual Reserve, Inc. All rights reserved. All use is subject to the limited), Ancestry.com, http://www.Ancestry.com, Year: 1880; Census Place: New York City, New York, New York; Roll: 898; Family History Film: 1254898; Page: 513D; Enumeration District: 636; Image: 0387.\n\n3. Ancestry.com, 1930 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2002. Original data - United States of America, Bureau of the Census. Fifteenth Census of the United States, 1930. Washington, D.C.: National Archives and Records Administration, 1930. T626.), Ancestry.com, http://www.Ancestry.com, Year: 1930; Census Place: Bronx, Bronx, New York; Roll: 1470; Page: 16B; Enumeration District: 220; Image: 179.0; FHL microfilm: 2341205.\n\n4. U.S., World War I Draft Registration Cards, 1917-1918 (Ancestry.com. U.S., World War I Draft Registration Cards, 1917-1918 [database on-line]. Provo, UT, USA: Ancestry.com Operations Inc, 2005.), Ancestry.com, http://www.Ancestry.com, Registration State: New York; Registration County: Bronx; Roll: 1753937; Draft Board: 4.\n\n5. Ancestry.com, New York, State Census, 1915 (Online publication - Provo, UT, USA: Ancestry.com Operations, Inc., 2012. Original data - State population census schedules, 1915. Albany, New York: New York State Archives. Original data: State population census schedules, 1915. Albany, New York: New York State Archives), Ancestry.com, http://www.Ancestry.com, Source Citation: New York State Archives; Albany, New York; State Population Census Schedules, 1915; Election District: 30; Assembly District: 32; City: New York; County: Bronx; Page: 96. Name: Joseph Albert Obrien birth date: 20 Jan 1875 birth place: New York residence date: 1 June 1915 residence place: New York, Bronx, New York, United States.\n\n6. Ancestry.com, New York, New York, Marriage Indexes 1866-1937 (Ancestry.com Operations, Inc.), Ancestry.com, http://www.Ancestry.com.\n\n7. Ancestry.com, New York, State Census, 1905 (Ancestry.com Operations, Inc.), Ancestry.com, http://www.Ancestry.com, New York State Archives; Albany, New York; State Population Census Schedules, 1905; Election District: A.D. 33 E.D. 18; City: Manhattan; County: New York; Page: 57.'}
2024-12-19 03:05:33 - INFO - Finished clean_files_chain
2024-12-19 03:05:33 - INFO - Successfully cleaned document 5 from OBrienFamilyNotes.pdf
2024-12-19 03:05:33 - INFO - Document 6 (OBrienFamilyNotes.pdf) of 8
2024-12-19 03:05:33 - INFO - Starting clean_files_chain
2024-12-19 03:05:33 - INFO - Document: page_content='Family View Report for Joseph Albert Obrien*
John O'Brien
1848 -
Joseph Albert Obrien*
1875 - 1940
James Coffey
? O'Brien
Annie O'Brien
1855 -
Mary T Flanagan*
Abt. 1879
New York
07 Jan 1952
Bronx, New York
Born:
Died:
Marriage:
17 Dec 1901 in Manhattan, New York; Based on information from 1910 Census
Joseph Albert Obrien*
20 Jan 1875
New York
Bef. 1940
Bronx, New York
Born:
Died:
Death
Children:
Sex Birth
F
Edna Mary O'Brien
21 Mar 1902
Manhattan, New York
M
Joseph A O'Brien*
20 Nov 1945
Bronx, New York
Abt. 1905
New York
M
William Francis O'Brien
17 Aug 1995
Cranbury, Middlesex, New Jersey
20 May 1906
Bronx, New York
M
Raymond O'Brien V
Abt. 1908
New York
M
John Edward Obrien
Abt. 1910
New York
M
Edwin Obrien
Abt. 1914
New York
F
Eileen R O'Brien
05 Jan 2013
New York
23 Nov 1919
New York
' metadata={'source': '/tmp/tmp5j809av7', 'file_path': '/tmp/tmp5j809av7', 'page': 5, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}
2024-12-19 03:05:33 - INFO - Invoking chain
2024-12-19 03:05:43 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 03:05:43 - INFO - Response: {'cleaned_content': "Family View Report for Joseph Albert O'Brien\n\nJohn O'Brien\n1848 - \n\nJoseph Albert O'Brien\n1875 - 1940\n\nJames Coffey\n? O'Brien\n\nAnnie O'Brien\n1855 - \n\nMary T. Flanagan\nApproximately 1879 - 07 Jan 1952\nBronx, New York\n\nBorn: 20 Jan 1875, New York\nDied: Before 1940, Bronx, New York\n\nMarriage: 17 Dec 1901 in Manhattan, New York; Based on information from the 1910 Census\n\nChildren:\n\n1. Edna Mary O'Brien\n   - Birth: 21 Mar 1902, Manhattan, New York\n   - Sex: Female\n\n2. Joseph A. O'Brien\n   - Birth: Approximately 1905, New York\n   - Died: 20 Nov 1945, Bronx, New York\n   - Sex: Male\n\n3. William Francis O'Brien\n   - Birth: 20 May 1906, Bronx, New York\n   - Died: 17 Aug 1995, Cranbury, Middlesex, New Jersey\n   - Sex: Male\n\n4. Raymond O'Brien V\n   - Birth: Approximately 1908, New York\n   - Sex: Male\n\n5. John Edward O'Brien\n   - Birth: Approximately 1910, New York\n   - Sex: Male\n\n6. Edwin O'Brien\n   - Birth: Approximately 1914, New York\n   - Sex: Male\n\n7. Eileen R. O'Brien\n   - Birth: 23 Nov 1919, New York\n   - Died: 05 Jan 2013, New York\n   - Sex: Female"}
2024-12-19 03:05:43 - INFO - Finished clean_files_chain
2024-12-19 03:05:43 - INFO - Successfully cleaned document 6 from OBrienFamilyNotes.pdf
2024-12-19 03:05:43 - INFO - Document 7 (OBrienFamilyNotes.pdf) of 8
2024-12-19 03:05:43 - INFO - Starting clean_files_chain
2024-12-19 03:05:43 - INFO - Document: page_content='Individual Report for John O'Brien
Sex:
Mother:
Father:
Male
John O'Brien1
Individual Summary:
Individual Facts:
Birth:
Abt. 1848 in New York1
Residence:
1880 in New York City, New York, New York; Age: 32Marital Status:
Married; Relation to Head of House: Self; Occupation: Plumber1
Shared Facts:
Annie O'Brien
[no facts]
Children:
Joseph Albert Obrien*
Mary R O'Brien
John A O'Brien
Helen Bridget O'Brien
Annie O'Brien
William F O'Brien
Gertrude O'Brien
Notes:
Person Notes:
[no notes]
Sources:
1 Ancestry.com and The Church of Jesus Christ of Latter-day Saints, 1880 United States
Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2010.
1880 U.S. Census Index provided by The Church of Jesus Christ of Latter-day Saints ©
Copyright 1999 Intellectual Reserve, Inc. All rights reserved. All use is subject to the limited
), Ancestry.com, http://www.Ancestry.com, Year: 1880; Census Place: New York City, New
York, New York; Roll: 898; Family History Film: 1254898; Page: 513D; Enumeration District:
636; Image: 0387.
' metadata={'source': '/tmp/tmp5j809av7', 'file_path': '/tmp/tmp5j809av7', 'page': 6, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}
2024-12-19 03:05:43 - INFO - Invoking chain
2024-12-19 03:05:48 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 03:05:48 - INFO - Response: {'cleaned_content': "Individual Report for John O'Brien\n\nSex: Male\n\nMother: Annie O'Brien\n\nFather: [no facts]\n\nIndividual Summary:\n\nIndividual Facts:\n- Birth: About 1848 in New York\n- Residence: In 1880, New York City, New York; Age: 32\n- Marital Status: Married\n- Relation to Head of House: Self\n- Occupation: Plumber\n\nShared Facts:\n- Children:\n  - Joseph Albert O'Brien\n  - Mary R. O'Brien\n  - John A. O'Brien\n  - Helen Bridget O'Brien\n  - Annie O'Brien\n  - William F. O'Brien\n  - Gertrude O'Brien\n\nNotes:\n- Person Notes: [no notes]\n\nSources:\n1. Ancestry.com and The Church of Jesus Christ of Latter-day Saints, 1880 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2010). 1880 U.S. Census Index provided by The Church of Jesus Christ of Latter-day Saints © Copyright 1999 Intellectual Reserve, Inc. All rights reserved. All use is subject to the limited.\n   Ancestry.com, http://www.Ancestry.com, Year: 1880; Census Place: New York City, New York, New York; Roll: 898; Family History Film: 1254898; Page: 513D; Enumeration District: 636; Image: 0387."}
2024-12-19 03:05:48 - INFO - Finished clean_files_chain
2024-12-19 03:05:48 - INFO - Successfully cleaned document 7 from OBrienFamilyNotes.pdf
2024-12-19 03:05:48 - INFO - Document 8 (OBrienFamilyNotes.pdf) of 8
2024-12-19 03:05:48 - INFO - Starting clean_files_chain
2024-12-19 03:05:48 - INFO - Document: page_content='' metadata={'source': '/tmp/tmp5j809av7', 'file_path': '/tmp/tmp5j809av7', 'page': 7, 'total_pages': 8, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': '', 'producer': '', 'creationDate': '', 'modDate': "D:20170821112246-07'00'", 'trapped': ''}
2024-12-19 03:05:48 - INFO - Invoking chain
2024-12-19 03:05:49 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 03:05:49 - INFO - Response: {'cleaned_content': ''}
2024-12-19 03:05:49 - INFO - Finished clean_files_chain
2024-12-19 03:05:49 - INFO - Successfully cleaned document 8 from OBrienFamilyNotes.pdf
2024-12-19 03:05:49 - INFO - Pages: []
2024-12-19 03:05:49 - INFO - Full response: Page 1

Joseph Albert O'Brien
- Born: 24 April 1932 in Bronx, New York
- Married: 07 October 1956
- Died: 07 January 2011 in Annapolis, Anne Arundel, Maryland

Joseph A O'Brien
- Born: Approximately 1905 in New York
- Married: 02 August 1931 in Bronx, New York; St. Anselm's Church - 68 Tinton Ave
- Died: 20 November 1945 in Bronx, New York

Genevieve Godziemski
- Born: 01 November 1911 in New York
- Died: 23 July 1989 in Hollywood, Broward, Florida; Age at Death: 77

Joseph Albert O'Brien
- Born: 20 January 1875 in New York
- Married: 17 December 1901 in Manhattan, New York; Based on information from the 1910 Census
- Died: Before 1940 in Bronx, New York; Wife was a widow in the 1940 Census.

Mary T Flanagan
- Born: Approximately 1879 in New York
- Died: 07 January 1952 in Bronx, New York

Walter (Wladislaw) Godziemski (Godzembsky)
- Born: 05 March 1877 in Poland
- Married: 02 September 1906 in New York
- Died: 19 August 1943 in Richmond, New York

Mariana (Mary) Zwalina
- Born: 15 March 1878 in Kolna, Podlaskie, Poland
- Died: 02 October 1960 in Bronx, New York

Pedigree Chart for Joseph Albert O'BrienJoseph Albert O'Brien

Born: 20 January 1875 in New York
Married: 17 December 1901 in Manhattan, New York
Based on information from the 1910 Census
Died: Before 1940 in Bronx, New York; Wife was a widow in the 1940 Census.

John O'Brien

Born: Approximately 1848 in New York
Married:
Died:

Annie O'Brien

Born: June 1855 in New York
Died:Page 3

Mary T. Flanagan
- Born: Approximately 1879 in New York
- Married: December 17, 1901 in Manhattan, New York (Based on information from the 1910 Census)
- Died: January 7, 1952 in Bronx, New York

Peter Flanagan
- Born: 
- Married: 
- Died: 

Ellen Flanagan
- Born: Scotland
- Died: Individual Report for Joseph Albert O'Brien

Sex: Male
Mother: Annie O'Brien
Father: John O'Brien

Individual Summary:

Individual Facts:
- Birth: 20 Jan 1875 in New York
- Residence (1880): New York City, New York; Age: 5; Marital Status: Single; Relation to Head of House: Son
- Residence (1900): Manhattan, New York; Age: 23; Marital Status: Single; Relation to Head of House: Son
- Residence (1905): Manhattan, New York; Relation to Head of House: Head
- Residence (1910): Bronx Assembly District 32, New York; Age: 34; Marital Status: Married; Relation to Head of House: Head
- Residence (01 Jun 1915): New York, Bronx, New York, United States
- Residence (1917): Bronx, New York
- Residence (1920): Bronx Assembly District 3, Bronx, New York; Age: 44; Marital Status: Married; Relation to Head of House: Head
- Residence (01 Jun 1925): New York, Bronx, New York; Age: 50; Relation to Head of House: Head
- Residence (1930): Bronx, New York; Age: 53; Marital Status: Married; Relation to Head of House: Head
- Death: Before 1940 in Bronx, New York; Wife was a widow in the 1940 Census.

Shared Facts:
- Marriage: 17 Dec 1901 in Manhattan, New York; Based on information from the 1910 Census
- Children:
  - Edna Mary O'Brien
  - Joseph A O'Brien
  - William Francis O'Brien
  - Raymond O'Brien V
  - John Edward O'Brien
  - Edwin O'Brien
  - Eileen R O'Brien

Notes:
- Person Notes: [no notes]

Sources:
1. Ancestry.com, 1910 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2006. Original data - Thirteenth Census of the United States, 1910 (NARA microfilm publication T624, 1,178 rolls). Records of the Bureau of the Census, Record Group 29. National Archives, Washington, D.C.), Ancestry.com, http://www.Ancestry.com, Year: 1910; Census Place: Bronx Assembly District 32, New York, New York; Roll: T624_997; Page: 1A; Enumeration District: 1451; FHL microfilm: 1375010.
2. Ancestry.com, 1920 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2010. Images reproduced by FamilySearch. Original data - Fourteenth Census of the United States, 1920. (NARA microfilm publication T625, 2076 rolls). Records of the Bureau of the Census), iOS Application, http://www.iOSApplication, Year: 1920; Census Place: Bronx Assembly District 3, Bronx, New York.
3. Ancestry.com, New York, State Census, 1925 (Ancestry.com Operations, Inc.), Ancestry.com, http://www.Ancestry.com, New York State Archives; Albany, New York; State Population Census Schedules, 1925; Election District: 03; Assembly District: 06; City: New York; County: Bronx; Page: 16.Sources:

1. Ancestry.com, 1900 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2004. Original data - United States of America, Bureau of the Census. Twelfth Census of the United States, 1900. Washington, D.C.: National Archives and Records Administration, 1900. T623, 18), Ancestry.com, http://www.Ancestry.com, Year: 1900; Census Place: Manhattan, New York, New York; Roll: 1123; Page: 9B; Enumeration District: 0933; FHL microfilm: 1241123.

2. Ancestry.com and The Church of Jesus Christ of Latter-day Saints, 1880 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2010. 1880 U.S. Census Index provided by The Church of Jesus Christ of Latter-day Saints © Copyright 1999 Intellectual Reserve, Inc. All rights reserved. All use is subject to the limited), Ancestry.com, http://www.Ancestry.com, Year: 1880; Census Place: New York City, New York, New York; Roll: 898; Family History Film: 1254898; Page: 513D; Enumeration District: 636; Image: 0387.

3. Ancestry.com, 1930 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2002. Original data - United States of America, Bureau of the Census. Fifteenth Census of the United States, 1930. Washington, D.C.: National Archives and Records Administration, 1930. T626.), Ancestry.com, http://www.Ancestry.com, Year: 1930; Census Place: Bronx, Bronx, New York; Roll: 1470; Page: 16B; Enumeration District: 220; Image: 179.0; FHL microfilm: 2341205.

4. U.S., World War I Draft Registration Cards, 1917-1918 (Ancestry.com. U.S., World War I Draft Registration Cards, 1917-1918 [database on-line]. Provo, UT, USA: Ancestry.com Operations Inc, 2005.), Ancestry.com, http://www.Ancestry.com, Registration State: New York; Registration County: Bronx; Roll: 1753937; Draft Board: 4.

5. Ancestry.com, New York, State Census, 1915 (Online publication - Provo, UT, USA: Ancestry.com Operations, Inc., 2012. Original data - State population census schedules, 1915. Albany, New York: New York State Archives. Original data: State population census schedules, 1915. Albany, New York: New York State Archives), Ancestry.com, http://www.Ancestry.com, Source Citation: New York State Archives; Albany, New York; State Population Census Schedules, 1915; Election District: 30; Assembly District: 32; City: New York; County: Bronx; Page: 96. Name: Joseph Albert Obrien birth date: 20 Jan 1875 birth place: New York residence date: 1 June 1915 residence place: New York, Bronx, New York, United States.

6. Ancestry.com, New York, New York, Marriage Indexes 1866-1937 (Ancestry.com Operations, Inc.), Ancestry.com, http://www.Ancestry.com.

7. Ancestry.com, New York, State Census, 1905 (Ancestry.com Operations, Inc.), Ancestry.com, http://www.Ancestry.com, New York State Archives; Albany, New York; State Population Census Schedules, 1905; Election District: A.D. 33 E.D. 18; City: Manhattan; County: New York; Page: 57.Family View Report for Joseph Albert O'Brien

John O'Brien
1848 - 

Joseph Albert O'Brien
1875 - 1940

James Coffey
? O'Brien

Annie O'Brien
1855 - 

Mary T. Flanagan
Approximately 1879 - 07 Jan 1952
Bronx, New York

Born: 20 Jan 1875, New York
Died: Before 1940, Bronx, New York

Marriage: 17 Dec 1901 in Manhattan, New York; Based on information from the 1910 Census

Children:

1. Edna Mary O'Brien
   - Birth: 21 Mar 1902, Manhattan, New York
   - Sex: Female

2. Joseph A. O'Brien
   - Birth: Approximately 1905, New York
   - Died: 20 Nov 1945, Bronx, New York
   - Sex: Male

3. William Francis O'Brien
   - Birth: 20 May 1906, Bronx, New York
   - Died: 17 Aug 1995, Cranbury, Middlesex, New Jersey
   - Sex: Male

4. Raymond O'Brien V
   - Birth: Approximately 1908, New York
   - Sex: Male

5. John Edward O'Brien
   - Birth: Approximately 1910, New York
   - Sex: Male

6. Edwin O'Brien
   - Birth: Approximately 1914, New York
   - Sex: Male

7. Eileen R. O'Brien
   - Birth: 23 Nov 1919, New York
   - Died: 05 Jan 2013, New York
   - Sex: FemaleIndividual Report for John O'Brien

Sex: Male

Mother: Annie O'Brien

Father: [no facts]

Individual Summary:

Individual Facts:
- Birth: About 1848 in New York
- Residence: In 1880, New York City, New York; Age: 32
- Marital Status: Married
- Relation to Head of House: Self
- Occupation: Plumber

Shared Facts:
- Children:
  - Joseph Albert O'Brien
  - Mary R. O'Brien
  - John A. O'Brien
  - Helen Bridget O'Brien
  - Annie O'Brien
  - William F. O'Brien
  - Gertrude O'Brien

Notes:
- Person Notes: [no notes]

Sources:
1. Ancestry.com and The Church of Jesus Christ of Latter-day Saints, 1880 United States Federal Census (Online publication - Provo, UT, USA: Ancestry.com Operations Inc, 2010). 1880 U.S. Census Index provided by The Church of Jesus Christ of Latter-day Saints © Copyright 1999 Intellectual Reserve, Inc. All rights reserved. All use is subject to the limited.
   Ancestry.com, http://www.Ancestry.com, Year: 1880; Census Place: New York City, New York, New York; Roll: 898; Family History Film: 1254898; Page: 513D; Enumeration District: 636; Image: 0387.
2024-12-19 03:05:49 - INFO - Processing pages: 0, full_response: Yes
2024-12-19 03:05:49 - INFO - Created 1 tasks for question generation
2024-12-19 03:05:49 - INFO - Starting question_generate_chain
2024-12-19 03:05:49 - INFO - Setting up question generation chain
2024-12-19 03:05:49 - INFO - Chain type: <class 'langchain_core.runnables.base.RunnableSequence'>
2024-12-19 03:05:49 - INFO - Question generation chain setup complete
2024-12-19 03:05:59 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 03:05:59 - INFO - Generated 6 questions for C with the following questions: [QAPair(question="What was the birth year of Joseph Albert O'Brien?", answer='1875', q_type='multiple_choice', choices=['1932', '1875', '1905', '1848']), QAPair(question='Which individual died on January 7, 1952?', answer='Mary T Flanagan', q_type='multiple_choice', choices=['Genevieve Godziemski', 'Walter Godziemski', 'Mary T Flanagan', 'Mariana Zwalina']), QAPair(question="How many children did Joseph Albert O'Brien have?", answer='7', q_type='multiple_choice', choices=['5', '6', '7', '8']), QAPair(question="Where was Joseph A O'Brien born?", answer='New York', q_type='multiple_choice', choices=['New Jersey', 'Bronx', 'New York', 'Florida']), QAPair(question="What was the marital status of Joseph Albert O'Brien in the 1910 Census?", answer='Married', q_type='multiple_choice', choices=['Single', 'Married', 'Divorced', 'Widowed']), QAPair(question='What is the death date of Walter Godziemski?', answer='19 August 1943', q_type='multiple_choice', choices=['20 November 1945', '19 August 1943', '02 October 1960', '23 July 1989'])]
2024-12-19 03:05:59 - INFO - Finished question_generate_chain
2024-12-19 03:05:59 - INFO - Completed question generation. Number of results: 1
2024-12-19 03:05:59 - INFO - Generated test list with 1 tests
2024-12-19 03:05:59 - INFO - Preparing judge_kwargs with 9 parameters
2024-12-19 03:05:59 - INFO - FINAL TEST:
{
    "questions": [
        {
            "question": "What was the birth year of Joseph Albert O'Brien?",
            "answer": "1875",
            "q_type": "multiple_choice",
            "choices": [
                "1932",
                "1875",
                "1905",
                "1848"
            ]
        },
        {
            "question": "Which individual died on January 7, 1952?",
            "answer": "Mary T Flanagan",
            "q_type": "multiple_choice",
            "choices": [
                "Genevieve Godziemski",
                "Walter Godziemski",
                "Mary T Flanagan",
                "Mariana Zwalina"
            ]
        },
        {
            "question": "How many children did Joseph Albert O'Brien have?",
            "answer": "7",
            "q_type": "multiple_choice",
            "choices": [
                "5",
                "6",
                "7",
                "8"
            ]
        },
        {
            "question": "Where was Joseph A O'Brien born?",
            "answer": "New York",
            "q_type": "multiple_choice",
            "choices": [
                "New Jersey",
                "Bronx",
                "New York",
                "Florida"
            ]
        },
        {
            "question": "What was the marital status of Joseph Albert O'Brien in the 1910 Census?",
            "answer": "Married",
            "q_type": "multiple_choice",
            "choices": [
                "Single",
                "Married",
                "Divorced",
                "Widowed"
            ]
        },
        {
            "question": "What is the death date of Walter Godziemski?",
            "answer": "19 August 1943",
            "q_type": "multiple_choice",
            "choices": [
                "20 November 1945",
                "19 August 1943",
                "02 October 1960",
                "23 July 1989"
            ]
        }
    ]
}
2024-12-19 03:05:59 - INFO - All tasks completed. Number of results: 1
2024-12-19 03:05:59 - INFO - Generated 1 tests
2024-12-19 03:05:59 - INFO - Cleaning up temp files
2024-12-19 03:05:59 - INFO - Deleted temp file: /tmp/tmp5j809av7
2024-12-19 03:05:59 - INFO - Temp files cleaned
2024-12-19 03:05:59 - INFO - Run function completed
2024-12-19 03:05:59 - INFO - Test generated successfully
2024-12-19 03:23:41 - INFO - GET request received for index page
2024-12-19 03:23:46 - INFO - GET request received for index page
2024-12-19 03:27:56 - INFO - GET request received for index page
2024-12-19 03:27:56 - INFO - GET request received for index page
2024-12-19 03:28:07 - INFO - GET request received for index page
2024-12-19 03:36:00 - INFO - GET request received for index page
2024-12-19 03:44:25 - INFO - GET request received for index page
2024-12-19 04:17:58 - INFO - GET request received for index page
2024-12-19 06:00:26 - INFO - GET request received for index page
2024-12-19 06:00:30 - INFO - GET request received for index page
2024-12-19 06:00:42 - INFO - GET request received for index page
2024-12-19 06:00:54 - INFO - GET request received for index page
2024-12-19 06:01:59 - INFO - POST request received for /generate
2024-12-19 06:01:59 - INFO - Form data: title='Operating Systems Test 1' course='Operating Systems' professor='Dr. Park' number_of_written_questions=1 number_of_mcq_questions=2 number_of_TF_questions=2 level='Normal' school_type='Undergraduate' difficulty='Extreme' testing_philosophy='I like to give them the hardest possible challenge so they study more and learn more :)' url_1=None url_2=None subject_material=[UploadFile(filename='450Slides10.pdf', size=166799, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides10.pdf"', 'content-type': 'application/pdf'}))]
2024-12-19 06:01:59 - INFO - Starting run function
2024-12-19 06:01:59 - INFO - Form data accessed
2024-12-19 06:01:59 - INFO - Form Title: Operating Systems Test 1
2024-12-19 06:01:59 - INFO - Form Course: Operating Systems
2024-12-19 06:01:59 - INFO - Form Professor: Dr. Park
2024-12-19 06:01:59 - INFO - Form Number of MCQ Questions: 2
2024-12-19 06:01:59 - INFO - Form Number of TF Questions: 2
2024-12-19 06:01:59 - INFO - Form Number of Written Questions: 1
2024-12-19 06:01:59 - INFO - Form School Type: Undergraduate
2024-12-19 06:01:59 - INFO - Form Difficulty: Extreme
2024-12-19 06:01:59 - INFO - Form Testing Philosophy: I like to give them the hardest possible challenge so they study more and learn more :)
2024-12-19 06:01:59 - INFO - Moving to files...
2024-12-19 06:01:59 - INFO - Starting to process files
2024-12-19 06:01:59 - INFO - Processing file: 450Slides10.pdf
2024-12-19 06:01:59 - INFO - Getting loader for file: UploadFile(filename='450Slides10.pdf', size=166799, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides10.pdf"', 'content-type': 'application/pdf'}))
2024-12-19 06:01:59 - INFO - File extension: .pdf
2024-12-19 06:01:59 - INFO - Processing PDF file: 450Slides10.pdf
2024-12-19 06:01:59 - INFO - Using loader type: PyMuPDFLoader for UploadFile(filename='450Slides10.pdf', size=166799, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides10.pdf"', 'content-type': 'application/pdf'}))
2024-12-19 06:01:59 - INFO - URLs: []
2024-12-19 06:01:59 - INFO - Processing 1 files and 0 URLs
2024-12-19 06:01:59 - INFO - Processing 450Slides10.pdf
2024-12-19 06:01:59 - INFO - Using loader type: PyMuPDFLoader for 450Slides10.pdf
2024-12-19 06:01:59 - INFO - Processing 450Slides10.pdf as a regular document using PyMuPDFLoader
2024-12-19 06:01:59 - INFO - Successfully loaded 5 documents from: 450Slides10.pdf
2024-12-19 06:01:59 - INFO - Docs: [Document(metadata={'source': '/tmp/tmpspk94gh1', 'file_path': '/tmp/tmpspk94gh1', 'page': 0, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n1\nPreview\nInter-Process Communication\n\ue007Race Condition\n\ue007Critical Section (or region)\n\ue007Solutions for Mutual Exclusion in a Critical Section\n◼With Busy Waiting\n\ue007Disabling Interrupts –non-preemptive kernel\n\ue007Lock Variables –violating the first necessary condition (mutual exclusion )\n\ue007Strict Alternation –violating the second necessary condition ( block by a process outside critical section)\n\ue007Peterson’s Solution\n\ue007Hardware Solution\n▪\nTest and Set Lock –\n▪\nMemory Barriers\n▪\nAtomic Variable\n\ue007Priority Inversion problems with busy waiting\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n1\nInterprocess Communication\n\ue007\nThree issues in interprocess communication\n1.\nHow one process can pass information to another (communication\nbetween processes) – with IPCS (shared memory, message queue,\nFIFO, PIPE, socket, …)\n2.\nHow to make sure two or more processes do not get into the\ncritical section (mutual exclusion)- with mutex, semaphore\n3.\nProper sequencing (Synchronization) when dependencies are\npresent (ex. A create outputs, B consume the outputs)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n2\nInterprocess Communication\n(Race Condition)\n\ue007Race Condition\n◼A situation where two or more processes are reading or writing some shared\ndata and the final result depends on who runs precisely when, are called race\ncondition.\n\ue007Critical section (critical region)\n◼The part of program where the shared memory is accessed.\n\ue007Mutual Exclusion in a critical section can avoid races condition:\n◼If we could arrange matters such that no two processes were ever in their\ncritical regions at the same time, we can avoid races condition.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n3\nInterprocess Communication\n(Race Condition)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n4\nSlots for file names\n• When a process want\nto print a file, it enter a\nfile name in a special\nspooler directory in\nprinter\n• Printer daemon\nperiodically check\nspooler directory any file\nneed to be printed.\nShared variable\nInterprocess Communication\n(Race Condition)\n\ue007\nProcess A tried to send a job to\nspooler, Process A read in = 7,\nprocess A time out and go to ready\nstate before updating in = in + 1.\n\ue007\nProcess B tried to send a job to\nspooler. Process B read in = 7, load\nits job name in slot 7, update i = i +\n1 = 8 and then go to block state for\nwaiting for job.\n\ue007\nProcess A is rescheduled by\nscheduler. Process A already read in\n= 7, Process A load its job name in\nslot 7, update i = i + 1 = 9 and then\ngo to blocked state waiting for this\njob finish.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n5\nInterprocess Communication\n(Race Condition)\n\ue007How to avoid race condition?\nMutual exclusion – some way of making sure that if one process is using a\nshared variable or file, the other processes will be excluded from doing the same\nthing.\n\ue007The choice of the algorithm for achieving mutual exclusion is a\nmajor design issue in any operating system.\n\ue007A solution for the race condition should have following four\nconditions\n1.\nNo two processes may be simultaneously inside their critical regions – mutual\nexclusion\n2.\nNo process running outside its critical region may block other processes\n3.\nNo process should have to wait forever to enter critical region\n4.\nNo assumptions may be made about speeds or the number of CPUs.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n6\n'), Document(metadata={'source': '/tmp/tmpspk94gh1', 'file_path': '/tmp/tmpspk94gh1', 'page': 1, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n2\nInterprocess Communication\n(Race Condition)\n\ue007Two approaches for mutual exclusion solutions.\n◼Busy wait – A process will wait until resource become available\nor CPU time term expired.\n◼Sleep and Wakeup – A process check a resource, if not available\ngo to sleep. When the resource become available, the process\nwill be waked up by system or the process release the resource.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n7\nMutual Exclusion with Busy Waiting\n\ue007Each process has time term. A process keep checking the\npossibility to get into critical section.\n\ue007Mutual Exclusion with Busy Waiting\n◼Disabling Interrupts –non-preemptive kernel\n◼Lock Variables\n◼Strict Alternation\n◼Peterson’s Solution\n◼Hardware Solutions\n\ue007Test and Set Lock\n\ue007Memory Barriers\n\ue007Atomic Variable\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n8\nMutual Exclusion with Busy Waiting\n(Disabling Interrupt – Nonprimitive Kernel)\nDisabling Interrupt\n\ue007Once a process get into the critical section, interrupts set to disable.\n\ue007Other process cannot get CPU time until the process finish its job in\nthe critical section.\n\ue007Since each user process has power to control interrupt, it might\ncause the end of system.\n\ue007We can build a simple program which can disable entire system\nsince user has control system interrupt. (vulnerable system)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n9\nMutual Exclusion with Busy Waiting\n(Disabling Interrupt – Nonprimitive Kernel)\nEx) End of the system with Disabling interrupt\n1. A process get into the critical section.\n2. It make disable all the interrupts – which means all\nother process are sleeping until the job is done in the\ncritical section.\n3. The process has blocked outside critical section just\nbefore make enable all the interrupts and never return\nagain, cause end of the system.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n10\nMutual Exclusion with Busy Waiting\n(Using Lock Variable)\n\ue007There are variable called “Lock”\n◼A process can enter in its critical section when Lock = 0.\n◼Lock =0 means no process is currently running in the critical\nsection, set Lock =1 and enter in the critical section.\n◼Once a process finish its job in critical section, set Lock = 0 and\nlet other process in the critical section\n◼Lock = 1 means there is a process running in the critical section,\na process do busy waiting until Lock become 0.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n11\nMutual Exclusion with Busy Waiting\n(Using Lock Variable)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n12\nstatic int lock = 0; //lock variable is initially 0\nrepeat\nwhile lock \ue0060do\n; (no-operation) // Busy waiting\nlock = 1;\nlock = 0;\nuntil false\nCritical Section\nRemainder Section\n'), Document(metadata={'source': '/tmp/tmpspk94gh1', 'file_path': '/tmp/tmpspk94gh1', 'page': 2, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n3\nMutual Exclusion with Busy Waiting\n(Using Lock Variable)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n13\nstatic int lock = 0; //lock is initially 0\nrepeat\nwhile lock \ue0060 do\n; (no-operation) //busy waiting\nlock = 1;\nlock = 0;\nuntil false\nCritical Section\nRemainder Section\nScenario)\n1.\nInitially lock = 0.\n2.\nA process P1 tries get into critical section.\nThe process P1 check lock value = 0.\n3.\nProcess P1 CPU time is over and go to\nready state, before updating lock = 1.\n4.\nProcess P2 tries get into critical section.\nP2 check lock value lock = 0\n5.\nP2 set lock = 1 and go to critical section.\n6.\nP2 CPU time is over and P1 is rescheduled.\n7.\nP1 already read lock = 0, P1 set lock = 1\nand go to Critical section. Now P1 and P2\nare in the critical section at the same\ntime\nViolating condition #1: mutual exclusion\nMutual Exclusion with Busy Waiting\n(Strict Alternation)\n\ue007Variable turn can be i or j.\n\ue007if turn = i, process Pi can go to the\ncritical section.\n\ue007Once Pi finish its job in critical\nsection, Pi set turn = j, let process\nPj enter critical section\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n14\nCritical Section\nRemainder Section\nturn is i or j\nrepeat\nwhile turn \ue006i do\n; (no-operation)\nturn = j;\nuntil false\nMutual Exclusion with Busy Waiting\n(Strict Alternation)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n15\nCritical Section\nRemainder Section\nturn is i or j\nrepeat\nwhile turn \ue006i do\n; (no-operation)\nturn = j;\nuntil false\nLet assume initially turn = 0\n1.\nP0 is in CS while P1 is in remaining\nsection.\n2.\nP0 done C.S. and set turn = 1, P1 is\nstill in remaining section.\n3.\nP0 done remaining section and want\nto go to C.S. but turn= 1.\n4.\nP1 has fatal error in remainder\nsection and trapped out by OS.\n5.\nP0 is waiting forever to enter the C.S.\nViolating #2 and #3 condition\n2.\nNo process running outside its critical\nregion may block other processes\n3.\nNo process should have to wait forever to\nenter critical region\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\n\ue007Peterson’s solution provides a good algorithmic description of\nsolving the critical-section problem and illustrates some of the\ncomplexities involved in designing software that addresses the\nrequirements of mutual exclusion, progress, and bounded waiting.\n\ue007Peterson’s solution is restricted to two processes that alternate\nexecution between their critical sections and remainder sections.\n\ue007The processes are numbered P0 and P1.\n\ue007For convenience, when presenting Pi, we use Pj to denote the other\nprocess; that is, j equals 1 −i.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n16\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n17\n#define false 0\n#define true 1\n#define n 2\nint turn\nint interested[n]\nvoid enter_region(int process);\n{\nint other;\nother = 1 – process\ninterested[process] = true\nturn = process;\nwhile (turn ==process && interest[other]==true)\n; /*no operation –busy waiting*/\n}\nvoid leave_region(int process)\n{\ninterest[process] = false;\n}\nvoid main()\n{\nrepeat\nenter_region (int i)\nCritical Section\nleave_resion (int i)\nRemainder Section\nuntil false\n}\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\n1.\nInitially, neither process is in the critical section\n2.\nA process P0 call enter_region (0)\na)\nSet interested[0] = true;\nb)\nSet turn = 0\n3.\ngo to critical section\n4.\nthe process P1 call enter_region(1) to get into its critical section\na)\nset interested[1] = true;\nb)\nset turn = 1;\n5.\nsince interested[0] = true, it is keep looping for interest [0] =\nfalse\n6.\nfinally process P0 finish its critical section and call leave_region(0)\n1.\nset interested[0] = false\n7.\nnow P1 find out interest[0] = false, P1 goes to its critical section\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n18\n'), Document(metadata={'source': '/tmp/tmpspk94gh1', 'file_path': '/tmp/tmpspk94gh1', 'page': 3, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n4\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\nProve for Peterson’s Solution)\n\ue007\nLets consider the case both P0 and P1 call enter_region(0) and enter_region(1) almost\nsimultaneously.\n\ue007\nLets interest[0]= true and interest[1] = true at the same time\n\ue007\nBut turn can be only turn = 0 or turn = 1 which ever store is done last is the one that\ncounts!!\nCase 1) turn = 0\nInside enter_region(0)\n◼\nSince turn =0 and interest [1] = ture, P0 keep looping in no-operation until P1 set interested[1] =\nfalse.\nInside enter_region(1)\n◼\nSince turn = 0 and interest[0] = true, P1 goes to its critical section.\nCase 2) turn = 1\nInside enter_region(0)\n◼\nSince turn =1 and interest [1] = ture,. P0 goes to its critical section\nInside enter_region(1)\n◼\nSince turn = 1 and interest[0] = true, P1 keep looping in no-operation until P0 set interested[0] =\nfalse.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n19\nMutual Exclusion with Busy Waiting\n(Test and Set Lock – hardware solution)\n\ue007\nSince TSL instruction is a hardware instruction. The operations of reading the\nlock and storing into register are guaranteed to be indivisible.\n\ue007\nInstruction test and set lock\nTSL RX, LOCK\n1. Read the content at the memory address of LOCK into register RX.\n2. Store a non-zero value at the memory address of LOCK\n\ue007\nThe operations of reading the content of LOCK and storing into it are guaranteed\nto be indivisible.\n\ue007\nHow to use Test and Set Lock instruction for solving race condition?\n◼\nWhen LOCK = 0, any process may set LOCK = 1 by using TSL instruction and go to\nits critical section.\n◼\nWhen the process finish its critical section, set LOCK = 0 using the original move\ninstruction.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n20\nMutual Exclusion with Busy Waiting\n(Test and Set Lock – hardware solution)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n21\nEnter_region\nTSL Register, LOCK\nCMP Register, #0\nJNE Enter_region\nSet LOCK, #1\nRET\nLeave_region\nMOVE LOCK, #0\nRET\nRepeat\nEnter_region\nLeave_region\nuntil false\nCritical Section\nRemainder Section\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\n\ue007Two general memory models\n◼Strongly ordered Memory –a memory modification on one processor is\nimmediately visible to all other processors\n◼Weakly ordered Memory – a memory modification on one processor may not\nbe immediately visible to other processors.\n\ue007With Strongly ordered memory, computer architectures provide\ninstructions that can force any changes in memory to be\npropagated to all other processors, thereby ensuring that memory\nmodifications are visible to threads (or processes) running on other\nprocessors.\n\ue007Such instructions are known as memory barriers or memory\nfences.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n22\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\n\ue007A memory barrier is a type of barrier instruction that causes a\ncentral processing unit (CPU) or compiler to enforce an ordering\nconstraint on memory operations issued before and after the\nbarrier instruction.\n\ue007This typically means that operations issued prior to the barrier are\nguaranteed to be performed before operations issued after the\nbarrier.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n23\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\nEx)\n\ue007Lets assume two threads (or processes) are running on different\npart of program by sharing two variables. (bool flag = false; int x=0;)\n\ue007Thread 1 might print 0 or 100 depends on the order of execution.\n\ue007By using memory barrier instruction Thread1 always print 100.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n24\nwhile (!flag)\nprint x;\nx = 100\nflag = true;\nThread 1\nThread 2\n'), Document(metadata={'source': '/tmp/tmpspk94gh1', 'file_path': '/tmp/tmpspk94gh1', 'page': 4, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content="9/17/2024\n5\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\n\ue007Now it is guarantee that the value of flag is loaded before the value of x\n\ue007Also it is guarantee that assignment to x occurs before the assignment to flag.\n\ue007So Thread 1 always print 100\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n25\nwhile (!flag)\nmemory_barrier();\nprint x;\nx = 100;\nmemory_barrier();\nflag = true;\nThread 1\nThread 2\nMutual Exclusion with Busy Waiting\n(Atomic Variables– hardware solution)\n\ue007We can avoid mutual exclusion by using atomic operations.\n\ue007When a thread (or process) performs an atomic operation, the\nother threads (or process) see it as happening instantaneously.\n\ue007The advantage of atomic operations is that they are relatively quick\ncompared to locks, and do not suffer from deadlock and convoying.\n\ue007The disadvantage is that they only do a limited set of operations,\nand often these are not enough to synthesize more complicated\noperations efficiently.\n\ue007But nonetheless you should not pass up an opportunity to use an\natomic operation in place of mutual exclusion.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n26\nMutual Exclusion with Busy Waiting\n(Priority Inversion Problem)\n\ue007Peterson's solution, test and set lock, Memory Barrier, Atomic variable method –\nbusy waiting – (wasting CPU time)\nPriority Inversion problem with busy waiting method\n\ue007A computer with two processes PH with high priorities, and PL with low priorities.\n\ue007The scheduling rules are such that PH get CPU time whenever it is in ready state.\n(preemptive priority scheduling)\n1. At a time T0: PL is in critical section, and PH is in block state.\n2. At a time T1: PH change sate from block to ready state and try to enter the critical\nsection. PL still in critical section.\n3. Based on scheduling rule, short-term scheduler select PH, PH hold CPU and try to enter\ninto critical section.\n4. Since PL is in critical section, PH run busy waiting outside critical section forever since\nPL does not have a chance to get CPU time to finish its critical section.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n27\nMutual Exclusion with Busy Waiting\n(Priority Inversion Problem)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n28\nBlock\nRunning\nReady\nT0 :\nPL: running state in critical section\nPH: block state\nPH\nPL\nBlock\nRunning\nReady\nPH\nPL\nT1 : PH become ready state\nPL: ready state in critical section\nPH: ready state\nCPU scheduler will select higher\npriority process\nBlock\nRunning\nReady\nPH\nPL\nTi>1\nPL: ready state in critical section\nPH: busy waiting in running state\nPH become ready state\nScheduler keep selecting\nPH since higher priority\nThe scheduling rules : CPU scheduler will always select higher priority process.\n")] for 450Slides10.pdf using PyMuPDFLoader
2024-12-19 06:01:59 - INFO - Document 1 (450Slides10.pdf) of 5
2024-12-19 06:01:59 - INFO - Starting clean_files_chain
2024-12-19 06:01:59 - INFO - Document: page_content='9/17/2024
1
Preview
Inter-Process Communication
Race Condition
Critical Section (or region)
Solutions for Mutual Exclusion in a Critical Section
◼With Busy Waiting
Disabling Interrupts –non-preemptive kernel
Lock Variables –violating the first necessary condition (mutual exclusion )
Strict Alternation –violating the second necessary condition ( block by a process outside critical section)
Peterson’s Solution
Hardware Solution
▪
Test and Set Lock –
▪
Memory Barriers
▪
Atomic Variable
Priority Inversion problems with busy waiting
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
1
Interprocess Communication

Three issues in interprocess communication
1.
How one process can pass information to another (communication
between processes) – with IPCS (shared memory, message queue,
FIFO, PIPE, socket, …)
2.
How to make sure two or more processes do not get into the
critical section (mutual exclusion)- with mutex, semaphore
3.
Proper sequencing (Synchronization) when dependencies are
present (ex. A create outputs, B consume the outputs)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
2
Interprocess Communication
(Race Condition)
Race Condition
◼A situation where two or more processes are reading or writing some shared
data and the final result depends on who runs precisely when, are called race
condition.
Critical section (critical region)
◼The part of program where the shared memory is accessed.
Mutual Exclusion in a critical section can avoid races condition:
◼If we could arrange matters such that no two processes were ever in their
critical regions at the same time, we can avoid races condition.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
3
Interprocess Communication
(Race Condition)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
4
Slots for file names
• When a process want
to print a file, it enter a
file name in a special
spooler directory in
printer
• Printer daemon
periodically check
spooler directory any file
need to be printed.
Shared variable
Interprocess Communication
(Race Condition)

Process A tried to send a job to
spooler, Process A read in = 7,
process A time out and go to ready
state before updating in = in + 1.

Process B tried to send a job to
spooler. Process B read in = 7, load
its job name in slot 7, update i = i +
1 = 8 and then go to block state for
waiting for job.

Process A is rescheduled by
scheduler. Process A already read in
= 7, Process A load its job name in
slot 7, update i = i + 1 = 9 and then
go to blocked state waiting for this
job finish.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
5
Interprocess Communication
(Race Condition)
How to avoid race condition?
Mutual exclusion – some way of making sure that if one process is using a
shared variable or file, the other processes will be excluded from doing the same
thing.
The choice of the algorithm for achieving mutual exclusion is a
major design issue in any operating system.
A solution for the race condition should have following four
conditions
1.
No two processes may be simultaneously inside their critical regions – mutual
exclusion
2.
No process running outside its critical region may block other processes
3.
No process should have to wait forever to enter critical region
4.
No assumptions may be made about speeds or the number of CPUs.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
6
' metadata={'source': '/tmp/tmpspk94gh1', 'file_path': '/tmp/tmpspk94gh1', 'page': 0, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-19 06:01:59 - INFO - Invoking chain
2024-12-19 06:02:25 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 06:02:25 - INFO - Response: {'cleaned_content': 'Date: 9/17/2024\n\nInter-Process Communication\n\n- Race Condition\n- Critical Section (or region)\n- Solutions for Mutual Exclusion in a Critical Section\n  - With Busy Waiting\n    - Disabling Interrupts – non-preemptive kernel\n    - Lock Variables – violating the first necessary condition (mutual exclusion)\n    - Strict Alternation – violating the second necessary condition (block by a process outside critical section)\n    - Peterson’s Solution\n    - Hardware Solution\n      - Test and Set Lock\n      - Memory Barriers\n      - Atomic Variable\n- Priority Inversion problems with busy waiting\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nInterprocess Communication\n\nThree issues in interprocess communication:\n1. How one process can pass information to another (communication between processes) – with IPCS (shared memory, message queue, FIFO, PIPE, socket, …)\n2. How to make sure two or more processes do not get into the critical section (mutual exclusion) – with mutex, semaphore\n3. Proper sequencing (Synchronization) when dependencies are present (e.g., A creates outputs, B consumes the outputs)\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nInterprocess Communication (Race Condition)\n\nRace Condition:\nA situation where two or more processes are reading or writing some shared data and the final result depends on who runs precisely when, is called a race condition.\n\nCritical Section (Critical Region):\nThe part of the program where the shared memory is accessed.\n\nMutual Exclusion in a critical section can avoid race conditions:\nIf we could arrange matters such that no two processes were ever in their critical regions at the same time, we can avoid race conditions.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nSlots for file names:\nWhen a process wants to print a file, it enters a file name in a special spooler directory in the printer. The printer daemon periodically checks the spooler directory for any file that needs to be printed.\n\nShared Variable\n\nInterprocess Communication (Race Condition):\nProcess A tries to send a job to the spooler. Process A reads in = 7, process A times out and goes to ready state before updating in = in + 1.\nProcess B tries to send a job to the spooler. Process B reads in = 7, loads its job name in slot 7, updates i = i + 1 = 8, and then goes to block state waiting for the job.\nProcess A is rescheduled by the scheduler. Process A already read in = 7, Process A loads its job name in slot 7, updates i = i + 1 = 9, and then goes to blocked state waiting for this job to finish.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nInterprocess Communication (Race Condition):\nHow to avoid race condition?\nMutual exclusion – some way of making sure that if one process is using a shared variable or file, the other processes will be excluded from doing the same thing.\nThe choice of the algorithm for achieving mutual exclusion is a major design issue in any operating system.\nA solution for the race condition should have the following four conditions:\n1. No two processes may be simultaneously inside their critical regions – mutual exclusion.\n2. No process running outside its critical region may block other processes.\n3. No process should have to wait forever to enter the critical region.\n4. No assumptions may be made about speeds or the number of CPUs.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park'}
2024-12-19 06:02:25 - INFO - Finished clean_files_chain
2024-12-19 06:02:25 - INFO - Successfully cleaned document 1 from 450Slides10.pdf
2024-12-19 06:02:25 - INFO - Document 2 (450Slides10.pdf) of 5
2024-12-19 06:02:25 - INFO - Starting clean_files_chain
2024-12-19 06:02:25 - INFO - Document: page_content='9/17/2024
2
Interprocess Communication
(Race Condition)
Two approaches for mutual exclusion solutions.
◼Busy wait – A process will wait until resource become available
or CPU time term expired.
◼Sleep and Wakeup – A process check a resource, if not available
go to sleep. When the resource become available, the process
will be waked up by system or the process release the resource.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
7
Mutual Exclusion with Busy Waiting
Each process has time term. A process keep checking the
possibility to get into critical section.
Mutual Exclusion with Busy Waiting
◼Disabling Interrupts –non-preemptive kernel
◼Lock Variables
◼Strict Alternation
◼Peterson’s Solution
◼Hardware Solutions
Test and Set Lock
Memory Barriers
Atomic Variable
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
8
Mutual Exclusion with Busy Waiting
(Disabling Interrupt – Nonprimitive Kernel)
Disabling Interrupt
Once a process get into the critical section, interrupts set to disable.
Other process cannot get CPU time until the process finish its job in
the critical section.
Since each user process has power to control interrupt, it might
cause the end of system.
We can build a simple program which can disable entire system
since user has control system interrupt. (vulnerable system)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
9
Mutual Exclusion with Busy Waiting
(Disabling Interrupt – Nonprimitive Kernel)
Ex) End of the system with Disabling interrupt
1. A process get into the critical section.
2. It make disable all the interrupts – which means all
other process are sleeping until the job is done in the
critical section.
3. The process has blocked outside critical section just
before make enable all the interrupts and never return
again, cause end of the system.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
10
Mutual Exclusion with Busy Waiting
(Using Lock Variable)
There are variable called “Lock”
◼A process can enter in its critical section when Lock = 0.
◼Lock =0 means no process is currently running in the critical
section, set Lock =1 and enter in the critical section.
◼Once a process finish its job in critical section, set Lock = 0 and
let other process in the critical section
◼Lock = 1 means there is a process running in the critical section,
a process do busy waiting until Lock become 0.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
11
Mutual Exclusion with Busy Waiting
(Using Lock Variable)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
12
static int lock = 0; //lock variable is initially 0
repeat
while lock 0do
; (no-operation) // Busy waiting
lock = 1;
lock = 0;
until false
Critical Section
Remainder Section
' metadata={'source': '/tmp/tmpspk94gh1', 'file_path': '/tmp/tmpspk94gh1', 'page': 1, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-19 06:02:25 - INFO - Invoking chain
2024-12-19 06:02:39 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 06:02:39 - INFO - Response: {'cleaned_content': '9/17/2024\n\nInterprocess Communication (Race Condition)\n\nTwo approaches for mutual exclusion solutions:\n1. Busy wait – A process will wait until the resource becomes available or CPU time term expires.\n2. Sleep and Wakeup – A process checks a resource; if not available, it goes to sleep. When the resource becomes available, the process will be woken up by the system or the process releases the resource.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting\n\nEach process has a time term. A process keeps checking the possibility to get into the critical section. \n\nMutual Exclusion with Busy Waiting methods include:\n- Disabling Interrupts – non-preemptive kernel\n- Lock Variables\n- Strict Alternation\n- Peterson’s Solution\n- Hardware Solutions\n\nAdditional hardware solutions include:\n- Test and Set Lock\n- Memory Barriers\n- Atomic Variable\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Disabling Interrupt – Non-preemptive Kernel)\n\nDisabling Interrupt:\n- Once a process gets into the critical section, interrupts are set to disable.\n- Other processes cannot get CPU time until the process finishes its job in the critical section.\n- Since each user process has the power to control interrupts, it might cause the end of the system.\n- We can build a simple program that can disable the entire system since the user has control over system interrupts (vulnerable system).\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nExample: End of the system with Disabling Interrupt:\n1. A process gets into the critical section.\n2. It disables all the interrupts, meaning all other processes are sleeping until the job is done in the critical section.\n3. The process gets blocked outside the critical section just before enabling all the interrupts and never returns again, causing the end of the system.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Using Lock Variable)\n\nThere is a variable called "Lock":\n- A process can enter its critical section when Lock = 0.\n- Lock = 0 means no process is currently running in the critical section; the process sets Lock = 1 and enters the critical section.\n- Once a process finishes its job in the critical section, it sets Lock = 0 and lets other processes enter the critical section.\n- Lock = 1 means there is a process running in the critical section; a process will do busy waiting until Lock becomes 0.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nCode example using Lock Variable:\nstatic int lock = 0; // lock variable is initially 0\nrepeat\n  while lock == 0 do\n    ; // Busy waiting\n  lock = 1;\n  lock = 0;\nuntil false\n\nCritical Section\nRemainder Section'}
2024-12-19 06:02:39 - INFO - Finished clean_files_chain
2024-12-19 06:02:39 - INFO - Successfully cleaned document 2 from 450Slides10.pdf
2024-12-19 06:02:39 - INFO - Document 3 (450Slides10.pdf) of 5
2024-12-19 06:02:39 - INFO - Starting clean_files_chain
2024-12-19 06:02:39 - INFO - Document: page_content='9/17/2024
3
Mutual Exclusion with Busy Waiting
(Using Lock Variable)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
13
static int lock = 0; //lock is initially 0
repeat
while lock 0 do
; (no-operation) //busy waiting
lock = 1;
lock = 0;
until false
Critical Section
Remainder Section
Scenario)
1.
Initially lock = 0.
2.
A process P1 tries get into critical section.
The process P1 check lock value = 0.
3.
Process P1 CPU time is over and go to
ready state, before updating lock = 1.
4.
Process P2 tries get into critical section.
P2 check lock value lock = 0
5.
P2 set lock = 1 and go to critical section.
6.
P2 CPU time is over and P1 is rescheduled.
7.
P1 already read lock = 0, P1 set lock = 1
and go to Critical section. Now P1 and P2
are in the critical section at the same
time
Violating condition #1: mutual exclusion
Mutual Exclusion with Busy Waiting
(Strict Alternation)
Variable turn can be i or j.
if turn = i, process Pi can go to the
critical section.
Once Pi finish its job in critical
section, Pi set turn = j, let process
Pj enter critical section
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
14
Critical Section
Remainder Section
turn is i or j
repeat
while turn i do
; (no-operation)
turn = j;
until false
Mutual Exclusion with Busy Waiting
(Strict Alternation)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
15
Critical Section
Remainder Section
turn is i or j
repeat
while turn i do
; (no-operation)
turn = j;
until false
Let assume initially turn = 0
1.
P0 is in CS while P1 is in remaining
section.
2.
P0 done C.S. and set turn = 1, P1 is
still in remaining section.
3.
P0 done remaining section and want
to go to C.S. but turn= 1.
4.
P1 has fatal error in remainder
section and trapped out by OS.
5.
P0 is waiting forever to enter the C.S.
Violating #2 and #3 condition
2.
No process running outside its critical
region may block other processes
3.
No process should have to wait forever to
enter critical region
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
Peterson’s solution provides a good algorithmic description of
solving the critical-section problem and illustrates some of the
complexities involved in designing software that addresses the
requirements of mutual exclusion, progress, and bounded waiting.
Peterson’s solution is restricted to two processes that alternate
execution between their critical sections and remainder sections.
The processes are numbered P0 and P1.
For convenience, when presenting Pi, we use Pj to denote the other
process; that is, j equals 1 −i.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
16
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
17
#define false 0
#define true 1
#define n 2
int turn
int interested[n]
void enter_region(int process);
{
int other;
other = 1 – process
interested[process] = true
turn = process;
while (turn ==process && interest[other]==true)
; /*no operation –busy waiting*/
}
void leave_region(int process)
{
interest[process] = false;
}
void main()
{
repeat
enter_region (int i)
Critical Section
leave_resion (int i)
Remainder Section
until false
}
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
1.
Initially, neither process is in the critical section
2.
A process P0 call enter_region (0)
a)
Set interested[0] = true;
b)
Set turn = 0
3.
go to critical section
4.
the process P1 call enter_region(1) to get into its critical section
a)
set interested[1] = true;
b)
set turn = 1;
5.
since interested[0] = true, it is keep looping for interest [0] =
false
6.
finally process P0 finish its critical section and call leave_region(0)
1.
set interested[0] = false
7.
now P1 find out interest[0] = false, P1 goes to its critical section
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
18
' metadata={'source': '/tmp/tmpspk94gh1', 'file_path': '/tmp/tmpspk94gh1', 'page': 2, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-19 06:02:39 - INFO - Invoking chain
2024-12-19 06:02:52 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 06:02:52 - INFO - Response: {'cleaned_content': "9/17/2024\n\nMutual Exclusion with Busy Waiting (Using Lock Variable)\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nstatic int lock = 0; // lock is initially 0\nrepeat\n    while lock == 0 do\n        ; // (no-operation) // busy waiting\n    lock = 1;\n    lock = 0;\nuntil false\n\nCritical Section\nRemainder Section\n\nScenario:\n1. Initially, lock = 0.\n2. A process P1 tries to get into the critical section.\n   - The process P1 checks lock value = 0.\n3. Process P1's CPU time is over and goes to ready state, before updating lock = 1.\n4. Process P2 tries to get into the critical section.\n   - P2 checks lock value lock = 0.\n5. P2 sets lock = 1 and goes to the critical section.\n6. P2's CPU time is over and P1 is rescheduled.\n7. P1 already read lock = 0, P1 sets lock = 1 and goes to the critical section. Now P1 and P2 are in the critical section at the same time.\n   - Violating condition #1: mutual exclusion\n\nMutual Exclusion with Busy Waiting (Strict Alternation)\n- Variable turn can be i or j.\n- If turn = i, process Pi can go to the critical section.\n- Once Pi finishes its job in the critical section, Pi sets turn = j, letting process Pj enter the critical section.\n\nCritical Section\nRemainder Section\n\nturn is i or j\nrepeat\n    while turn == i do\n        ; // (no-operation)\n    turn = j;\nuntil false\n\nLet us assume initially turn = 0:\n1. P0 is in the critical section while P1 is in the remainder section.\n2. P0 finishes the critical section and sets turn = 1, P1 is still in the remainder section.\n3. P0 finishes the remainder section and wants to go to the critical section but turn = 1.\n4. P1 has a fatal error in the remainder section and is trapped out by the OS.\n5. P0 is waiting forever to enter the critical section.\n   - Violating conditions #2 and #3:\n     2. No process running outside its critical region may block other processes.\n     3. No process should have to wait forever to enter the critical region.\n\nMutual Exclusion with Busy Waiting (Peterson’s Solution)\n- Peterson’s solution provides a good algorithmic description of solving the critical-section problem and illustrates some of the complexities involved in designing software that addresses the requirements of mutual exclusion, progress, and bounded waiting.\n- Peterson’s solution is restricted to two processes that alternate execution between their critical sections and remainder sections.\n- The processes are numbered P0 and P1.\n- For convenience, when presenting Pi, we use Pj to denote the other process; that is, j equals 1 - i.\n\n#define false 0\n#define true 1\n#define n 2\nint turn;\nint interested[n];\n\nvoid enter_region(int process) {\n    int other;\n    other = 1 - process;\n    interested[process] = true;\n    turn = process;\n    while (turn == process && interested[other] == true)\n        ; // no operation – busy waiting\n}\n\nvoid leave_region(int process) {\n    interested[process] = false;\n}\n\nvoid main() {\n    repeat\n        enter_region(int i);\n        Critical Section;\n        leave_region(int i);\n        Remainder Section;\n    until false;\n}\n\nMutual Exclusion with Busy Waiting (Peterson’s Solution)\n1. Initially, neither process is in the critical section.\n2. A process P0 calls enter_region(0):\n   a) Set interested[0] = true;\n   b) Set turn = 0;\n3. Go to the critical section.\n4. The process P1 calls enter_region(1) to get into its critical section:\n   a) Set interested[1] = true;\n   b) Set turn = 1;\n5. Since interested[0] = true, it keeps looping for interested[0] = false.\n6. Finally, process P0 finishes its critical section and calls leave_region(0):\n   a) Set interested[0] = false;\n7. Now P1 finds out interested[0] = false, P1 goes to its critical section."}
2024-12-19 06:02:52 - INFO - Finished clean_files_chain
2024-12-19 06:02:52 - INFO - Successfully cleaned document 3 from 450Slides10.pdf
2024-12-19 06:02:52 - INFO - Document 4 (450Slides10.pdf) of 5
2024-12-19 06:02:52 - INFO - Starting clean_files_chain
2024-12-19 06:02:52 - INFO - Document: page_content='9/17/2024
4
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
Prove for Peterson’s Solution)

Lets consider the case both P0 and P1 call enter_region(0) and enter_region(1) almost
simultaneously.

Lets interest[0]= true and interest[1] = true at the same time

But turn can be only turn = 0 or turn = 1 which ever store is done last is the one that
counts!!
Case 1) turn = 0
Inside enter_region(0)
◼
Since turn =0 and interest [1] = ture, P0 keep looping in no-operation until P1 set interested[1] =
false.
Inside enter_region(1)
◼
Since turn = 0 and interest[0] = true, P1 goes to its critical section.
Case 2) turn = 1
Inside enter_region(0)
◼
Since turn =1 and interest [1] = ture,. P0 goes to its critical section
Inside enter_region(1)
◼
Since turn = 1 and interest[0] = true, P1 keep looping in no-operation until P0 set interested[0] =
false.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
19
Mutual Exclusion with Busy Waiting
(Test and Set Lock – hardware solution)

Since TSL instruction is a hardware instruction. The operations of reading the
lock and storing into register are guaranteed to be indivisible.

Instruction test and set lock
TSL RX, LOCK
1. Read the content at the memory address of LOCK into register RX.
2. Store a non-zero value at the memory address of LOCK

The operations of reading the content of LOCK and storing into it are guaranteed
to be indivisible.

How to use Test and Set Lock instruction for solving race condition?
◼
When LOCK = 0, any process may set LOCK = 1 by using TSL instruction and go to
its critical section.
◼
When the process finish its critical section, set LOCK = 0 using the original move
instruction.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
20
Mutual Exclusion with Busy Waiting
(Test and Set Lock – hardware solution)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
21
Enter_region
TSL Register, LOCK
CMP Register, #0
JNE Enter_region
Set LOCK, #1
RET
Leave_region
MOVE LOCK, #0
RET
Repeat
Enter_region
Leave_region
until false
Critical Section
Remainder Section
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
Two general memory models
◼Strongly ordered Memory –a memory modification on one processor is
immediately visible to all other processors
◼Weakly ordered Memory – a memory modification on one processor may not
be immediately visible to other processors.
With Strongly ordered memory, computer architectures provide
instructions that can force any changes in memory to be
propagated to all other processors, thereby ensuring that memory
modifications are visible to threads (or processes) running on other
processors.
Such instructions are known as memory barriers or memory
fences.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
22
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
A memory barrier is a type of barrier instruction that causes a
central processing unit (CPU) or compiler to enforce an ordering
constraint on memory operations issued before and after the
barrier instruction.
This typically means that operations issued prior to the barrier are
guaranteed to be performed before operations issued after the
barrier.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
23
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
Ex)
Lets assume two threads (or processes) are running on different
part of program by sharing two variables. (bool flag = false; int x=0;)
Thread 1 might print 0 or 100 depends on the order of execution.
By using memory barrier instruction Thread1 always print 100.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
24
while (!flag)
print x;
x = 100
flag = true;
Thread 1
Thread 2
' metadata={'source': '/tmp/tmpspk94gh1', 'file_path': '/tmp/tmpspk94gh1', 'page': 3, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-19 06:02:52 - INFO - Invoking chain
2024-12-19 06:03:11 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 06:03:11 - INFO - Response: {'cleaned_content': '9/17/2024\n\nMutual Exclusion with Busy Waiting (Peterson’s Solution)\n\nLet’s consider the case where both P0 and P1 call enter_region(0) and enter_region(1) almost simultaneously.\n\nLet interest[0] = true and interest[1] = true at the same time. But turn can only be turn = 0 or turn = 1; whichever store is done last is the one that counts!\n\nCase 1: turn = 0\nInside enter_region(0):\n- Since turn = 0 and interest[1] = true, P0 keeps looping in a no-operation until P1 sets interest[1] = false.\n\nInside enter_region(1):\n- Since turn = 0 and interest[0] = true, P1 goes to its critical section.\n\nCase 2: turn = 1\nInside enter_region(0):\n- Since turn = 1 and interest[1] = true, P0 goes to its critical section.\n\nInside enter_region(1):\n- Since turn = 1 and interest[0] = true, P1 keeps looping in a no-operation until P0 sets interest[0] = false.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Test and Set Lock – hardware solution)\n\nSince the Test and Set Lock (TSL) instruction is a hardware instruction, the operations of reading the lock and storing into a register are guaranteed to be indivisible.\n\nInstruction: test and set lock\nTSL RX, LOCK\n1. Read the content at the memory address of LOCK into register RX.\n2. Store a non-zero value at the memory address of LOCK.\n\nThe operations of reading the content of LOCK and storing into it are guaranteed to be indivisible.\n\nHow to use the Test and Set Lock instruction for solving race conditions:\n- When LOCK = 0, any process may set LOCK = 1 by using the TSL instruction and go to its critical section.\n- When the process finishes its critical section, it sets LOCK = 0 using the original move instruction.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nEnter_region:\nTSL Register, LOCK\nCMP Register, #0\nJNE Enter_region\nSet LOCK, #1\nRET\n\nLeave_region:\nMOVE LOCK, #0\nRET\n\nRepeat:\nEnter_region\nLeave_region until false\n\nCritical Section\nRemainder Section\n\nMutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)\n\nThere are two general memory models:\n- Strongly ordered Memory: A memory modification on one processor is immediately visible to all other processors.\n- Weakly ordered Memory: A memory modification on one processor may not be immediately visible to other processors.\n\nWith strongly ordered memory, computer architectures provide instructions that can force any changes in memory to be propagated to all other processors, thereby ensuring that memory modifications are visible to threads (or processes) running on other processors.\n\nSuch instructions are known as memory barriers or memory fences.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nA memory barrier is a type of barrier instruction that causes a central processing unit (CPU) or compiler to enforce an ordering constraint on memory operations issued before and after the barrier instruction.\n\nThis typically means that operations issued prior to the barrier are guaranteed to be performed before operations issued after the barrier.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nExample:\nLet’s assume two threads (or processes) are running on different parts of the program by sharing two variables: (bool flag = false; int x = 0;)\n- Thread 1 might print 0 or 100 depending on the order of execution.\n- By using the memory barrier instruction, Thread 1 always prints 100.\n\nwhile (!flag)\n    print x;\n    x = 100;\n    flag = true;\n\nThread 1\nThread 2\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park'}
2024-12-19 06:03:11 - INFO - Finished clean_files_chain
2024-12-19 06:03:11 - INFO - Successfully cleaned document 4 from 450Slides10.pdf
2024-12-19 06:03:11 - INFO - Document 5 (450Slides10.pdf) of 5
2024-12-19 06:03:11 - INFO - Starting clean_files_chain
2024-12-19 06:03:11 - INFO - Document: page_content='9/17/2024
5
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
Now it is guarantee that the value of flag is loaded before the value of x
Also it is guarantee that assignment to x occurs before the assignment to flag.
So Thread 1 always print 100
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
25
while (!flag)
memory_barrier();
print x;
x = 100;
memory_barrier();
flag = true;
Thread 1
Thread 2
Mutual Exclusion with Busy Waiting
(Atomic Variables– hardware solution)
We can avoid mutual exclusion by using atomic operations.
When a thread (or process) performs an atomic operation, the
other threads (or process) see it as happening instantaneously.
The advantage of atomic operations is that they are relatively quick
compared to locks, and do not suffer from deadlock and convoying.
The disadvantage is that they only do a limited set of operations,
and often these are not enough to synthesize more complicated
operations efficiently.
But nonetheless you should not pass up an opportunity to use an
atomic operation in place of mutual exclusion.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
26
Mutual Exclusion with Busy Waiting
(Priority Inversion Problem)
Peterson's solution, test and set lock, Memory Barrier, Atomic variable method –
busy waiting – (wasting CPU time)
Priority Inversion problem with busy waiting method
A computer with two processes PH with high priorities, and PL with low priorities.
The scheduling rules are such that PH get CPU time whenever it is in ready state.
(preemptive priority scheduling)
1. At a time T0: PL is in critical section, and PH is in block state.
2. At a time T1: PH change sate from block to ready state and try to enter the critical
section. PL still in critical section.
3. Based on scheduling rule, short-term scheduler select PH, PH hold CPU and try to enter
into critical section.
4. Since PL is in critical section, PH run busy waiting outside critical section forever since
PL does not have a chance to get CPU time to finish its critical section.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
27
Mutual Exclusion with Busy Waiting
(Priority Inversion Problem)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
28
Block
Running
Ready
T0 :
PL: running state in critical section
PH: block state
PH
PL
Block
Running
Ready
PH
PL
T1 : PH become ready state
PL: ready state in critical section
PH: ready state
CPU scheduler will select higher
priority process
Block
Running
Ready
PH
PL
Ti>1
PL: ready state in critical section
PH: busy waiting in running state
PH become ready state
Scheduler keep selecting
PH since higher priority
The scheduling rules : CPU scheduler will always select higher priority process.
' metadata={'source': '/tmp/tmpspk94gh1', 'file_path': '/tmp/tmpspk94gh1', 'page': 4, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-19 06:03:11 - INFO - Invoking chain
2024-12-19 06:03:21 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 06:03:21 - INFO - Response: {'cleaned_content': "Date: 9/17/2024\n\n# Mutual Exclusion with Busy Waiting\n## Memory Barriers – Hardware Solution\n- It is guaranteed that the value of flag is loaded before the value of x.\n- It is also guaranteed that the assignment to x occurs before the assignment to flag.\n- Therefore, Thread 1 will always print 100.\n\n### Code Snippet:\nwhile (!flag) {\n    memory_barrier();\n}\nprint x;\n x = 100;\n memory_barrier();\nflag = true;\n\n### Thread 1\n### Thread 2\n\n## Mutual Exclusion with Busy Waiting\n### Atomic Variables – Hardware Solution\n- We can avoid mutual exclusion by using atomic operations.\n- When a thread (or process) performs an atomic operation, other threads (or processes) see it as happening instantaneously.\n- The advantage of atomic operations is that they are relatively quick compared to locks and do not suffer from deadlock and convoying.\n- The disadvantage is that they only perform a limited set of operations, which are often insufficient for synthesizing more complicated operations efficiently.\n- Nonetheless, you should not miss the opportunity to use an atomic operation in place of mutual exclusion.\n\n## Mutual Exclusion with Busy Waiting\n### Priority Inversion Problem\n- Various methods like Peterson's solution, test and set lock, memory barrier, and atomic variable method result in busy waiting (wasting CPU time).\n- The priority inversion problem occurs with busy waiting methods.\n- Consider a computer with two processes: PH (high priority) and PL (low priority).\n- The scheduling rules dictate that PH gets CPU time whenever it is in the ready state (preemptive priority scheduling).\n\n### Example Scenario:\n1. At time T0: PL is in the critical section, and PH is in a blocked state.\n2. At time T1: PH changes state from blocked to ready and tries to enter the critical section. PL is still in the critical section.\n3. Based on scheduling rules, the short-term scheduler selects PH, who holds the CPU and tries to enter the critical section.\n4. Since PL is in the critical section, PH runs busy waiting outside the critical section indefinitely as PL does not get a chance to finish its critical section and receive CPU time.\n\n## Priority Inversion Problem Illustration\n- At T0:\n  - PL: running state in critical section\n  - PH: blocked state\n\n- At T1:\n  - PH: becomes ready state\n  - PL: ready state in critical section\n  - PH: ready state\n\n- The CPU scheduler will select the higher priority process.\n\n- After T1:\n  - PL: ready state in critical section\n  - PH: busy waiting in running state\n- PH remains in a ready state while the scheduler keeps selecting PH due to its higher priority.\n\n### Note:\nThe scheduling rules specify that the CPU scheduler will always select the higher priority process."}
2024-12-19 06:03:21 - INFO - Finished clean_files_chain
2024-12-19 06:03:21 - INFO - Successfully cleaned document 5 from 450Slides10.pdf
2024-12-19 06:03:21 - INFO - Pages: []
2024-12-19 06:03:21 - INFO - Full response: Date: 9/17/2024

Inter-Process Communication

- Race Condition
- Critical Section (or region)
- Solutions for Mutual Exclusion in a Critical Section
  - With Busy Waiting
    - Disabling Interrupts – non-preemptive kernel
    - Lock Variables – violating the first necessary condition (mutual exclusion)
    - Strict Alternation – violating the second necessary condition (block by a process outside critical section)
    - Peterson’s Solution
    - Hardware Solution
      - Test and Set Lock
      - Memory Barriers
      - Atomic Variable
- Priority Inversion problems with busy waiting

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Interprocess Communication

Three issues in interprocess communication:
1. How one process can pass information to another (communication between processes) – with IPCS (shared memory, message queue, FIFO, PIPE, socket, …)
2. How to make sure two or more processes do not get into the critical section (mutual exclusion) – with mutex, semaphore
3. Proper sequencing (Synchronization) when dependencies are present (e.g., A creates outputs, B consumes the outputs)

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Interprocess Communication (Race Condition)

Race Condition:
A situation where two or more processes are reading or writing some shared data and the final result depends on who runs precisely when, is called a race condition.

Critical Section (Critical Region):
The part of the program where the shared memory is accessed.

Mutual Exclusion in a critical section can avoid race conditions:
If we could arrange matters such that no two processes were ever in their critical regions at the same time, we can avoid race conditions.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Slots for file names:
When a process wants to print a file, it enters a file name in a special spooler directory in the printer. The printer daemon periodically checks the spooler directory for any file that needs to be printed.

Shared Variable

Interprocess Communication (Race Condition):
Process A tries to send a job to the spooler. Process A reads in = 7, process A times out and goes to ready state before updating in = in + 1.
Process B tries to send a job to the spooler. Process B reads in = 7, loads its job name in slot 7, updates i = i + 1 = 8, and then goes to block state waiting for the job.
Process A is rescheduled by the scheduler. Process A already read in = 7, Process A loads its job name in slot 7, updates i = i + 1 = 9, and then goes to blocked state waiting for this job to finish.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Interprocess Communication (Race Condition):
How to avoid race condition?
Mutual exclusion – some way of making sure that if one process is using a shared variable or file, the other processes will be excluded from doing the same thing.
The choice of the algorithm for achieving mutual exclusion is a major design issue in any operating system.
A solution for the race condition should have the following four conditions:
1. No two processes may be simultaneously inside their critical regions – mutual exclusion.
2. No process running outside its critical region may block other processes.
3. No process should have to wait forever to enter the critical region.
4. No assumptions may be made about speeds or the number of CPUs.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park9/17/2024

Interprocess Communication (Race Condition)

Two approaches for mutual exclusion solutions:
1. Busy wait – A process will wait until the resource becomes available or CPU time term expires.
2. Sleep and Wakeup – A process checks a resource; if not available, it goes to sleep. When the resource becomes available, the process will be woken up by the system or the process releases the resource.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting

Each process has a time term. A process keeps checking the possibility to get into the critical section. 

Mutual Exclusion with Busy Waiting methods include:
- Disabling Interrupts – non-preemptive kernel
- Lock Variables
- Strict Alternation
- Peterson’s Solution
- Hardware Solutions

Additional hardware solutions include:
- Test and Set Lock
- Memory Barriers
- Atomic Variable

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Disabling Interrupt – Non-preemptive Kernel)

Disabling Interrupt:
- Once a process gets into the critical section, interrupts are set to disable.
- Other processes cannot get CPU time until the process finishes its job in the critical section.
- Since each user process has the power to control interrupts, it might cause the end of the system.
- We can build a simple program that can disable the entire system since the user has control over system interrupts (vulnerable system).

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Example: End of the system with Disabling Interrupt:
1. A process gets into the critical section.
2. It disables all the interrupts, meaning all other processes are sleeping until the job is done in the critical section.
3. The process gets blocked outside the critical section just before enabling all the interrupts and never returns again, causing the end of the system.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Using Lock Variable)

There is a variable called "Lock":
- A process can enter its critical section when Lock = 0.
- Lock = 0 means no process is currently running in the critical section; the process sets Lock = 1 and enters the critical section.
- Once a process finishes its job in the critical section, it sets Lock = 0 and lets other processes enter the critical section.
- Lock = 1 means there is a process running in the critical section; a process will do busy waiting until Lock becomes 0.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Code example using Lock Variable:
static int lock = 0; // lock variable is initially 0
repeat
  while lock == 0 do
    ; // Busy waiting
  lock = 1;
  lock = 0;
until false

Critical Section
Remainder Section9/17/2024

Mutual Exclusion with Busy Waiting (Using Lock Variable)
COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

static int lock = 0; // lock is initially 0
repeat
    while lock == 0 do
        ; // (no-operation) // busy waiting
    lock = 1;
    lock = 0;
until false

Critical Section
Remainder Section

Scenario:
1. Initially, lock = 0.
2. A process P1 tries to get into the critical section.
   - The process P1 checks lock value = 0.
3. Process P1's CPU time is over and goes to ready state, before updating lock = 1.
4. Process P2 tries to get into the critical section.
   - P2 checks lock value lock = 0.
5. P2 sets lock = 1 and goes to the critical section.
6. P2's CPU time is over and P1 is rescheduled.
7. P1 already read lock = 0, P1 sets lock = 1 and goes to the critical section. Now P1 and P2 are in the critical section at the same time.
   - Violating condition #1: mutual exclusion

Mutual Exclusion with Busy Waiting (Strict Alternation)
- Variable turn can be i or j.
- If turn = i, process Pi can go to the critical section.
- Once Pi finishes its job in the critical section, Pi sets turn = j, letting process Pj enter the critical section.

Critical Section
Remainder Section

turn is i or j
repeat
    while turn == i do
        ; // (no-operation)
    turn = j;
until false

Let us assume initially turn = 0:
1. P0 is in the critical section while P1 is in the remainder section.
2. P0 finishes the critical section and sets turn = 1, P1 is still in the remainder section.
3. P0 finishes the remainder section and wants to go to the critical section but turn = 1.
4. P1 has a fatal error in the remainder section and is trapped out by the OS.
5. P0 is waiting forever to enter the critical section.
   - Violating conditions #2 and #3:
     2. No process running outside its critical region may block other processes.
     3. No process should have to wait forever to enter the critical region.

Mutual Exclusion with Busy Waiting (Peterson’s Solution)
- Peterson’s solution provides a good algorithmic description of solving the critical-section problem and illustrates some of the complexities involved in designing software that addresses the requirements of mutual exclusion, progress, and bounded waiting.
- Peterson’s solution is restricted to two processes that alternate execution between their critical sections and remainder sections.
- The processes are numbered P0 and P1.
- For convenience, when presenting Pi, we use Pj to denote the other process; that is, j equals 1 - i.

#define false 0
#define true 1
#define n 2
int turn;
int interested[n];

void enter_region(int process) {
    int other;
    other = 1 - process;
    interested[process] = true;
    turn = process;
    while (turn == process && interested[other] == true)
        ; // no operation – busy waiting
}

void leave_region(int process) {
    interested[process] = false;
}

void main() {
    repeat
        enter_region(int i);
        Critical Section;
        leave_region(int i);
        Remainder Section;
    until false;
}

Mutual Exclusion with Busy Waiting (Peterson’s Solution)
1. Initially, neither process is in the critical section.
2. A process P0 calls enter_region(0):
   a) Set interested[0] = true;
   b) Set turn = 0;
3. Go to the critical section.
4. The process P1 calls enter_region(1) to get into its critical section:
   a) Set interested[1] = true;
   b) Set turn = 1;
5. Since interested[0] = true, it keeps looping for interested[0] = false.
6. Finally, process P0 finishes its critical section and calls leave_region(0):
   a) Set interested[0] = false;
7. Now P1 finds out interested[0] = false, P1 goes to its critical section.9/17/2024

Mutual Exclusion with Busy Waiting (Peterson’s Solution)

Let’s consider the case where both P0 and P1 call enter_region(0) and enter_region(1) almost simultaneously.

Let interest[0] = true and interest[1] = true at the same time. But turn can only be turn = 0 or turn = 1; whichever store is done last is the one that counts!

Case 1: turn = 0
Inside enter_region(0):
- Since turn = 0 and interest[1] = true, P0 keeps looping in a no-operation until P1 sets interest[1] = false.

Inside enter_region(1):
- Since turn = 0 and interest[0] = true, P1 goes to its critical section.

Case 2: turn = 1
Inside enter_region(0):
- Since turn = 1 and interest[1] = true, P0 goes to its critical section.

Inside enter_region(1):
- Since turn = 1 and interest[0] = true, P1 keeps looping in a no-operation until P0 sets interest[0] = false.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Test and Set Lock – hardware solution)

Since the Test and Set Lock (TSL) instruction is a hardware instruction, the operations of reading the lock and storing into a register are guaranteed to be indivisible.

Instruction: test and set lock
TSL RX, LOCK
1. Read the content at the memory address of LOCK into register RX.
2. Store a non-zero value at the memory address of LOCK.

The operations of reading the content of LOCK and storing into it are guaranteed to be indivisible.

How to use the Test and Set Lock instruction for solving race conditions:
- When LOCK = 0, any process may set LOCK = 1 by using the TSL instruction and go to its critical section.
- When the process finishes its critical section, it sets LOCK = 0 using the original move instruction.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Enter_region:
TSL Register, LOCK
CMP Register, #0
JNE Enter_region
Set LOCK, #1
RET

Leave_region:
MOVE LOCK, #0
RET

Repeat:
Enter_region
Leave_region until false

Critical Section
Remainder Section

Mutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)

There are two general memory models:
- Strongly ordered Memory: A memory modification on one processor is immediately visible to all other processors.
- Weakly ordered Memory: A memory modification on one processor may not be immediately visible to other processors.

With strongly ordered memory, computer architectures provide instructions that can force any changes in memory to be propagated to all other processors, thereby ensuring that memory modifications are visible to threads (or processes) running on other processors.

Such instructions are known as memory barriers or memory fences.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

A memory barrier is a type of barrier instruction that causes a central processing unit (CPU) or compiler to enforce an ordering constraint on memory operations issued before and after the barrier instruction.

This typically means that operations issued prior to the barrier are guaranteed to be performed before operations issued after the barrier.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Example:
Let’s assume two threads (or processes) are running on different parts of the program by sharing two variables: (bool flag = false; int x = 0;)
- Thread 1 might print 0 or 100 depending on the order of execution.
- By using the memory barrier instruction, Thread 1 always prints 100.

while (!flag)
    print x;
    x = 100;
    flag = true;

Thread 1
Thread 2

COSC450 Operating System, Fall 2024
Dr. Sang-Eon ParkDate: 9/17/2024

# Mutual Exclusion with Busy Waiting
## Memory Barriers – Hardware Solution
- It is guaranteed that the value of flag is loaded before the value of x.
- It is also guaranteed that the assignment to x occurs before the assignment to flag.
- Therefore, Thread 1 will always print 100.

### Code Snippet:
while (!flag) {
    memory_barrier();
}
print x;
 x = 100;
 memory_barrier();
flag = true;

### Thread 1
### Thread 2

## Mutual Exclusion with Busy Waiting
### Atomic Variables – Hardware Solution
- We can avoid mutual exclusion by using atomic operations.
- When a thread (or process) performs an atomic operation, other threads (or processes) see it as happening instantaneously.
- The advantage of atomic operations is that they are relatively quick compared to locks and do not suffer from deadlock and convoying.
- The disadvantage is that they only perform a limited set of operations, which are often insufficient for synthesizing more complicated operations efficiently.
- Nonetheless, you should not miss the opportunity to use an atomic operation in place of mutual exclusion.

## Mutual Exclusion with Busy Waiting
### Priority Inversion Problem
- Various methods like Peterson's solution, test and set lock, memory barrier, and atomic variable method result in busy waiting (wasting CPU time).
- The priority inversion problem occurs with busy waiting methods.
- Consider a computer with two processes: PH (high priority) and PL (low priority).
- The scheduling rules dictate that PH gets CPU time whenever it is in the ready state (preemptive priority scheduling).

### Example Scenario:
1. At time T0: PL is in the critical section, and PH is in a blocked state.
2. At time T1: PH changes state from blocked to ready and tries to enter the critical section. PL is still in the critical section.
3. Based on scheduling rules, the short-term scheduler selects PH, who holds the CPU and tries to enter the critical section.
4. Since PL is in the critical section, PH runs busy waiting outside the critical section indefinitely as PL does not get a chance to finish its critical section and receive CPU time.

## Priority Inversion Problem Illustration
- At T0:
  - PL: running state in critical section
  - PH: blocked state

- At T1:
  - PH: becomes ready state
  - PL: ready state in critical section
  - PH: ready state

- The CPU scheduler will select the higher priority process.

- After T1:
  - PL: ready state in critical section
  - PH: busy waiting in running state
- PH remains in a ready state while the scheduler keeps selecting PH due to its higher priority.

### Note:
The scheduling rules specify that the CPU scheduler will always select the higher priority process.
2024-12-19 06:03:21 - INFO - Processing pages: 0, full_response: Yes
2024-12-19 06:03:21 - INFO - Created 1 tasks for question generation
2024-12-19 06:03:21 - INFO - Starting question_generate_chain
2024-12-19 06:03:21 - INFO - Setting up question generation chain
2024-12-19 06:03:21 - INFO - Chain type: <class 'langchain_core.runnables.base.RunnableSequence'>
2024-12-19 06:03:21 - INFO - Question generation chain setup complete
2024-12-19 06:03:33 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 06:03:33 - INFO - Generated 5 questions for Operating Systems with the following questions: [QAPair(question='Which of the following is a method used for achieving mutual exclusion in a critical section?', answer='Peterson’s Solution', q_type='multiple_choice', choices=['Semaphore', 'Peterson’s Solution', 'Thread Pooling', 'Mutex Locking']), QAPair(question='In a busy waiting scenario, a process will keep checking until a resource becomes available. This statement is:', answer='True', q_type='TF', choices=['True', 'False']), QAPair(question='What are the four conditions that a solution for a race condition must satisfy?', answer='1. No two processes may be simultaneously inside their critical regions (mutual exclusion). 2. No process running outside its critical region may block other processes. 3. No process should have to wait forever to enter the critical region. 4. No assumptions may be made about speeds or the number of CPUs.', q_type='written', choices=[]), QAPair(question='A situation where two or more processes are reading or writing shared data and the final result depends on the order of execution is known as a:', answer='True', q_type='TF', choices=['True', 'False']), QAPair(question='What is the significant difference between disabling interrupts and using lock variables in achieving mutual exclusion?', answer='Disabling interrupts can lead to system vulnerability while lock variables may cause busy waiting.', q_type='multiple_choice', choices=['Both methods are equally secure.', 'Disabling interrupts can lead to system vulnerability while lock variables may cause busy waiting.', 'Lock variables are always more efficient than disabling interrupts.', 'Disabling interrupts is a more modern approach compared to lock variables.'])]
2024-12-19 06:03:33 - INFO - Finished question_generate_chain
2024-12-19 06:03:33 - INFO - Completed question generation. Number of results: 1
2024-12-19 06:03:33 - INFO - Generated test list with 1 tests
2024-12-19 06:03:33 - INFO - Preparing judge_kwargs with 9 parameters
2024-12-19 06:03:33 - INFO - FINAL TEST:
{
    "questions": [
        {
            "question": "Which of the following is a method used for achieving mutual exclusion in a critical section?",
            "answer": "Peterson\u2019s Solution",
            "q_type": "multiple_choice",
            "choices": [
                "Semaphore",
                "Peterson\u2019s Solution",
                "Thread Pooling",
                "Mutex Locking"
            ]
        },
        {
            "question": "In a busy waiting scenario, a process will keep checking until a resource becomes available. This statement is:",
            "answer": "True",
            "q_type": "TF",
            "choices": [
                "True",
                "False"
            ]
        },
        {
            "question": "What are the four conditions that a solution for a race condition must satisfy?",
            "answer": "1. No two processes may be simultaneously inside their critical regions (mutual exclusion). 2. No process running outside its critical region may block other processes. 3. No process should have to wait forever to enter the critical region. 4. No assumptions may be made about speeds or the number of CPUs.",
            "q_type": "written",
            "choices": []
        },
        {
            "question": "A situation where two or more processes are reading or writing shared data and the final result depends on the order of execution is known as a:",
            "answer": "True",
            "q_type": "TF",
            "choices": [
                "True",
                "False"
            ]
        },
        {
            "question": "What is the significant difference between disabling interrupts and using lock variables in achieving mutual exclusion?",
            "answer": "Disabling interrupts can lead to system vulnerability while lock variables may cause busy waiting.",
            "q_type": "multiple_choice",
            "choices": [
                "Both methods are equally secure.",
                "Disabling interrupts can lead to system vulnerability while lock variables may cause busy waiting.",
                "Lock variables are always more efficient than disabling interrupts.",
                "Disabling interrupts is a more modern approach compared to lock variables."
            ]
        }
    ]
}
2024-12-19 06:03:33 - INFO - All tasks completed. Number of results: 1
2024-12-19 06:03:33 - INFO - Generated 1 tests
2024-12-19 06:03:33 - INFO - Cleaning up temp files
2024-12-19 06:03:33 - INFO - Deleted temp file: /tmp/tmpspk94gh1
2024-12-19 06:03:33 - INFO - Temp files cleaned
2024-12-19 06:03:33 - INFO - Run function completed
2024-12-19 06:03:33 - INFO - Test generated successfully
2024-12-19 06:05:10 - INFO - POST request received for /generate
2024-12-19 06:05:10 - INFO - Form data: title='Operating Systems Test 1' course='Operating Systems' professor='Dr. Park' number_of_written_questions=1 number_of_mcq_questions=2 number_of_TF_questions=2 level='Normal' school_type='Undergraduate' difficulty='Extreme' testing_philosophy='I like to give them the hardest possible challenge so they study more and learn more :)' url_1=None url_2=None subject_material=[UploadFile(filename='450Slides10.pdf', size=166799, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides10.pdf"', 'content-type': 'application/pdf'}))]
2024-12-19 06:05:10 - INFO - Starting run function
2024-12-19 06:05:10 - INFO - Form data accessed
2024-12-19 06:05:10 - INFO - Form Title: Operating Systems Test 1
2024-12-19 06:05:10 - INFO - Form Course: Operating Systems
2024-12-19 06:05:10 - INFO - Form Professor: Dr. Park
2024-12-19 06:05:10 - INFO - Form Number of MCQ Questions: 2
2024-12-19 06:05:10 - INFO - Form Number of TF Questions: 2
2024-12-19 06:05:10 - INFO - Form Number of Written Questions: 1
2024-12-19 06:05:10 - INFO - Form School Type: Undergraduate
2024-12-19 06:05:10 - INFO - Form Difficulty: Extreme
2024-12-19 06:05:10 - INFO - Form Testing Philosophy: I like to give them the hardest possible challenge so they study more and learn more :)
2024-12-19 06:05:10 - INFO - Moving to files...
2024-12-19 06:05:10 - INFO - Starting to process files
2024-12-19 06:05:10 - INFO - Processing file: 450Slides10.pdf
2024-12-19 06:05:10 - INFO - Getting loader for file: UploadFile(filename='450Slides10.pdf', size=166799, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides10.pdf"', 'content-type': 'application/pdf'}))
2024-12-19 06:05:10 - INFO - File extension: .pdf
2024-12-19 06:05:10 - INFO - Processing PDF file: 450Slides10.pdf
2024-12-19 06:05:10 - INFO - Using loader type: PyMuPDFLoader for UploadFile(filename='450Slides10.pdf', size=166799, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides10.pdf"', 'content-type': 'application/pdf'}))
2024-12-19 06:05:10 - INFO - URLs: []
2024-12-19 06:05:10 - INFO - Processing 1 files and 0 URLs
2024-12-19 06:05:10 - INFO - Processing 450Slides10.pdf
2024-12-19 06:05:10 - INFO - Using loader type: PyMuPDFLoader for 450Slides10.pdf
2024-12-19 06:05:10 - INFO - Processing 450Slides10.pdf as a regular document using PyMuPDFLoader
2024-12-19 06:05:10 - INFO - Successfully loaded 5 documents from: 450Slides10.pdf
2024-12-19 06:05:10 - INFO - Docs: [Document(metadata={'source': '/tmp/tmpslgv7tee', 'file_path': '/tmp/tmpslgv7tee', 'page': 0, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n1\nPreview\nInter-Process Communication\n\ue007Race Condition\n\ue007Critical Section (or region)\n\ue007Solutions for Mutual Exclusion in a Critical Section\n◼With Busy Waiting\n\ue007Disabling Interrupts –non-preemptive kernel\n\ue007Lock Variables –violating the first necessary condition (mutual exclusion )\n\ue007Strict Alternation –violating the second necessary condition ( block by a process outside critical section)\n\ue007Peterson’s Solution\n\ue007Hardware Solution\n▪\nTest and Set Lock –\n▪\nMemory Barriers\n▪\nAtomic Variable\n\ue007Priority Inversion problems with busy waiting\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n1\nInterprocess Communication\n\ue007\nThree issues in interprocess communication\n1.\nHow one process can pass information to another (communication\nbetween processes) – with IPCS (shared memory, message queue,\nFIFO, PIPE, socket, …)\n2.\nHow to make sure two or more processes do not get into the\ncritical section (mutual exclusion)- with mutex, semaphore\n3.\nProper sequencing (Synchronization) when dependencies are\npresent (ex. A create outputs, B consume the outputs)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n2\nInterprocess Communication\n(Race Condition)\n\ue007Race Condition\n◼A situation where two or more processes are reading or writing some shared\ndata and the final result depends on who runs precisely when, are called race\ncondition.\n\ue007Critical section (critical region)\n◼The part of program where the shared memory is accessed.\n\ue007Mutual Exclusion in a critical section can avoid races condition:\n◼If we could arrange matters such that no two processes were ever in their\ncritical regions at the same time, we can avoid races condition.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n3\nInterprocess Communication\n(Race Condition)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n4\nSlots for file names\n• When a process want\nto print a file, it enter a\nfile name in a special\nspooler directory in\nprinter\n• Printer daemon\nperiodically check\nspooler directory any file\nneed to be printed.\nShared variable\nInterprocess Communication\n(Race Condition)\n\ue007\nProcess A tried to send a job to\nspooler, Process A read in = 7,\nprocess A time out and go to ready\nstate before updating in = in + 1.\n\ue007\nProcess B tried to send a job to\nspooler. Process B read in = 7, load\nits job name in slot 7, update i = i +\n1 = 8 and then go to block state for\nwaiting for job.\n\ue007\nProcess A is rescheduled by\nscheduler. Process A already read in\n= 7, Process A load its job name in\nslot 7, update i = i + 1 = 9 and then\ngo to blocked state waiting for this\njob finish.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n5\nInterprocess Communication\n(Race Condition)\n\ue007How to avoid race condition?\nMutual exclusion – some way of making sure that if one process is using a\nshared variable or file, the other processes will be excluded from doing the same\nthing.\n\ue007The choice of the algorithm for achieving mutual exclusion is a\nmajor design issue in any operating system.\n\ue007A solution for the race condition should have following four\nconditions\n1.\nNo two processes may be simultaneously inside their critical regions – mutual\nexclusion\n2.\nNo process running outside its critical region may block other processes\n3.\nNo process should have to wait forever to enter critical region\n4.\nNo assumptions may be made about speeds or the number of CPUs.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n6\n'), Document(metadata={'source': '/tmp/tmpslgv7tee', 'file_path': '/tmp/tmpslgv7tee', 'page': 1, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n2\nInterprocess Communication\n(Race Condition)\n\ue007Two approaches for mutual exclusion solutions.\n◼Busy wait – A process will wait until resource become available\nor CPU time term expired.\n◼Sleep and Wakeup – A process check a resource, if not available\ngo to sleep. When the resource become available, the process\nwill be waked up by system or the process release the resource.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n7\nMutual Exclusion with Busy Waiting\n\ue007Each process has time term. A process keep checking the\npossibility to get into critical section.\n\ue007Mutual Exclusion with Busy Waiting\n◼Disabling Interrupts –non-preemptive kernel\n◼Lock Variables\n◼Strict Alternation\n◼Peterson’s Solution\n◼Hardware Solutions\n\ue007Test and Set Lock\n\ue007Memory Barriers\n\ue007Atomic Variable\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n8\nMutual Exclusion with Busy Waiting\n(Disabling Interrupt – Nonprimitive Kernel)\nDisabling Interrupt\n\ue007Once a process get into the critical section, interrupts set to disable.\n\ue007Other process cannot get CPU time until the process finish its job in\nthe critical section.\n\ue007Since each user process has power to control interrupt, it might\ncause the end of system.\n\ue007We can build a simple program which can disable entire system\nsince user has control system interrupt. (vulnerable system)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n9\nMutual Exclusion with Busy Waiting\n(Disabling Interrupt – Nonprimitive Kernel)\nEx) End of the system with Disabling interrupt\n1. A process get into the critical section.\n2. It make disable all the interrupts – which means all\nother process are sleeping until the job is done in the\ncritical section.\n3. The process has blocked outside critical section just\nbefore make enable all the interrupts and never return\nagain, cause end of the system.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n10\nMutual Exclusion with Busy Waiting\n(Using Lock Variable)\n\ue007There are variable called “Lock”\n◼A process can enter in its critical section when Lock = 0.\n◼Lock =0 means no process is currently running in the critical\nsection, set Lock =1 and enter in the critical section.\n◼Once a process finish its job in critical section, set Lock = 0 and\nlet other process in the critical section\n◼Lock = 1 means there is a process running in the critical section,\na process do busy waiting until Lock become 0.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n11\nMutual Exclusion with Busy Waiting\n(Using Lock Variable)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n12\nstatic int lock = 0; //lock variable is initially 0\nrepeat\nwhile lock \ue0060do\n; (no-operation) // Busy waiting\nlock = 1;\nlock = 0;\nuntil false\nCritical Section\nRemainder Section\n'), Document(metadata={'source': '/tmp/tmpslgv7tee', 'file_path': '/tmp/tmpslgv7tee', 'page': 2, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n3\nMutual Exclusion with Busy Waiting\n(Using Lock Variable)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n13\nstatic int lock = 0; //lock is initially 0\nrepeat\nwhile lock \ue0060 do\n; (no-operation) //busy waiting\nlock = 1;\nlock = 0;\nuntil false\nCritical Section\nRemainder Section\nScenario)\n1.\nInitially lock = 0.\n2.\nA process P1 tries get into critical section.\nThe process P1 check lock value = 0.\n3.\nProcess P1 CPU time is over and go to\nready state, before updating lock = 1.\n4.\nProcess P2 tries get into critical section.\nP2 check lock value lock = 0\n5.\nP2 set lock = 1 and go to critical section.\n6.\nP2 CPU time is over and P1 is rescheduled.\n7.\nP1 already read lock = 0, P1 set lock = 1\nand go to Critical section. Now P1 and P2\nare in the critical section at the same\ntime\nViolating condition #1: mutual exclusion\nMutual Exclusion with Busy Waiting\n(Strict Alternation)\n\ue007Variable turn can be i or j.\n\ue007if turn = i, process Pi can go to the\ncritical section.\n\ue007Once Pi finish its job in critical\nsection, Pi set turn = j, let process\nPj enter critical section\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n14\nCritical Section\nRemainder Section\nturn is i or j\nrepeat\nwhile turn \ue006i do\n; (no-operation)\nturn = j;\nuntil false\nMutual Exclusion with Busy Waiting\n(Strict Alternation)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n15\nCritical Section\nRemainder Section\nturn is i or j\nrepeat\nwhile turn \ue006i do\n; (no-operation)\nturn = j;\nuntil false\nLet assume initially turn = 0\n1.\nP0 is in CS while P1 is in remaining\nsection.\n2.\nP0 done C.S. and set turn = 1, P1 is\nstill in remaining section.\n3.\nP0 done remaining section and want\nto go to C.S. but turn= 1.\n4.\nP1 has fatal error in remainder\nsection and trapped out by OS.\n5.\nP0 is waiting forever to enter the C.S.\nViolating #2 and #3 condition\n2.\nNo process running outside its critical\nregion may block other processes\n3.\nNo process should have to wait forever to\nenter critical region\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\n\ue007Peterson’s solution provides a good algorithmic description of\nsolving the critical-section problem and illustrates some of the\ncomplexities involved in designing software that addresses the\nrequirements of mutual exclusion, progress, and bounded waiting.\n\ue007Peterson’s solution is restricted to two processes that alternate\nexecution between their critical sections and remainder sections.\n\ue007The processes are numbered P0 and P1.\n\ue007For convenience, when presenting Pi, we use Pj to denote the other\nprocess; that is, j equals 1 −i.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n16\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n17\n#define false 0\n#define true 1\n#define n 2\nint turn\nint interested[n]\nvoid enter_region(int process);\n{\nint other;\nother = 1 – process\ninterested[process] = true\nturn = process;\nwhile (turn ==process && interest[other]==true)\n; /*no operation –busy waiting*/\n}\nvoid leave_region(int process)\n{\ninterest[process] = false;\n}\nvoid main()\n{\nrepeat\nenter_region (int i)\nCritical Section\nleave_resion (int i)\nRemainder Section\nuntil false\n}\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\n1.\nInitially, neither process is in the critical section\n2.\nA process P0 call enter_region (0)\na)\nSet interested[0] = true;\nb)\nSet turn = 0\n3.\ngo to critical section\n4.\nthe process P1 call enter_region(1) to get into its critical section\na)\nset interested[1] = true;\nb)\nset turn = 1;\n5.\nsince interested[0] = true, it is keep looping for interest [0] =\nfalse\n6.\nfinally process P0 finish its critical section and call leave_region(0)\n1.\nset interested[0] = false\n7.\nnow P1 find out interest[0] = false, P1 goes to its critical section\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n18\n'), Document(metadata={'source': '/tmp/tmpslgv7tee', 'file_path': '/tmp/tmpslgv7tee', 'page': 3, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n4\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\nProve for Peterson’s Solution)\n\ue007\nLets consider the case both P0 and P1 call enter_region(0) and enter_region(1) almost\nsimultaneously.\n\ue007\nLets interest[0]= true and interest[1] = true at the same time\n\ue007\nBut turn can be only turn = 0 or turn = 1 which ever store is done last is the one that\ncounts!!\nCase 1) turn = 0\nInside enter_region(0)\n◼\nSince turn =0 and interest [1] = ture, P0 keep looping in no-operation until P1 set interested[1] =\nfalse.\nInside enter_region(1)\n◼\nSince turn = 0 and interest[0] = true, P1 goes to its critical section.\nCase 2) turn = 1\nInside enter_region(0)\n◼\nSince turn =1 and interest [1] = ture,. P0 goes to its critical section\nInside enter_region(1)\n◼\nSince turn = 1 and interest[0] = true, P1 keep looping in no-operation until P0 set interested[0] =\nfalse.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n19\nMutual Exclusion with Busy Waiting\n(Test and Set Lock – hardware solution)\n\ue007\nSince TSL instruction is a hardware instruction. The operations of reading the\nlock and storing into register are guaranteed to be indivisible.\n\ue007\nInstruction test and set lock\nTSL RX, LOCK\n1. Read the content at the memory address of LOCK into register RX.\n2. Store a non-zero value at the memory address of LOCK\n\ue007\nThe operations of reading the content of LOCK and storing into it are guaranteed\nto be indivisible.\n\ue007\nHow to use Test and Set Lock instruction for solving race condition?\n◼\nWhen LOCK = 0, any process may set LOCK = 1 by using TSL instruction and go to\nits critical section.\n◼\nWhen the process finish its critical section, set LOCK = 0 using the original move\ninstruction.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n20\nMutual Exclusion with Busy Waiting\n(Test and Set Lock – hardware solution)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n21\nEnter_region\nTSL Register, LOCK\nCMP Register, #0\nJNE Enter_region\nSet LOCK, #1\nRET\nLeave_region\nMOVE LOCK, #0\nRET\nRepeat\nEnter_region\nLeave_region\nuntil false\nCritical Section\nRemainder Section\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\n\ue007Two general memory models\n◼Strongly ordered Memory –a memory modification on one processor is\nimmediately visible to all other processors\n◼Weakly ordered Memory – a memory modification on one processor may not\nbe immediately visible to other processors.\n\ue007With Strongly ordered memory, computer architectures provide\ninstructions that can force any changes in memory to be\npropagated to all other processors, thereby ensuring that memory\nmodifications are visible to threads (or processes) running on other\nprocessors.\n\ue007Such instructions are known as memory barriers or memory\nfences.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n22\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\n\ue007A memory barrier is a type of barrier instruction that causes a\ncentral processing unit (CPU) or compiler to enforce an ordering\nconstraint on memory operations issued before and after the\nbarrier instruction.\n\ue007This typically means that operations issued prior to the barrier are\nguaranteed to be performed before operations issued after the\nbarrier.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n23\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\nEx)\n\ue007Lets assume two threads (or processes) are running on different\npart of program by sharing two variables. (bool flag = false; int x=0;)\n\ue007Thread 1 might print 0 or 100 depends on the order of execution.\n\ue007By using memory barrier instruction Thread1 always print 100.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n24\nwhile (!flag)\nprint x;\nx = 100\nflag = true;\nThread 1\nThread 2\n'), Document(metadata={'source': '/tmp/tmpslgv7tee', 'file_path': '/tmp/tmpslgv7tee', 'page': 4, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content="9/17/2024\n5\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\n\ue007Now it is guarantee that the value of flag is loaded before the value of x\n\ue007Also it is guarantee that assignment to x occurs before the assignment to flag.\n\ue007So Thread 1 always print 100\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n25\nwhile (!flag)\nmemory_barrier();\nprint x;\nx = 100;\nmemory_barrier();\nflag = true;\nThread 1\nThread 2\nMutual Exclusion with Busy Waiting\n(Atomic Variables– hardware solution)\n\ue007We can avoid mutual exclusion by using atomic operations.\n\ue007When a thread (or process) performs an atomic operation, the\nother threads (or process) see it as happening instantaneously.\n\ue007The advantage of atomic operations is that they are relatively quick\ncompared to locks, and do not suffer from deadlock and convoying.\n\ue007The disadvantage is that they only do a limited set of operations,\nand often these are not enough to synthesize more complicated\noperations efficiently.\n\ue007But nonetheless you should not pass up an opportunity to use an\natomic operation in place of mutual exclusion.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n26\nMutual Exclusion with Busy Waiting\n(Priority Inversion Problem)\n\ue007Peterson's solution, test and set lock, Memory Barrier, Atomic variable method –\nbusy waiting – (wasting CPU time)\nPriority Inversion problem with busy waiting method\n\ue007A computer with two processes PH with high priorities, and PL with low priorities.\n\ue007The scheduling rules are such that PH get CPU time whenever it is in ready state.\n(preemptive priority scheduling)\n1. At a time T0: PL is in critical section, and PH is in block state.\n2. At a time T1: PH change sate from block to ready state and try to enter the critical\nsection. PL still in critical section.\n3. Based on scheduling rule, short-term scheduler select PH, PH hold CPU and try to enter\ninto critical section.\n4. Since PL is in critical section, PH run busy waiting outside critical section forever since\nPL does not have a chance to get CPU time to finish its critical section.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n27\nMutual Exclusion with Busy Waiting\n(Priority Inversion Problem)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n28\nBlock\nRunning\nReady\nT0 :\nPL: running state in critical section\nPH: block state\nPH\nPL\nBlock\nRunning\nReady\nPH\nPL\nT1 : PH become ready state\nPL: ready state in critical section\nPH: ready state\nCPU scheduler will select higher\npriority process\nBlock\nRunning\nReady\nPH\nPL\nTi>1\nPL: ready state in critical section\nPH: busy waiting in running state\nPH become ready state\nScheduler keep selecting\nPH since higher priority\nThe scheduling rules : CPU scheduler will always select higher priority process.\n")] for 450Slides10.pdf using PyMuPDFLoader
2024-12-19 06:05:10 - INFO - Document 1 (450Slides10.pdf) of 5
2024-12-19 06:05:10 - INFO - Starting clean_files_chain
2024-12-19 06:05:10 - INFO - Document: page_content='9/17/2024
1
Preview
Inter-Process Communication
Race Condition
Critical Section (or region)
Solutions for Mutual Exclusion in a Critical Section
◼With Busy Waiting
Disabling Interrupts –non-preemptive kernel
Lock Variables –violating the first necessary condition (mutual exclusion )
Strict Alternation –violating the second necessary condition ( block by a process outside critical section)
Peterson’s Solution
Hardware Solution
▪
Test and Set Lock –
▪
Memory Barriers
▪
Atomic Variable
Priority Inversion problems with busy waiting
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
1
Interprocess Communication

Three issues in interprocess communication
1.
How one process can pass information to another (communication
between processes) – with IPCS (shared memory, message queue,
FIFO, PIPE, socket, …)
2.
How to make sure two or more processes do not get into the
critical section (mutual exclusion)- with mutex, semaphore
3.
Proper sequencing (Synchronization) when dependencies are
present (ex. A create outputs, B consume the outputs)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
2
Interprocess Communication
(Race Condition)
Race Condition
◼A situation where two or more processes are reading or writing some shared
data and the final result depends on who runs precisely when, are called race
condition.
Critical section (critical region)
◼The part of program where the shared memory is accessed.
Mutual Exclusion in a critical section can avoid races condition:
◼If we could arrange matters such that no two processes were ever in their
critical regions at the same time, we can avoid races condition.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
3
Interprocess Communication
(Race Condition)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
4
Slots for file names
• When a process want
to print a file, it enter a
file name in a special
spooler directory in
printer
• Printer daemon
periodically check
spooler directory any file
need to be printed.
Shared variable
Interprocess Communication
(Race Condition)

Process A tried to send a job to
spooler, Process A read in = 7,
process A time out and go to ready
state before updating in = in + 1.

Process B tried to send a job to
spooler. Process B read in = 7, load
its job name in slot 7, update i = i +
1 = 8 and then go to block state for
waiting for job.

Process A is rescheduled by
scheduler. Process A already read in
= 7, Process A load its job name in
slot 7, update i = i + 1 = 9 and then
go to blocked state waiting for this
job finish.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
5
Interprocess Communication
(Race Condition)
How to avoid race condition?
Mutual exclusion – some way of making sure that if one process is using a
shared variable or file, the other processes will be excluded from doing the same
thing.
The choice of the algorithm for achieving mutual exclusion is a
major design issue in any operating system.
A solution for the race condition should have following four
conditions
1.
No two processes may be simultaneously inside their critical regions – mutual
exclusion
2.
No process running outside its critical region may block other processes
3.
No process should have to wait forever to enter critical region
4.
No assumptions may be made about speeds or the number of CPUs.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
6
' metadata={'source': '/tmp/tmpslgv7tee', 'file_path': '/tmp/tmpslgv7tee', 'page': 0, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-19 06:05:10 - INFO - Invoking chain
2024-12-19 06:05:20 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 06:05:20 - INFO - Response: {'cleaned_content': 'Date: 9/17/2024\n\n# Inter-Process Communication\n\n## Race Condition\n\n## Critical Section (or Region)\n\n## Solutions for Mutual Exclusion in a Critical Section\n\n- With Busy Waiting\n  - Disabling Interrupts - non-preemptive kernel\n  - Lock Variables - violating the first necessary condition (mutual exclusion)\n  - Strict Alternation - violating the second necessary condition (blocked by a process outside the critical section)\n  - Peterson’s Solution\n  - Hardware Solution\n    - Test and Set Lock\n    - Memory Barriers\n    - Atomic Variable\n- Priority Inversion problems with busy waiting\n\n### COSC450 Operating System, Fall 2024\nInstructor: Dr. Sang-Eon Park\n\n## Interprocess Communication\n\n### Three Issues in Interprocess Communication\n1. How one process can pass information to another (communication between processes) - using IPC mechanisms such as shared memory, message queue, FIFO, PIPE, socket, etc.\n2. How to ensure two or more processes do not enter the critical section simultaneously (mutual exclusion) - using mutex, semaphore\n3. Proper sequencing (synchronization) when dependencies are present (e.g., process A creates an output, process B consumes the output)\n\n### Race Condition\nA race condition occurs when two or more processes read or write shared data, and the final result depends on the timing of their execution.\n\n### Critical Section (Critical Region)\nThe critical section is the part of the program where shared memory is accessed. To avoid race conditions, mutual exclusion in a critical section is necessary. If we can ensure that no two processes are in their critical regions at the same time, we can avoid race conditions.\n\n### Example: Slots for File Names\n- When a process wants to print a file, it enters a file name in a special spooler directory for the printer.\n- The printer daemon periodically checks the spooler directory for any files that need to be printed.\n\n### Shared Variable Scenario\n- Process A attempts to send a job to the spooler. It reads `in = 7`, but after a timeout, it goes to a ready state before updating `in` to `in + 1`.\n- Process B also tries to send a job to the spooler, reads `in = 7`, loads its job name in slot 7, updates `i` to `i + 1 = 8`, and then goes to a blocked state waiting for the job to finish.\n- Process A is rescheduled and loads its job name in slot 7 again, updating `i` to `i + 1 = 9`, and then goes to a blocked state while waiting for the job to finish.\n\n### How to Avoid Race Conditions\n- Mutual exclusion is required to ensure that if one process is using a shared variable or file, other processes are excluded from doing the same.\n- The choice of the algorithm for achieving mutual exclusion is a major design issue in any operating system.\n\n### Conditions for a Race Condition Solution\n1. No two processes may be simultaneously inside their critical regions (mutual exclusion).\n2. No process running outside its critical region may block other processes.\n3. No process should have to wait forever to enter the critical region.\n4. No assumptions may be made about speeds or the number of CPUs.'}
2024-12-19 06:05:20 - INFO - Finished clean_files_chain
2024-12-19 06:05:20 - INFO - Successfully cleaned document 1 from 450Slides10.pdf
2024-12-19 06:05:20 - INFO - Document 2 (450Slides10.pdf) of 5
2024-12-19 06:05:20 - INFO - Starting clean_files_chain
2024-12-19 06:05:20 - INFO - Document: page_content='9/17/2024
2
Interprocess Communication
(Race Condition)
Two approaches for mutual exclusion solutions.
◼Busy wait – A process will wait until resource become available
or CPU time term expired.
◼Sleep and Wakeup – A process check a resource, if not available
go to sleep. When the resource become available, the process
will be waked up by system or the process release the resource.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
7
Mutual Exclusion with Busy Waiting
Each process has time term. A process keep checking the
possibility to get into critical section.
Mutual Exclusion with Busy Waiting
◼Disabling Interrupts –non-preemptive kernel
◼Lock Variables
◼Strict Alternation
◼Peterson’s Solution
◼Hardware Solutions
Test and Set Lock
Memory Barriers
Atomic Variable
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
8
Mutual Exclusion with Busy Waiting
(Disabling Interrupt – Nonprimitive Kernel)
Disabling Interrupt
Once a process get into the critical section, interrupts set to disable.
Other process cannot get CPU time until the process finish its job in
the critical section.
Since each user process has power to control interrupt, it might
cause the end of system.
We can build a simple program which can disable entire system
since user has control system interrupt. (vulnerable system)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
9
Mutual Exclusion with Busy Waiting
(Disabling Interrupt – Nonprimitive Kernel)
Ex) End of the system with Disabling interrupt
1. A process get into the critical section.
2. It make disable all the interrupts – which means all
other process are sleeping until the job is done in the
critical section.
3. The process has blocked outside critical section just
before make enable all the interrupts and never return
again, cause end of the system.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
10
Mutual Exclusion with Busy Waiting
(Using Lock Variable)
There are variable called “Lock”
◼A process can enter in its critical section when Lock = 0.
◼Lock =0 means no process is currently running in the critical
section, set Lock =1 and enter in the critical section.
◼Once a process finish its job in critical section, set Lock = 0 and
let other process in the critical section
◼Lock = 1 means there is a process running in the critical section,
a process do busy waiting until Lock become 0.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
11
Mutual Exclusion with Busy Waiting
(Using Lock Variable)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
12
static int lock = 0; //lock variable is initially 0
repeat
while lock 0do
; (no-operation) // Busy waiting
lock = 1;
lock = 0;
until false
Critical Section
Remainder Section
' metadata={'source': '/tmp/tmpslgv7tee', 'file_path': '/tmp/tmpslgv7tee', 'page': 1, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-19 06:05:20 - INFO - Invoking chain
2024-12-19 06:05:29 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 06:05:29 - INFO - Response: {'cleaned_content': '9/17/2024\n\nInterprocess Communication (Race Condition)\n\nTwo approaches for mutual exclusion solutions:\n1. Busy wait – A process will wait until the resource becomes available or the CPU time term expires.\n2. Sleep and Wakeup – A process checks a resource; if it is not available, it goes to sleep. When the resource becomes available, the process will be woken up by the system or the process releases the resource.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting\n\nEach process has a time term. A process keeps checking the possibility of entering the critical section. Mutual Exclusion with Busy Waiting includes:\n- Disabling Interrupts – non-preemptive kernel\n- Lock Variables\n- Strict Alternation\n- Peterson’s Solution\n- Hardware Solutions\n  - Test and Set Lock\n  - Memory Barriers\n  - Atomic Variable\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Disabling Interrupt – Nonprimitive Kernel)\n\nDisabling Interrupt:\n- Once a process gets into the critical section, interrupts are set to disable.\n- Other processes cannot get CPU time until the process finishes its job in the critical section.\n- Since each user process has the power to control interrupts, it might cause the end of the system.\n- We can build a simple program that can disable the entire system since the user has control over system interrupts (vulnerable system).\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Disabling Interrupt – Nonprimitive Kernel)\n\nExample: End of the system with Disabling Interrupt\n1. A process enters the critical section.\n2. It disables all interrupts, meaning all other processes are sleeping until the job is done in the critical section.\n3. The process is blocked outside the critical section just before enabling all the interrupts and never returns again, causing the end of the system.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Using Lock Variable)\n\nThere is a variable called "Lock":\n- A process can enter its critical section when Lock = 0.\n- Lock = 0 means no process is currently running in the critical section; set Lock = 1 and enter the critical section.\n- Once a process finishes its job in the critical section, set Lock = 0 to let other processes in the critical section.\n- Lock = 1 means there is a process running in the critical section; a process does busy waiting until Lock becomes 0.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Using Lock Variable)\n\nstatic int lock = 0; // lock variable is initially 0\nrepeat\n    while lock == 0 do\n        ; // (no-operation) // Busy waiting\n    lock = 1;\n    lock = 0;\nuntil false\n\nCritical Section\nRemainder Section'}
2024-12-19 06:05:29 - INFO - Finished clean_files_chain
2024-12-19 06:05:29 - INFO - Successfully cleaned document 2 from 450Slides10.pdf
2024-12-19 06:05:29 - INFO - Document 3 (450Slides10.pdf) of 5
2024-12-19 06:05:29 - INFO - Starting clean_files_chain
2024-12-19 06:05:29 - INFO - Document: page_content='9/17/2024
3
Mutual Exclusion with Busy Waiting
(Using Lock Variable)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
13
static int lock = 0; //lock is initially 0
repeat
while lock 0 do
; (no-operation) //busy waiting
lock = 1;
lock = 0;
until false
Critical Section
Remainder Section
Scenario)
1.
Initially lock = 0.
2.
A process P1 tries get into critical section.
The process P1 check lock value = 0.
3.
Process P1 CPU time is over and go to
ready state, before updating lock = 1.
4.
Process P2 tries get into critical section.
P2 check lock value lock = 0
5.
P2 set lock = 1 and go to critical section.
6.
P2 CPU time is over and P1 is rescheduled.
7.
P1 already read lock = 0, P1 set lock = 1
and go to Critical section. Now P1 and P2
are in the critical section at the same
time
Violating condition #1: mutual exclusion
Mutual Exclusion with Busy Waiting
(Strict Alternation)
Variable turn can be i or j.
if turn = i, process Pi can go to the
critical section.
Once Pi finish its job in critical
section, Pi set turn = j, let process
Pj enter critical section
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
14
Critical Section
Remainder Section
turn is i or j
repeat
while turn i do
; (no-operation)
turn = j;
until false
Mutual Exclusion with Busy Waiting
(Strict Alternation)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
15
Critical Section
Remainder Section
turn is i or j
repeat
while turn i do
; (no-operation)
turn = j;
until false
Let assume initially turn = 0
1.
P0 is in CS while P1 is in remaining
section.
2.
P0 done C.S. and set turn = 1, P1 is
still in remaining section.
3.
P0 done remaining section and want
to go to C.S. but turn= 1.
4.
P1 has fatal error in remainder
section and trapped out by OS.
5.
P0 is waiting forever to enter the C.S.
Violating #2 and #3 condition
2.
No process running outside its critical
region may block other processes
3.
No process should have to wait forever to
enter critical region
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
Peterson’s solution provides a good algorithmic description of
solving the critical-section problem and illustrates some of the
complexities involved in designing software that addresses the
requirements of mutual exclusion, progress, and bounded waiting.
Peterson’s solution is restricted to two processes that alternate
execution between their critical sections and remainder sections.
The processes are numbered P0 and P1.
For convenience, when presenting Pi, we use Pj to denote the other
process; that is, j equals 1 −i.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
16
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
17
#define false 0
#define true 1
#define n 2
int turn
int interested[n]
void enter_region(int process);
{
int other;
other = 1 – process
interested[process] = true
turn = process;
while (turn ==process && interest[other]==true)
; /*no operation –busy waiting*/
}
void leave_region(int process)
{
interest[process] = false;
}
void main()
{
repeat
enter_region (int i)
Critical Section
leave_resion (int i)
Remainder Section
until false
}
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
1.
Initially, neither process is in the critical section
2.
A process P0 call enter_region (0)
a)
Set interested[0] = true;
b)
Set turn = 0
3.
go to critical section
4.
the process P1 call enter_region(1) to get into its critical section
a)
set interested[1] = true;
b)
set turn = 1;
5.
since interested[0] = true, it is keep looping for interest [0] =
false
6.
finally process P0 finish its critical section and call leave_region(0)
1.
set interested[0] = false
7.
now P1 find out interest[0] = false, P1 goes to its critical section
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
18
' metadata={'source': '/tmp/tmpslgv7tee', 'file_path': '/tmp/tmpslgv7tee', 'page': 2, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-19 06:05:29 - INFO - Invoking chain
2024-12-19 06:05:42 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 06:05:42 - INFO - Response: {'cleaned_content': "9/17/2024\n\nMutual Exclusion with Busy Waiting (Using Lock Variable)\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nstatic int lock = 0; // lock is initially 0\nrepeat\n    while lock == 0 do\n        ; // (no-operation) // busy waiting\n    lock = 1;\n    lock = 0;\nuntil false\n\nCritical Section\nRemainder Section\n\nScenario:\n1. Initially lock = 0.\n2. A process P1 tries to get into the critical section. The process P1 checks lock value = 0.\n3. Process P1's CPU time is over and goes to ready state, before updating lock = 1.\n4. Process P2 tries to get into the critical section. P2 checks lock value lock = 0.\n5. P2 sets lock = 1 and goes to the critical section.\n6. P2's CPU time is over and P1 is rescheduled.\n7. P1 already read lock = 0; P1 sets lock = 1 and goes to the critical section. Now P1 and P2 are in the critical section at the same time.\n\nViolating condition #1: mutual exclusion.\n\nMutual Exclusion with Busy Waiting (Strict Alternation)\n- Variable turn can be i or j.\n- If turn = i, process Pi can go to the critical section.\n- Once Pi finishes its job in the critical section, Pi sets turn = j, letting process Pj enter the critical section.\n\nCritical Section\nRemainder Section\n\nturn is i or j\nrepeat\n    while turn == i do\n        ; // (no-operation)\n    turn = j;\nuntil false\n\nLet’s assume initially turn = 0:\n1. P0 is in the critical section while P1 is in the remainder section.\n2. P0 finishes critical section and sets turn = 1; P1 is still in the remainder section.\n3. P0 finishes the remainder section and wants to go to critical section but turn = 1.\n4. P1 has a fatal error in the remainder section and is trapped out by the OS.\n5. P0 is waiting forever to enter the critical section.\n\nViolating conditions:\n2. No process running outside its critical region may block other processes.\n3. No process should have to wait forever to enter the critical region.\n\nMutual Exclusion with Busy Waiting (Peterson’s Solution)\n- Peterson’s solution provides a good algorithmic description of solving the critical-section problem and illustrates some of the complexities involved in designing software that addresses the requirements of mutual exclusion, progress, and bounded waiting.\n- Peterson’s solution is restricted to two processes that alternate execution between their critical sections and remainder sections.\n- The processes are numbered P0 and P1.\n- For convenience, when presenting Pi, we use Pj to denote the other process; that is, j equals 1 - i.\n\n#define false 0\n#define true 1\n#define n 2\nint turn;\nint interested[n];\n\nvoid enter_region(int process) {\n    int other;\n    other = 1 - process;\n    interested[process] = true;\n    turn = process;\n    while (turn == process && interested[other] == true)\n        ; /* no operation – busy waiting */\n}\n\nvoid leave_region(int process) {\n    interested[process] = false;\n}\n\nvoid main() {\n    repeat\n        enter_region(int i);\n        Critical Section;\n        leave_region(int i);\n        Remainder Section;\n    until false;\n}\n\nMutual Exclusion with Busy Waiting (Peterson’s Solution)\n1. Initially, neither process is in the critical section.\n2. A process P0 calls enter_region(0):\n   a) Set interested[0] = true;\n   b) Set turn = 0.\n3. P0 goes to the critical section.\n4. The process P1 calls enter_region(1) to get into its critical section:\n   a) Set interested[1] = true;\n   b) Set turn = 1;\n5. Since interested[0] = true, it keeps looping while interested[0] = false.\n6. Finally, process P0 finishes its critical section and calls leave_region(0):\n   1. Set interested[0] = false.\n7. Now P1 finds out interested[0] = false, so P1 goes to its critical section."}
2024-12-19 06:05:42 - INFO - Finished clean_files_chain
2024-12-19 06:05:42 - INFO - Successfully cleaned document 3 from 450Slides10.pdf
2024-12-19 06:05:42 - INFO - Document 4 (450Slides10.pdf) of 5
2024-12-19 06:05:42 - INFO - Starting clean_files_chain
2024-12-19 06:05:42 - INFO - Document: page_content='9/17/2024
4
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
Prove for Peterson’s Solution)

Lets consider the case both P0 and P1 call enter_region(0) and enter_region(1) almost
simultaneously.

Lets interest[0]= true and interest[1] = true at the same time

But turn can be only turn = 0 or turn = 1 which ever store is done last is the one that
counts!!
Case 1) turn = 0
Inside enter_region(0)
◼
Since turn =0 and interest [1] = ture, P0 keep looping in no-operation until P1 set interested[1] =
false.
Inside enter_region(1)
◼
Since turn = 0 and interest[0] = true, P1 goes to its critical section.
Case 2) turn = 1
Inside enter_region(0)
◼
Since turn =1 and interest [1] = ture,. P0 goes to its critical section
Inside enter_region(1)
◼
Since turn = 1 and interest[0] = true, P1 keep looping in no-operation until P0 set interested[0] =
false.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
19
Mutual Exclusion with Busy Waiting
(Test and Set Lock – hardware solution)

Since TSL instruction is a hardware instruction. The operations of reading the
lock and storing into register are guaranteed to be indivisible.

Instruction test and set lock
TSL RX, LOCK
1. Read the content at the memory address of LOCK into register RX.
2. Store a non-zero value at the memory address of LOCK

The operations of reading the content of LOCK and storing into it are guaranteed
to be indivisible.

How to use Test and Set Lock instruction for solving race condition?
◼
When LOCK = 0, any process may set LOCK = 1 by using TSL instruction and go to
its critical section.
◼
When the process finish its critical section, set LOCK = 0 using the original move
instruction.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
20
Mutual Exclusion with Busy Waiting
(Test and Set Lock – hardware solution)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
21
Enter_region
TSL Register, LOCK
CMP Register, #0
JNE Enter_region
Set LOCK, #1
RET
Leave_region
MOVE LOCK, #0
RET
Repeat
Enter_region
Leave_region
until false
Critical Section
Remainder Section
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
Two general memory models
◼Strongly ordered Memory –a memory modification on one processor is
immediately visible to all other processors
◼Weakly ordered Memory – a memory modification on one processor may not
be immediately visible to other processors.
With Strongly ordered memory, computer architectures provide
instructions that can force any changes in memory to be
propagated to all other processors, thereby ensuring that memory
modifications are visible to threads (or processes) running on other
processors.
Such instructions are known as memory barriers or memory
fences.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
22
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
A memory barrier is a type of barrier instruction that causes a
central processing unit (CPU) or compiler to enforce an ordering
constraint on memory operations issued before and after the
barrier instruction.
This typically means that operations issued prior to the barrier are
guaranteed to be performed before operations issued after the
barrier.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
23
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
Ex)
Lets assume two threads (or processes) are running on different
part of program by sharing two variables. (bool flag = false; int x=0;)
Thread 1 might print 0 or 100 depends on the order of execution.
By using memory barrier instruction Thread1 always print 100.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
24
while (!flag)
print x;
x = 100
flag = true;
Thread 1
Thread 2
' metadata={'source': '/tmp/tmpslgv7tee', 'file_path': '/tmp/tmpslgv7tee', 'page': 3, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-19 06:05:42 - INFO - Invoking chain
2024-12-19 06:05:55 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 06:05:55 - INFO - Response: {'cleaned_content': "9/17/2024\n\nMutual Exclusion with Busy Waiting (Peterson’s Solution)\n\nProve for Peterson’s Solution:\n\nLet's consider the case where both P0 and P1 call enter_region(0) and enter_region(1) almost simultaneously.\n\nLet's assume interest[0] = true and interest[1] = true at the same time. However, turn can only be either turn = 0 or turn = 1; whichever store is done last is the one that counts!\n\nCase 1: turn = 0\n- Inside enter_region(0): Since turn = 0 and interest[1] = true, P0 keeps looping in no-operation until P1 sets interest[1] = false.\n- Inside enter_region(1): Since turn = 0 and interest[0] = true, P1 goes to its critical section.\n\nCase 2: turn = 1\n- Inside enter_region(0): Since turn = 1 and interest[1] = true, P0 goes to its critical section.\n- Inside enter_region(1): Since turn = 1 and interest[0] = true, P1 keeps looping in no-operation until P0 sets interest[0] = false.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Test and Set Lock – hardware solution)\n\nSince the Test and Set Lock (TSL) instruction is a hardware instruction, the operations of reading the lock and storing into a register are guaranteed to be indivisible.\n\nInstruction test and set lock:\n- TSL RX, LOCK\n1. Read the content at the memory address of LOCK into register RX.\n2. Store a non-zero value at the memory address of LOCK.\n\nThe operations of reading the content of LOCK and storing into it are guaranteed to be indivisible.\n\nHow to use the Test and Set Lock instruction for solving race conditions:\n- When LOCK = 0, any process may set LOCK = 1 by using the TSL instruction and go to its critical section.\n- When the process finishes its critical section, it sets LOCK = 0 using the original move instruction.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Test and Set Lock – hardware solution)\n\nEnter_region:\n- TSL Register, LOCK\n- CMP Register, #0\n- JNE Enter_region\n- Set LOCK, #1\n- RET\n\nLeave_region:\n- MOVE LOCK, #0\n- RET\n\nRepeat:\n- Enter_region\n- Leave_region\nuntil false\n\nCritical Section\nRemainder Section\n\nMutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)\n\nTwo general memory models:\n- Strongly ordered Memory: A memory modification on one processor is immediately visible to all other processors.\n- Weakly ordered Memory: A memory modification on one processor may not be immediately visible to other processors.\n\nWith strongly ordered memory, computer architectures provide instructions that can force any changes in memory to be propagated to all other processors, thereby ensuring that memory modifications are visible to threads (or processes) running on other processors.\n\nSuch instructions are known as memory barriers or memory fences.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)\n\nA memory barrier is a type of barrier instruction that causes a central processing unit (CPU) or compiler to enforce an ordering constraint on memory operations issued before and after the barrier instruction.\nThis typically means that operations issued prior to the barrier are guaranteed to be performed before operations issued after the barrier.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)\n\nExample:\nLet's assume two threads (or processes) are running in different parts of a program while sharing two variables: (bool flag = false; int x = 0;)\nThread 1 might print 0 or 100 depending on the order of execution. By using a memory barrier instruction, Thread 1 always prints 100.\n\nwhile (!flag)\n    print x;\n    x = 100;\n    flag = true;\n\nThread 1\nThread 2"}
2024-12-19 06:05:55 - INFO - Finished clean_files_chain
2024-12-19 06:05:55 - INFO - Successfully cleaned document 4 from 450Slides10.pdf
2024-12-19 06:05:55 - INFO - Document 5 (450Slides10.pdf) of 5
2024-12-19 06:05:55 - INFO - Starting clean_files_chain
2024-12-19 06:05:55 - INFO - Document: page_content='9/17/2024
5
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
Now it is guarantee that the value of flag is loaded before the value of x
Also it is guarantee that assignment to x occurs before the assignment to flag.
So Thread 1 always print 100
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
25
while (!flag)
memory_barrier();
print x;
x = 100;
memory_barrier();
flag = true;
Thread 1
Thread 2
Mutual Exclusion with Busy Waiting
(Atomic Variables– hardware solution)
We can avoid mutual exclusion by using atomic operations.
When a thread (or process) performs an atomic operation, the
other threads (or process) see it as happening instantaneously.
The advantage of atomic operations is that they are relatively quick
compared to locks, and do not suffer from deadlock and convoying.
The disadvantage is that they only do a limited set of operations,
and often these are not enough to synthesize more complicated
operations efficiently.
But nonetheless you should not pass up an opportunity to use an
atomic operation in place of mutual exclusion.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
26
Mutual Exclusion with Busy Waiting
(Priority Inversion Problem)
Peterson's solution, test and set lock, Memory Barrier, Atomic variable method –
busy waiting – (wasting CPU time)
Priority Inversion problem with busy waiting method
A computer with two processes PH with high priorities, and PL with low priorities.
The scheduling rules are such that PH get CPU time whenever it is in ready state.
(preemptive priority scheduling)
1. At a time T0: PL is in critical section, and PH is in block state.
2. At a time T1: PH change sate from block to ready state and try to enter the critical
section. PL still in critical section.
3. Based on scheduling rule, short-term scheduler select PH, PH hold CPU and try to enter
into critical section.
4. Since PL is in critical section, PH run busy waiting outside critical section forever since
PL does not have a chance to get CPU time to finish its critical section.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
27
Mutual Exclusion with Busy Waiting
(Priority Inversion Problem)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
28
Block
Running
Ready
T0 :
PL: running state in critical section
PH: block state
PH
PL
Block
Running
Ready
PH
PL
T1 : PH become ready state
PL: ready state in critical section
PH: ready state
CPU scheduler will select higher
priority process
Block
Running
Ready
PH
PL
Ti>1
PL: ready state in critical section
PH: busy waiting in running state
PH become ready state
Scheduler keep selecting
PH since higher priority
The scheduling rules : CPU scheduler will always select higher priority process.
' metadata={'source': '/tmp/tmpslgv7tee', 'file_path': '/tmp/tmpslgv7tee', 'page': 4, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-19 06:05:55 - INFO - Invoking chain
2024-12-19 06:06:06 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 06:06:06 - INFO - Response: {'cleaned_content': "Date: 9/17/2024\n\n## Mutual Exclusion with Busy Waiting\n\n### Memory Barriers – Hardware Solution\n- It is guaranteed that the value of 'flag' is loaded before the value of 'x'.\n- It is also guaranteed that the assignment to 'x' occurs before the assignment to 'flag'.\n- Therefore, Thread 1 always prints 100.\n\n**Code Example:**\n```\nwhile (!flag)\n    memory_barrier();\nprint x;\nx = 100;\nmemory_barrier();\nflag = true;\n```  \n\n### Atomic Variables – Hardware Solution\n- We can avoid mutual exclusion by using atomic operations.\n- When a thread (or process) performs an atomic operation, other threads (or processes) see it as happening instantaneously.\n- The advantage of atomic operations is that they are relatively quick compared to locks and do not suffer from deadlock and convoying.\n- The disadvantage is that they only do a limited set of operations, which are often not enough to efficiently synthesize more complicated operations.\n- Nonetheless, one should not pass up an opportunity to use an atomic operation in place of mutual exclusion.\n\n### Priority Inversion Problem\n- Various methods for mutual exclusion, such as Peterson's solution, test and set lock, memory barriers, and atomic variable methods, can lead to busy waiting and waste CPU time.\n- The priority inversion problem occurs with busy waiting methods in a system with two processes: PH (high priority) and PL (low priority).\n- **Scheduling Rules:** PH gets CPU time whenever it is in the ready state (preemptive priority scheduling).\n\n1. At time T0: PL is in the critical section, and PH is in a blocked state.\n2. At time T1: PH changes state from blocked to ready and tries to enter the critical section, but PL is still in the critical section.\n3. Based on scheduling rules, the short-term scheduler selects PH; PH holds the CPU and tries to enter the critical section.\n4. Since PL is in the critical section, PH runs busy waiting outside the critical section indefinitely because PL does not get a chance to finish its critical section.\n\n### Process States During Priority Inversion\n- At T0:\n  - PL: Running state in critical section\n  - PH: Blocked state\n\n- At T1:\n  - PL: Ready state in critical section\n  - PH: Ready state\n\n- After T1:\n  - PL: Ready state in critical section\n  - PH: Busy waiting in running state\n\n**Note:** The CPU scheduler will always select the higher priority process."}
2024-12-19 06:06:06 - INFO - Finished clean_files_chain
2024-12-19 06:06:06 - INFO - Successfully cleaned document 5 from 450Slides10.pdf
2024-12-19 06:06:06 - INFO - Pages: []
2024-12-19 06:06:06 - INFO - Full response: Date: 9/17/2024

# Inter-Process Communication

## Race Condition

## Critical Section (or Region)

## Solutions for Mutual Exclusion in a Critical Section

- With Busy Waiting
  - Disabling Interrupts - non-preemptive kernel
  - Lock Variables - violating the first necessary condition (mutual exclusion)
  - Strict Alternation - violating the second necessary condition (blocked by a process outside the critical section)
  - Peterson’s Solution
  - Hardware Solution
    - Test and Set Lock
    - Memory Barriers
    - Atomic Variable
- Priority Inversion problems with busy waiting

### COSC450 Operating System, Fall 2024
Instructor: Dr. Sang-Eon Park

## Interprocess Communication

### Three Issues in Interprocess Communication
1. How one process can pass information to another (communication between processes) - using IPC mechanisms such as shared memory, message queue, FIFO, PIPE, socket, etc.
2. How to ensure two or more processes do not enter the critical section simultaneously (mutual exclusion) - using mutex, semaphore
3. Proper sequencing (synchronization) when dependencies are present (e.g., process A creates an output, process B consumes the output)

### Race Condition
A race condition occurs when two or more processes read or write shared data, and the final result depends on the timing of their execution.

### Critical Section (Critical Region)
The critical section is the part of the program where shared memory is accessed. To avoid race conditions, mutual exclusion in a critical section is necessary. If we can ensure that no two processes are in their critical regions at the same time, we can avoid race conditions.

### Example: Slots for File Names
- When a process wants to print a file, it enters a file name in a special spooler directory for the printer.
- The printer daemon periodically checks the spooler directory for any files that need to be printed.

### Shared Variable Scenario
- Process A attempts to send a job to the spooler. It reads `in = 7`, but after a timeout, it goes to a ready state before updating `in` to `in + 1`.
- Process B also tries to send a job to the spooler, reads `in = 7`, loads its job name in slot 7, updates `i` to `i + 1 = 8`, and then goes to a blocked state waiting for the job to finish.
- Process A is rescheduled and loads its job name in slot 7 again, updating `i` to `i + 1 = 9`, and then goes to a blocked state while waiting for the job to finish.

### How to Avoid Race Conditions
- Mutual exclusion is required to ensure that if one process is using a shared variable or file, other processes are excluded from doing the same.
- The choice of the algorithm for achieving mutual exclusion is a major design issue in any operating system.

### Conditions for a Race Condition Solution
1. No two processes may be simultaneously inside their critical regions (mutual exclusion).
2. No process running outside its critical region may block other processes.
3. No process should have to wait forever to enter the critical region.
4. No assumptions may be made about speeds or the number of CPUs.9/17/2024

Interprocess Communication (Race Condition)

Two approaches for mutual exclusion solutions:
1. Busy wait – A process will wait until the resource becomes available or the CPU time term expires.
2. Sleep and Wakeup – A process checks a resource; if it is not available, it goes to sleep. When the resource becomes available, the process will be woken up by the system or the process releases the resource.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting

Each process has a time term. A process keeps checking the possibility of entering the critical section. Mutual Exclusion with Busy Waiting includes:
- Disabling Interrupts – non-preemptive kernel
- Lock Variables
- Strict Alternation
- Peterson’s Solution
- Hardware Solutions
  - Test and Set Lock
  - Memory Barriers
  - Atomic Variable

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Disabling Interrupt – Nonprimitive Kernel)

Disabling Interrupt:
- Once a process gets into the critical section, interrupts are set to disable.
- Other processes cannot get CPU time until the process finishes its job in the critical section.
- Since each user process has the power to control interrupts, it might cause the end of the system.
- We can build a simple program that can disable the entire system since the user has control over system interrupts (vulnerable system).

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Disabling Interrupt – Nonprimitive Kernel)

Example: End of the system with Disabling Interrupt
1. A process enters the critical section.
2. It disables all interrupts, meaning all other processes are sleeping until the job is done in the critical section.
3. The process is blocked outside the critical section just before enabling all the interrupts and never returns again, causing the end of the system.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Using Lock Variable)

There is a variable called "Lock":
- A process can enter its critical section when Lock = 0.
- Lock = 0 means no process is currently running in the critical section; set Lock = 1 and enter the critical section.
- Once a process finishes its job in the critical section, set Lock = 0 to let other processes in the critical section.
- Lock = 1 means there is a process running in the critical section; a process does busy waiting until Lock becomes 0.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Using Lock Variable)

static int lock = 0; // lock variable is initially 0
repeat
    while lock == 0 do
        ; // (no-operation) // Busy waiting
    lock = 1;
    lock = 0;
until false

Critical Section
Remainder Section9/17/2024

Mutual Exclusion with Busy Waiting (Using Lock Variable)
COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

static int lock = 0; // lock is initially 0
repeat
    while lock == 0 do
        ; // (no-operation) // busy waiting
    lock = 1;
    lock = 0;
until false

Critical Section
Remainder Section

Scenario:
1. Initially lock = 0.
2. A process P1 tries to get into the critical section. The process P1 checks lock value = 0.
3. Process P1's CPU time is over and goes to ready state, before updating lock = 1.
4. Process P2 tries to get into the critical section. P2 checks lock value lock = 0.
5. P2 sets lock = 1 and goes to the critical section.
6. P2's CPU time is over and P1 is rescheduled.
7. P1 already read lock = 0; P1 sets lock = 1 and goes to the critical section. Now P1 and P2 are in the critical section at the same time.

Violating condition #1: mutual exclusion.

Mutual Exclusion with Busy Waiting (Strict Alternation)
- Variable turn can be i or j.
- If turn = i, process Pi can go to the critical section.
- Once Pi finishes its job in the critical section, Pi sets turn = j, letting process Pj enter the critical section.

Critical Section
Remainder Section

turn is i or j
repeat
    while turn == i do
        ; // (no-operation)
    turn = j;
until false

Let’s assume initially turn = 0:
1. P0 is in the critical section while P1 is in the remainder section.
2. P0 finishes critical section and sets turn = 1; P1 is still in the remainder section.
3. P0 finishes the remainder section and wants to go to critical section but turn = 1.
4. P1 has a fatal error in the remainder section and is trapped out by the OS.
5. P0 is waiting forever to enter the critical section.

Violating conditions:
2. No process running outside its critical region may block other processes.
3. No process should have to wait forever to enter the critical region.

Mutual Exclusion with Busy Waiting (Peterson’s Solution)
- Peterson’s solution provides a good algorithmic description of solving the critical-section problem and illustrates some of the complexities involved in designing software that addresses the requirements of mutual exclusion, progress, and bounded waiting.
- Peterson’s solution is restricted to two processes that alternate execution between their critical sections and remainder sections.
- The processes are numbered P0 and P1.
- For convenience, when presenting Pi, we use Pj to denote the other process; that is, j equals 1 - i.

#define false 0
#define true 1
#define n 2
int turn;
int interested[n];

void enter_region(int process) {
    int other;
    other = 1 - process;
    interested[process] = true;
    turn = process;
    while (turn == process && interested[other] == true)
        ; /* no operation – busy waiting */
}

void leave_region(int process) {
    interested[process] = false;
}

void main() {
    repeat
        enter_region(int i);
        Critical Section;
        leave_region(int i);
        Remainder Section;
    until false;
}

Mutual Exclusion with Busy Waiting (Peterson’s Solution)
1. Initially, neither process is in the critical section.
2. A process P0 calls enter_region(0):
   a) Set interested[0] = true;
   b) Set turn = 0.
3. P0 goes to the critical section.
4. The process P1 calls enter_region(1) to get into its critical section:
   a) Set interested[1] = true;
   b) Set turn = 1;
5. Since interested[0] = true, it keeps looping while interested[0] = false.
6. Finally, process P0 finishes its critical section and calls leave_region(0):
   1. Set interested[0] = false.
7. Now P1 finds out interested[0] = false, so P1 goes to its critical section.9/17/2024

Mutual Exclusion with Busy Waiting (Peterson’s Solution)

Prove for Peterson’s Solution:

Let's consider the case where both P0 and P1 call enter_region(0) and enter_region(1) almost simultaneously.

Let's assume interest[0] = true and interest[1] = true at the same time. However, turn can only be either turn = 0 or turn = 1; whichever store is done last is the one that counts!

Case 1: turn = 0
- Inside enter_region(0): Since turn = 0 and interest[1] = true, P0 keeps looping in no-operation until P1 sets interest[1] = false.
- Inside enter_region(1): Since turn = 0 and interest[0] = true, P1 goes to its critical section.

Case 2: turn = 1
- Inside enter_region(0): Since turn = 1 and interest[1] = true, P0 goes to its critical section.
- Inside enter_region(1): Since turn = 1 and interest[0] = true, P1 keeps looping in no-operation until P0 sets interest[0] = false.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Test and Set Lock – hardware solution)

Since the Test and Set Lock (TSL) instruction is a hardware instruction, the operations of reading the lock and storing into a register are guaranteed to be indivisible.

Instruction test and set lock:
- TSL RX, LOCK
1. Read the content at the memory address of LOCK into register RX.
2. Store a non-zero value at the memory address of LOCK.

The operations of reading the content of LOCK and storing into it are guaranteed to be indivisible.

How to use the Test and Set Lock instruction for solving race conditions:
- When LOCK = 0, any process may set LOCK = 1 by using the TSL instruction and go to its critical section.
- When the process finishes its critical section, it sets LOCK = 0 using the original move instruction.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Test and Set Lock – hardware solution)

Enter_region:
- TSL Register, LOCK
- CMP Register, #0
- JNE Enter_region
- Set LOCK, #1
- RET

Leave_region:
- MOVE LOCK, #0
- RET

Repeat:
- Enter_region
- Leave_region
until false

Critical Section
Remainder Section

Mutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)

Two general memory models:
- Strongly ordered Memory: A memory modification on one processor is immediately visible to all other processors.
- Weakly ordered Memory: A memory modification on one processor may not be immediately visible to other processors.

With strongly ordered memory, computer architectures provide instructions that can force any changes in memory to be propagated to all other processors, thereby ensuring that memory modifications are visible to threads (or processes) running on other processors.

Such instructions are known as memory barriers or memory fences.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)

A memory barrier is a type of barrier instruction that causes a central processing unit (CPU) or compiler to enforce an ordering constraint on memory operations issued before and after the barrier instruction.
This typically means that operations issued prior to the barrier are guaranteed to be performed before operations issued after the barrier.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)

Example:
Let's assume two threads (or processes) are running in different parts of a program while sharing two variables: (bool flag = false; int x = 0;)
Thread 1 might print 0 or 100 depending on the order of execution. By using a memory barrier instruction, Thread 1 always prints 100.

while (!flag)
    print x;
    x = 100;
    flag = true;

Thread 1
Thread 2Date: 9/17/2024

## Mutual Exclusion with Busy Waiting

### Memory Barriers – Hardware Solution
- It is guaranteed that the value of 'flag' is loaded before the value of 'x'.
- It is also guaranteed that the assignment to 'x' occurs before the assignment to 'flag'.
- Therefore, Thread 1 always prints 100.

**Code Example:**
```
while (!flag)
    memory_barrier();
print x;
x = 100;
memory_barrier();
flag = true;
```  

### Atomic Variables – Hardware Solution
- We can avoid mutual exclusion by using atomic operations.
- When a thread (or process) performs an atomic operation, other threads (or processes) see it as happening instantaneously.
- The advantage of atomic operations is that they are relatively quick compared to locks and do not suffer from deadlock and convoying.
- The disadvantage is that they only do a limited set of operations, which are often not enough to efficiently synthesize more complicated operations.
- Nonetheless, one should not pass up an opportunity to use an atomic operation in place of mutual exclusion.

### Priority Inversion Problem
- Various methods for mutual exclusion, such as Peterson's solution, test and set lock, memory barriers, and atomic variable methods, can lead to busy waiting and waste CPU time.
- The priority inversion problem occurs with busy waiting methods in a system with two processes: PH (high priority) and PL (low priority).
- **Scheduling Rules:** PH gets CPU time whenever it is in the ready state (preemptive priority scheduling).

1. At time T0: PL is in the critical section, and PH is in a blocked state.
2. At time T1: PH changes state from blocked to ready and tries to enter the critical section, but PL is still in the critical section.
3. Based on scheduling rules, the short-term scheduler selects PH; PH holds the CPU and tries to enter the critical section.
4. Since PL is in the critical section, PH runs busy waiting outside the critical section indefinitely because PL does not get a chance to finish its critical section.

### Process States During Priority Inversion
- At T0:
  - PL: Running state in critical section
  - PH: Blocked state

- At T1:
  - PL: Ready state in critical section
  - PH: Ready state

- After T1:
  - PL: Ready state in critical section
  - PH: Busy waiting in running state

**Note:** The CPU scheduler will always select the higher priority process.
2024-12-19 06:06:06 - INFO - Processing pages: 0, full_response: Yes
2024-12-19 06:06:06 - INFO - Created 1 tasks for question generation
2024-12-19 06:06:06 - INFO - Starting question_generate_chain
2024-12-19 06:06:06 - INFO - Setting up question generation chain
2024-12-19 06:06:06 - INFO - Chain type: <class 'langchain_core.runnables.base.RunnableSequence'>
2024-12-19 06:06:06 - INFO - Question generation chain setup complete
2024-12-19 06:06:12 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 06:06:12 - INFO - Generated 5 questions for Operating Systems with the following questions: [QAPair(question='Which of the following is NOT a solution for mutual exclusion in a critical section?', answer='Strict Alternation', q_type='multiple_choice', choices=['Disabling Interrupts', 'Lock Variables', 'Strict Alternation', 'Peterson’s Solution']), QAPair(question="Peterson's Solution is applicable for more than two processes.", answer='False', q_type='TF', choices=['True', 'False']), QAPair(question='Explain the concept of a race condition in the context of inter-process communication.', answer='A race condition occurs when two or more processes access shared data and the final outcome depends on the sequence or timing of their execution. This can lead to inconsistent results if proper synchronization mechanisms are not in place.', q_type='written', choices=[]), QAPair(question='Busy waiting techniques can lead to priority inversion problems.', answer='True', q_type='TF', choices=['True', 'False']), QAPair(question='What is the role of memory barriers in ensuring proper synchronization among threads?', answer='Memory barriers enforce an ordering constraint on memory operations, ensuring that modifications made by one thread are visible to others in the correct order. This prevents issues where one thread might read stale data because operations have not yet propagated through the memory hierarchy.', q_type='written', choices=[])]
2024-12-19 06:06:12 - INFO - Finished question_generate_chain
2024-12-19 06:06:12 - INFO - Completed question generation. Number of results: 1
2024-12-19 06:06:12 - INFO - Generated test list with 1 tests
2024-12-19 06:06:12 - INFO - Preparing judge_kwargs with 9 parameters
2024-12-19 06:06:12 - INFO - FINAL TEST:
{
    "questions": [
        {
            "question": "Which of the following is NOT a solution for mutual exclusion in a critical section?",
            "answer": "Strict Alternation",
            "q_type": "multiple_choice",
            "choices": [
                "Disabling Interrupts",
                "Lock Variables",
                "Strict Alternation",
                "Peterson\u2019s Solution"
            ]
        },
        {
            "question": "Peterson's Solution is applicable for more than two processes.",
            "answer": "False",
            "q_type": "TF",
            "choices": [
                "True",
                "False"
            ]
        },
        {
            "question": "Explain the concept of a race condition in the context of inter-process communication.",
            "answer": "A race condition occurs when two or more processes access shared data and the final outcome depends on the sequence or timing of their execution. This can lead to inconsistent results if proper synchronization mechanisms are not in place.",
            "q_type": "written",
            "choices": []
        },
        {
            "question": "Busy waiting techniques can lead to priority inversion problems.",
            "answer": "True",
            "q_type": "TF",
            "choices": [
                "True",
                "False"
            ]
        },
        {
            "question": "What is the role of memory barriers in ensuring proper synchronization among threads?",
            "answer": "Memory barriers enforce an ordering constraint on memory operations, ensuring that modifications made by one thread are visible to others in the correct order. This prevents issues where one thread might read stale data because operations have not yet propagated through the memory hierarchy.",
            "q_type": "written",
            "choices": []
        }
    ]
}
2024-12-19 06:06:12 - INFO - All tasks completed. Number of results: 1
2024-12-19 06:06:12 - INFO - Generated 1 tests
2024-12-19 06:06:12 - INFO - Cleaning up temp files
2024-12-19 06:06:12 - INFO - Deleted temp file: /tmp/tmpslgv7tee
2024-12-19 06:06:12 - INFO - Temp files cleaned
2024-12-19 06:06:12 - INFO - Run function completed
2024-12-19 06:06:12 - INFO - Test generated successfully
2024-12-19 06:31:36 - INFO - GET request received for index page
2024-12-19 07:00:56 - INFO - GET request received for index page
2024-12-19 07:04:04 - INFO - POST request received for /generate
2024-12-19 07:04:04 - INFO - Form data: title='OS' course='Operating Systems' professor='Dr. Park' number_of_written_questions=1 number_of_mcq_questions=2 number_of_TF_questions=2 level='Normal' school_type='Undergraduate' difficulty='Extreme' testing_philosophy='Fail them' url_1=None url_2=None subject_material=[UploadFile(filename='450Slides10.pdf', size=166799, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides10.pdf"', 'content-type': 'application/pdf'}))]
2024-12-19 07:04:04 - INFO - Starting run function
2024-12-19 07:04:04 - INFO - Form data accessed
2024-12-19 07:04:04 - INFO - Form Title: OS
2024-12-19 07:04:04 - INFO - Form Course: Operating Systems
2024-12-19 07:04:04 - INFO - Form Professor: Dr. Park
2024-12-19 07:04:04 - INFO - Form Number of MCQ Questions: 2
2024-12-19 07:04:04 - INFO - Form Number of TF Questions: 2
2024-12-19 07:04:04 - INFO - Form Number of Written Questions: 1
2024-12-19 07:04:04 - INFO - Form School Type: Undergraduate
2024-12-19 07:04:04 - INFO - Form Difficulty: Extreme
2024-12-19 07:04:04 - INFO - Form Testing Philosophy: Fail them
2024-12-19 07:04:04 - INFO - Moving to files...
2024-12-19 07:04:04 - INFO - Starting to process files
2024-12-19 07:04:04 - INFO - Processing file: 450Slides10.pdf
2024-12-19 07:04:04 - INFO - Getting loader for file: UploadFile(filename='450Slides10.pdf', size=166799, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides10.pdf"', 'content-type': 'application/pdf'}))
2024-12-19 07:04:04 - INFO - File extension: .pdf
2024-12-19 07:04:04 - INFO - Processing PDF file: 450Slides10.pdf
2024-12-19 07:04:04 - INFO - Using loader type: PyMuPDFLoader for UploadFile(filename='450Slides10.pdf', size=166799, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides10.pdf"', 'content-type': 'application/pdf'}))
2024-12-19 07:04:04 - INFO - URLs: []
2024-12-19 07:04:04 - INFO - Processing 1 files and 0 URLs
2024-12-19 07:04:04 - INFO - Processing 450Slides10.pdf
2024-12-19 07:04:04 - INFO - Using loader type: PyMuPDFLoader for 450Slides10.pdf
2024-12-19 07:04:04 - INFO - Processing 450Slides10.pdf as a regular document using PyMuPDFLoader
2024-12-19 07:04:04 - INFO - Successfully loaded 5 documents from: 450Slides10.pdf
2024-12-19 07:04:04 - INFO - Docs: [Document(metadata={'source': '/tmp/tmphw6reamy', 'file_path': '/tmp/tmphw6reamy', 'page': 0, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n1\nPreview\nInter-Process Communication\n\ue007Race Condition\n\ue007Critical Section (or region)\n\ue007Solutions for Mutual Exclusion in a Critical Section\n◼With Busy Waiting\n\ue007Disabling Interrupts –non-preemptive kernel\n\ue007Lock Variables –violating the first necessary condition (mutual exclusion )\n\ue007Strict Alternation –violating the second necessary condition ( block by a process outside critical section)\n\ue007Peterson’s Solution\n\ue007Hardware Solution\n▪\nTest and Set Lock –\n▪\nMemory Barriers\n▪\nAtomic Variable\n\ue007Priority Inversion problems with busy waiting\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n1\nInterprocess Communication\n\ue007\nThree issues in interprocess communication\n1.\nHow one process can pass information to another (communication\nbetween processes) – with IPCS (shared memory, message queue,\nFIFO, PIPE, socket, …)\n2.\nHow to make sure two or more processes do not get into the\ncritical section (mutual exclusion)- with mutex, semaphore\n3.\nProper sequencing (Synchronization) when dependencies are\npresent (ex. A create outputs, B consume the outputs)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n2\nInterprocess Communication\n(Race Condition)\n\ue007Race Condition\n◼A situation where two or more processes are reading or writing some shared\ndata and the final result depends on who runs precisely when, are called race\ncondition.\n\ue007Critical section (critical region)\n◼The part of program where the shared memory is accessed.\n\ue007Mutual Exclusion in a critical section can avoid races condition:\n◼If we could arrange matters such that no two processes were ever in their\ncritical regions at the same time, we can avoid races condition.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n3\nInterprocess Communication\n(Race Condition)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n4\nSlots for file names\n• When a process want\nto print a file, it enter a\nfile name in a special\nspooler directory in\nprinter\n• Printer daemon\nperiodically check\nspooler directory any file\nneed to be printed.\nShared variable\nInterprocess Communication\n(Race Condition)\n\ue007\nProcess A tried to send a job to\nspooler, Process A read in = 7,\nprocess A time out and go to ready\nstate before updating in = in + 1.\n\ue007\nProcess B tried to send a job to\nspooler. Process B read in = 7, load\nits job name in slot 7, update i = i +\n1 = 8 and then go to block state for\nwaiting for job.\n\ue007\nProcess A is rescheduled by\nscheduler. Process A already read in\n= 7, Process A load its job name in\nslot 7, update i = i + 1 = 9 and then\ngo to blocked state waiting for this\njob finish.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n5\nInterprocess Communication\n(Race Condition)\n\ue007How to avoid race condition?\nMutual exclusion – some way of making sure that if one process is using a\nshared variable or file, the other processes will be excluded from doing the same\nthing.\n\ue007The choice of the algorithm for achieving mutual exclusion is a\nmajor design issue in any operating system.\n\ue007A solution for the race condition should have following four\nconditions\n1.\nNo two processes may be simultaneously inside their critical regions – mutual\nexclusion\n2.\nNo process running outside its critical region may block other processes\n3.\nNo process should have to wait forever to enter critical region\n4.\nNo assumptions may be made about speeds or the number of CPUs.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n6\n'), Document(metadata={'source': '/tmp/tmphw6reamy', 'file_path': '/tmp/tmphw6reamy', 'page': 1, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n2\nInterprocess Communication\n(Race Condition)\n\ue007Two approaches for mutual exclusion solutions.\n◼Busy wait – A process will wait until resource become available\nor CPU time term expired.\n◼Sleep and Wakeup – A process check a resource, if not available\ngo to sleep. When the resource become available, the process\nwill be waked up by system or the process release the resource.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n7\nMutual Exclusion with Busy Waiting\n\ue007Each process has time term. A process keep checking the\npossibility to get into critical section.\n\ue007Mutual Exclusion with Busy Waiting\n◼Disabling Interrupts –non-preemptive kernel\n◼Lock Variables\n◼Strict Alternation\n◼Peterson’s Solution\n◼Hardware Solutions\n\ue007Test and Set Lock\n\ue007Memory Barriers\n\ue007Atomic Variable\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n8\nMutual Exclusion with Busy Waiting\n(Disabling Interrupt – Nonprimitive Kernel)\nDisabling Interrupt\n\ue007Once a process get into the critical section, interrupts set to disable.\n\ue007Other process cannot get CPU time until the process finish its job in\nthe critical section.\n\ue007Since each user process has power to control interrupt, it might\ncause the end of system.\n\ue007We can build a simple program which can disable entire system\nsince user has control system interrupt. (vulnerable system)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n9\nMutual Exclusion with Busy Waiting\n(Disabling Interrupt – Nonprimitive Kernel)\nEx) End of the system with Disabling interrupt\n1. A process get into the critical section.\n2. It make disable all the interrupts – which means all\nother process are sleeping until the job is done in the\ncritical section.\n3. The process has blocked outside critical section just\nbefore make enable all the interrupts and never return\nagain, cause end of the system.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n10\nMutual Exclusion with Busy Waiting\n(Using Lock Variable)\n\ue007There are variable called “Lock”\n◼A process can enter in its critical section when Lock = 0.\n◼Lock =0 means no process is currently running in the critical\nsection, set Lock =1 and enter in the critical section.\n◼Once a process finish its job in critical section, set Lock = 0 and\nlet other process in the critical section\n◼Lock = 1 means there is a process running in the critical section,\na process do busy waiting until Lock become 0.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n11\nMutual Exclusion with Busy Waiting\n(Using Lock Variable)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n12\nstatic int lock = 0; //lock variable is initially 0\nrepeat\nwhile lock \ue0060do\n; (no-operation) // Busy waiting\nlock = 1;\nlock = 0;\nuntil false\nCritical Section\nRemainder Section\n'), Document(metadata={'source': '/tmp/tmphw6reamy', 'file_path': '/tmp/tmphw6reamy', 'page': 2, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n3\nMutual Exclusion with Busy Waiting\n(Using Lock Variable)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n13\nstatic int lock = 0; //lock is initially 0\nrepeat\nwhile lock \ue0060 do\n; (no-operation) //busy waiting\nlock = 1;\nlock = 0;\nuntil false\nCritical Section\nRemainder Section\nScenario)\n1.\nInitially lock = 0.\n2.\nA process P1 tries get into critical section.\nThe process P1 check lock value = 0.\n3.\nProcess P1 CPU time is over and go to\nready state, before updating lock = 1.\n4.\nProcess P2 tries get into critical section.\nP2 check lock value lock = 0\n5.\nP2 set lock = 1 and go to critical section.\n6.\nP2 CPU time is over and P1 is rescheduled.\n7.\nP1 already read lock = 0, P1 set lock = 1\nand go to Critical section. Now P1 and P2\nare in the critical section at the same\ntime\nViolating condition #1: mutual exclusion\nMutual Exclusion with Busy Waiting\n(Strict Alternation)\n\ue007Variable turn can be i or j.\n\ue007if turn = i, process Pi can go to the\ncritical section.\n\ue007Once Pi finish its job in critical\nsection, Pi set turn = j, let process\nPj enter critical section\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n14\nCritical Section\nRemainder Section\nturn is i or j\nrepeat\nwhile turn \ue006i do\n; (no-operation)\nturn = j;\nuntil false\nMutual Exclusion with Busy Waiting\n(Strict Alternation)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n15\nCritical Section\nRemainder Section\nturn is i or j\nrepeat\nwhile turn \ue006i do\n; (no-operation)\nturn = j;\nuntil false\nLet assume initially turn = 0\n1.\nP0 is in CS while P1 is in remaining\nsection.\n2.\nP0 done C.S. and set turn = 1, P1 is\nstill in remaining section.\n3.\nP0 done remaining section and want\nto go to C.S. but turn= 1.\n4.\nP1 has fatal error in remainder\nsection and trapped out by OS.\n5.\nP0 is waiting forever to enter the C.S.\nViolating #2 and #3 condition\n2.\nNo process running outside its critical\nregion may block other processes\n3.\nNo process should have to wait forever to\nenter critical region\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\n\ue007Peterson’s solution provides a good algorithmic description of\nsolving the critical-section problem and illustrates some of the\ncomplexities involved in designing software that addresses the\nrequirements of mutual exclusion, progress, and bounded waiting.\n\ue007Peterson’s solution is restricted to two processes that alternate\nexecution between their critical sections and remainder sections.\n\ue007The processes are numbered P0 and P1.\n\ue007For convenience, when presenting Pi, we use Pj to denote the other\nprocess; that is, j equals 1 −i.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n16\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n17\n#define false 0\n#define true 1\n#define n 2\nint turn\nint interested[n]\nvoid enter_region(int process);\n{\nint other;\nother = 1 – process\ninterested[process] = true\nturn = process;\nwhile (turn ==process && interest[other]==true)\n; /*no operation –busy waiting*/\n}\nvoid leave_region(int process)\n{\ninterest[process] = false;\n}\nvoid main()\n{\nrepeat\nenter_region (int i)\nCritical Section\nleave_resion (int i)\nRemainder Section\nuntil false\n}\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\n1.\nInitially, neither process is in the critical section\n2.\nA process P0 call enter_region (0)\na)\nSet interested[0] = true;\nb)\nSet turn = 0\n3.\ngo to critical section\n4.\nthe process P1 call enter_region(1) to get into its critical section\na)\nset interested[1] = true;\nb)\nset turn = 1;\n5.\nsince interested[0] = true, it is keep looping for interest [0] =\nfalse\n6.\nfinally process P0 finish its critical section and call leave_region(0)\n1.\nset interested[0] = false\n7.\nnow P1 find out interest[0] = false, P1 goes to its critical section\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n18\n'), Document(metadata={'source': '/tmp/tmphw6reamy', 'file_path': '/tmp/tmphw6reamy', 'page': 3, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content='9/17/2024\n4\nMutual Exclusion with Busy Waiting\n(Peterson’s Solution)\nProve for Peterson’s Solution)\n\ue007\nLets consider the case both P0 and P1 call enter_region(0) and enter_region(1) almost\nsimultaneously.\n\ue007\nLets interest[0]= true and interest[1] = true at the same time\n\ue007\nBut turn can be only turn = 0 or turn = 1 which ever store is done last is the one that\ncounts!!\nCase 1) turn = 0\nInside enter_region(0)\n◼\nSince turn =0 and interest [1] = ture, P0 keep looping in no-operation until P1 set interested[1] =\nfalse.\nInside enter_region(1)\n◼\nSince turn = 0 and interest[0] = true, P1 goes to its critical section.\nCase 2) turn = 1\nInside enter_region(0)\n◼\nSince turn =1 and interest [1] = ture,. P0 goes to its critical section\nInside enter_region(1)\n◼\nSince turn = 1 and interest[0] = true, P1 keep looping in no-operation until P0 set interested[0] =\nfalse.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n19\nMutual Exclusion with Busy Waiting\n(Test and Set Lock – hardware solution)\n\ue007\nSince TSL instruction is a hardware instruction. The operations of reading the\nlock and storing into register are guaranteed to be indivisible.\n\ue007\nInstruction test and set lock\nTSL RX, LOCK\n1. Read the content at the memory address of LOCK into register RX.\n2. Store a non-zero value at the memory address of LOCK\n\ue007\nThe operations of reading the content of LOCK and storing into it are guaranteed\nto be indivisible.\n\ue007\nHow to use Test and Set Lock instruction for solving race condition?\n◼\nWhen LOCK = 0, any process may set LOCK = 1 by using TSL instruction and go to\nits critical section.\n◼\nWhen the process finish its critical section, set LOCK = 0 using the original move\ninstruction.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n20\nMutual Exclusion with Busy Waiting\n(Test and Set Lock – hardware solution)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n21\nEnter_region\nTSL Register, LOCK\nCMP Register, #0\nJNE Enter_region\nSet LOCK, #1\nRET\nLeave_region\nMOVE LOCK, #0\nRET\nRepeat\nEnter_region\nLeave_region\nuntil false\nCritical Section\nRemainder Section\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\n\ue007Two general memory models\n◼Strongly ordered Memory –a memory modification on one processor is\nimmediately visible to all other processors\n◼Weakly ordered Memory – a memory modification on one processor may not\nbe immediately visible to other processors.\n\ue007With Strongly ordered memory, computer architectures provide\ninstructions that can force any changes in memory to be\npropagated to all other processors, thereby ensuring that memory\nmodifications are visible to threads (or processes) running on other\nprocessors.\n\ue007Such instructions are known as memory barriers or memory\nfences.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n22\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\n\ue007A memory barrier is a type of barrier instruction that causes a\ncentral processing unit (CPU) or compiler to enforce an ordering\nconstraint on memory operations issued before and after the\nbarrier instruction.\n\ue007This typically means that operations issued prior to the barrier are\nguaranteed to be performed before operations issued after the\nbarrier.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n23\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\nEx)\n\ue007Lets assume two threads (or processes) are running on different\npart of program by sharing two variables. (bool flag = false; int x=0;)\n\ue007Thread 1 might print 0 or 100 depends on the order of execution.\n\ue007By using memory barrier instruction Thread1 always print 100.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n24\nwhile (!flag)\nprint x;\nx = 100\nflag = true;\nThread 1\nThread 2\n'), Document(metadata={'source': '/tmp/tmphw6reamy', 'file_path': '/tmp/tmphw6reamy', 'page': 4, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}, page_content="9/17/2024\n5\nMutual Exclusion with Busy Waiting\n(Memory Barriers– hardware solution)\n\ue007Now it is guarantee that the value of flag is loaded before the value of x\n\ue007Also it is guarantee that assignment to x occurs before the assignment to flag.\n\ue007So Thread 1 always print 100\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n25\nwhile (!flag)\nmemory_barrier();\nprint x;\nx = 100;\nmemory_barrier();\nflag = true;\nThread 1\nThread 2\nMutual Exclusion with Busy Waiting\n(Atomic Variables– hardware solution)\n\ue007We can avoid mutual exclusion by using atomic operations.\n\ue007When a thread (or process) performs an atomic operation, the\nother threads (or process) see it as happening instantaneously.\n\ue007The advantage of atomic operations is that they are relatively quick\ncompared to locks, and do not suffer from deadlock and convoying.\n\ue007The disadvantage is that they only do a limited set of operations,\nand often these are not enough to synthesize more complicated\noperations efficiently.\n\ue007But nonetheless you should not pass up an opportunity to use an\natomic operation in place of mutual exclusion.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n26\nMutual Exclusion with Busy Waiting\n(Priority Inversion Problem)\n\ue007Peterson's solution, test and set lock, Memory Barrier, Atomic variable method –\nbusy waiting – (wasting CPU time)\nPriority Inversion problem with busy waiting method\n\ue007A computer with two processes PH with high priorities, and PL with low priorities.\n\ue007The scheduling rules are such that PH get CPU time whenever it is in ready state.\n(preemptive priority scheduling)\n1. At a time T0: PL is in critical section, and PH is in block state.\n2. At a time T1: PH change sate from block to ready state and try to enter the critical\nsection. PL still in critical section.\n3. Based on scheduling rule, short-term scheduler select PH, PH hold CPU and try to enter\ninto critical section.\n4. Since PL is in critical section, PH run busy waiting outside critical section forever since\nPL does not have a chance to get CPU time to finish its critical section.\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n27\nMutual Exclusion with Busy Waiting\n(Priority Inversion Problem)\nCOSC450 Operating System, Fall2024\nDr. Sang-Eon Park\n28\nBlock\nRunning\nReady\nT0 :\nPL: running state in critical section\nPH: block state\nPH\nPL\nBlock\nRunning\nReady\nPH\nPL\nT1 : PH become ready state\nPL: ready state in critical section\nPH: ready state\nCPU scheduler will select higher\npriority process\nBlock\nRunning\nReady\nPH\nPL\nTi>1\nPL: ready state in critical section\nPH: busy waiting in running state\nPH become ready state\nScheduler keep selecting\nPH since higher priority\nThe scheduling rules : CPU scheduler will always select higher priority process.\n")] for 450Slides10.pdf using PyMuPDFLoader
2024-12-19 07:04:04 - INFO - Document 1 (450Slides10.pdf) of 5
2024-12-19 07:04:04 - INFO - Starting clean_files_chain
2024-12-19 07:04:04 - INFO - Document: page_content='9/17/2024
1
Preview
Inter-Process Communication
Race Condition
Critical Section (or region)
Solutions for Mutual Exclusion in a Critical Section
◼With Busy Waiting
Disabling Interrupts –non-preemptive kernel
Lock Variables –violating the first necessary condition (mutual exclusion )
Strict Alternation –violating the second necessary condition ( block by a process outside critical section)
Peterson’s Solution
Hardware Solution
▪
Test and Set Lock –
▪
Memory Barriers
▪
Atomic Variable
Priority Inversion problems with busy waiting
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
1
Interprocess Communication

Three issues in interprocess communication
1.
How one process can pass information to another (communication
between processes) – with IPCS (shared memory, message queue,
FIFO, PIPE, socket, …)
2.
How to make sure two or more processes do not get into the
critical section (mutual exclusion)- with mutex, semaphore
3.
Proper sequencing (Synchronization) when dependencies are
present (ex. A create outputs, B consume the outputs)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
2
Interprocess Communication
(Race Condition)
Race Condition
◼A situation where two or more processes are reading or writing some shared
data and the final result depends on who runs precisely when, are called race
condition.
Critical section (critical region)
◼The part of program where the shared memory is accessed.
Mutual Exclusion in a critical section can avoid races condition:
◼If we could arrange matters such that no two processes were ever in their
critical regions at the same time, we can avoid races condition.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
3
Interprocess Communication
(Race Condition)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
4
Slots for file names
• When a process want
to print a file, it enter a
file name in a special
spooler directory in
printer
• Printer daemon
periodically check
spooler directory any file
need to be printed.
Shared variable
Interprocess Communication
(Race Condition)

Process A tried to send a job to
spooler, Process A read in = 7,
process A time out and go to ready
state before updating in = in + 1.

Process B tried to send a job to
spooler. Process B read in = 7, load
its job name in slot 7, update i = i +
1 = 8 and then go to block state for
waiting for job.

Process A is rescheduled by
scheduler. Process A already read in
= 7, Process A load its job name in
slot 7, update i = i + 1 = 9 and then
go to blocked state waiting for this
job finish.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
5
Interprocess Communication
(Race Condition)
How to avoid race condition?
Mutual exclusion – some way of making sure that if one process is using a
shared variable or file, the other processes will be excluded from doing the same
thing.
The choice of the algorithm for achieving mutual exclusion is a
major design issue in any operating system.
A solution for the race condition should have following four
conditions
1.
No two processes may be simultaneously inside their critical regions – mutual
exclusion
2.
No process running outside its critical region may block other processes
3.
No process should have to wait forever to enter critical region
4.
No assumptions may be made about speeds or the number of CPUs.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
6
' metadata={'source': '/tmp/tmphw6reamy', 'file_path': '/tmp/tmphw6reamy', 'page': 0, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-19 07:04:04 - INFO - Invoking chain
2024-12-19 07:04:18 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 07:04:18 - INFO - Response: {'cleaned_content': '9/17/2024\n\nInter-Process Communication\n\n- Race Condition\n- Critical Section (or region)\n- Solutions for Mutual Exclusion in a Critical Section\n  - With Busy Waiting\n    - Disabling Interrupts – non-preemptive kernel\n    - Lock Variables – violating the first necessary condition (mutual exclusion)\n    - Strict Alternation – violating the second necessary condition (block by a process outside critical section)\n    - Peterson’s Solution\n    - Hardware Solution\n      - Test and Set Lock\n      - Memory Barriers\n      - Atomic Variable\n  - Priority Inversion problems with busy waiting\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nInterprocess Communication\n\nThree issues in interprocess communication:\n1. How one process can pass information to another (communication between processes) – with IPCS (shared memory, message queue, FIFO, PIPE, socket, etc.)\n2. How to make sure two or more processes do not get into the critical section (mutual exclusion) – with mutex, semaphore\n3. Proper sequencing (Synchronization) when dependencies are present (e.g., A creates outputs, B consumes the outputs)\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nRace Condition\n\n- A situation where two or more processes are reading or writing some shared data and the final result depends on who runs precisely when, are called race condition.\n\nCritical section (critical region)\n\n- The part of the program where the shared memory is accessed.\n\nMutual Exclusion in a critical section can avoid race conditions:\n- If we could arrange matters such that no two processes were ever in their critical regions at the same time, we can avoid race conditions.\n\nSlots for file names:\n- When a process wants to print a file, it enters a file name in a special spooler directory in the printer.\n- The printer daemon periodically checks the spooler directory for any file that needs to be printed.\n\nShared variable\n\nRace Condition:\n- Process A tries to send a job to the spooler. Process A reads in = 7, process A times out and goes to ready state before updating in = in + 1.\n- Process B tries to send a job to the spooler. Process B reads in = 7, loads its job name in slot 7, updates i = i + 1 = 8, and then goes to blocked state waiting for the job.\n- Process A is rescheduled by the scheduler. Process A already read in = 7. Process A loads its job name in slot 7, updates i = i + 1 = 9, and then goes to blocked state waiting for this job to finish.\n\nHow to avoid race conditions?\n- Mutual exclusion – some way of making sure that if one process is using a shared variable or file, the other processes will be excluded from doing the same thing.\n- The choice of the algorithm for achieving mutual exclusion is a major design issue in any operating system.\n- A solution for the race condition should have the following four conditions:\n  1. No two processes may be simultaneously inside their critical regions – mutual exclusion\n  2. No process running outside its critical region may block other processes\n  3. No process should have to wait forever to enter the critical region\n  4. No assumptions may be made about speeds or the number of CPUs.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park'}
2024-12-19 07:04:18 - INFO - Finished clean_files_chain
2024-12-19 07:04:18 - INFO - Successfully cleaned document 1 from 450Slides10.pdf
2024-12-19 07:04:18 - INFO - Document 2 (450Slides10.pdf) of 5
2024-12-19 07:04:18 - INFO - Starting clean_files_chain
2024-12-19 07:04:18 - INFO - Document: page_content='9/17/2024
2
Interprocess Communication
(Race Condition)
Two approaches for mutual exclusion solutions.
◼Busy wait – A process will wait until resource become available
or CPU time term expired.
◼Sleep and Wakeup – A process check a resource, if not available
go to sleep. When the resource become available, the process
will be waked up by system or the process release the resource.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
7
Mutual Exclusion with Busy Waiting
Each process has time term. A process keep checking the
possibility to get into critical section.
Mutual Exclusion with Busy Waiting
◼Disabling Interrupts –non-preemptive kernel
◼Lock Variables
◼Strict Alternation
◼Peterson’s Solution
◼Hardware Solutions
Test and Set Lock
Memory Barriers
Atomic Variable
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
8
Mutual Exclusion with Busy Waiting
(Disabling Interrupt – Nonprimitive Kernel)
Disabling Interrupt
Once a process get into the critical section, interrupts set to disable.
Other process cannot get CPU time until the process finish its job in
the critical section.
Since each user process has power to control interrupt, it might
cause the end of system.
We can build a simple program which can disable entire system
since user has control system interrupt. (vulnerable system)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
9
Mutual Exclusion with Busy Waiting
(Disabling Interrupt – Nonprimitive Kernel)
Ex) End of the system with Disabling interrupt
1. A process get into the critical section.
2. It make disable all the interrupts – which means all
other process are sleeping until the job is done in the
critical section.
3. The process has blocked outside critical section just
before make enable all the interrupts and never return
again, cause end of the system.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
10
Mutual Exclusion with Busy Waiting
(Using Lock Variable)
There are variable called “Lock”
◼A process can enter in its critical section when Lock = 0.
◼Lock =0 means no process is currently running in the critical
section, set Lock =1 and enter in the critical section.
◼Once a process finish its job in critical section, set Lock = 0 and
let other process in the critical section
◼Lock = 1 means there is a process running in the critical section,
a process do busy waiting until Lock become 0.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
11
Mutual Exclusion with Busy Waiting
(Using Lock Variable)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
12
static int lock = 0; //lock variable is initially 0
repeat
while lock 0do
; (no-operation) // Busy waiting
lock = 1;
lock = 0;
until false
Critical Section
Remainder Section
' metadata={'source': '/tmp/tmphw6reamy', 'file_path': '/tmp/tmphw6reamy', 'page': 1, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-19 07:04:18 - INFO - Invoking chain
2024-12-19 07:04:31 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 07:04:31 - INFO - Response: {'cleaned_content': '9/17/2024\n\nInterprocess Communication (Race Condition)\n\nTwo approaches for mutual exclusion solutions:\n1. Busy wait – A process will wait until the resource becomes available or the CPU time term expires.\n2. Sleep and Wakeup – A process checks a resource; if it is not available, it goes to sleep. When the resource becomes available, the process will be woken up by the system or the process releases the resource.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting\n\nEach process has a time term. A process keeps checking the possibility of entering the critical section.\n\nMethods of Mutual Exclusion with Busy Waiting:\n- Disabling Interrupts – non-preemptive kernel\n- Lock Variables\n- Strict Alternation\n- Peterson’s Solution\n- Hardware Solutions\n- Test and Set Lock\n- Memory Barriers\n- Atomic Variable\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Disabling Interrupt – Nonprimitive Kernel)\n\nDisabling Interrupt:\n- Once a process enters the critical section, interrupts are set to disable.\n- Other processes cannot get CPU time until the process finishes its job in the critical section.\n- Since each user process has the power to control interrupts, it might cause the end of the system.\n- We can build a simple program that can disable the entire system since the user has control over system interrupts (vulnerable system).\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nExample: End of the system with Disabling Interrupt\n1. A process enters the critical section.\n2. It disables all the interrupts, meaning all other processes are sleeping until the job is done in the critical section.\n3. The process is blocked outside the critical section just before enabling all the interrupts and never returns again, causing the end of the system.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Using Lock Variable)\n\nThere is a variable called "Lock":\n- A process can enter its critical section when Lock = 0.\n- Lock = 0 means no process is currently running in the critical section; set Lock = 1 and enter the critical section.\n- Once a process finishes its job in the critical section, it sets Lock = 0 to let other processes enter the critical section.\n- Lock = 1 means there is a process running in the critical section; a process will do busy waiting until Lock becomes 0.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nCode Example:\nstatic int lock = 0; // lock variable is initially 0\nrepeat\n    while (lock == 0) do\n        ; // (no-operation) // Busy waiting\n    lock = 1;\n    lock = 0;\nuntil false\n\nCritical Section\nRemainder Section'}
2024-12-19 07:04:31 - INFO - Finished clean_files_chain
2024-12-19 07:04:31 - INFO - Successfully cleaned document 2 from 450Slides10.pdf
2024-12-19 07:04:31 - INFO - Document 3 (450Slides10.pdf) of 5
2024-12-19 07:04:31 - INFO - Starting clean_files_chain
2024-12-19 07:04:31 - INFO - Document: page_content='9/17/2024
3
Mutual Exclusion with Busy Waiting
(Using Lock Variable)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
13
static int lock = 0; //lock is initially 0
repeat
while lock 0 do
; (no-operation) //busy waiting
lock = 1;
lock = 0;
until false
Critical Section
Remainder Section
Scenario)
1.
Initially lock = 0.
2.
A process P1 tries get into critical section.
The process P1 check lock value = 0.
3.
Process P1 CPU time is over and go to
ready state, before updating lock = 1.
4.
Process P2 tries get into critical section.
P2 check lock value lock = 0
5.
P2 set lock = 1 and go to critical section.
6.
P2 CPU time is over and P1 is rescheduled.
7.
P1 already read lock = 0, P1 set lock = 1
and go to Critical section. Now P1 and P2
are in the critical section at the same
time
Violating condition #1: mutual exclusion
Mutual Exclusion with Busy Waiting
(Strict Alternation)
Variable turn can be i or j.
if turn = i, process Pi can go to the
critical section.
Once Pi finish its job in critical
section, Pi set turn = j, let process
Pj enter critical section
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
14
Critical Section
Remainder Section
turn is i or j
repeat
while turn i do
; (no-operation)
turn = j;
until false
Mutual Exclusion with Busy Waiting
(Strict Alternation)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
15
Critical Section
Remainder Section
turn is i or j
repeat
while turn i do
; (no-operation)
turn = j;
until false
Let assume initially turn = 0
1.
P0 is in CS while P1 is in remaining
section.
2.
P0 done C.S. and set turn = 1, P1 is
still in remaining section.
3.
P0 done remaining section and want
to go to C.S. but turn= 1.
4.
P1 has fatal error in remainder
section and trapped out by OS.
5.
P0 is waiting forever to enter the C.S.
Violating #2 and #3 condition
2.
No process running outside its critical
region may block other processes
3.
No process should have to wait forever to
enter critical region
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
Peterson’s solution provides a good algorithmic description of
solving the critical-section problem and illustrates some of the
complexities involved in designing software that addresses the
requirements of mutual exclusion, progress, and bounded waiting.
Peterson’s solution is restricted to two processes that alternate
execution between their critical sections and remainder sections.
The processes are numbered P0 and P1.
For convenience, when presenting Pi, we use Pj to denote the other
process; that is, j equals 1 −i.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
16
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
17
#define false 0
#define true 1
#define n 2
int turn
int interested[n]
void enter_region(int process);
{
int other;
other = 1 – process
interested[process] = true
turn = process;
while (turn ==process && interest[other]==true)
; /*no operation –busy waiting*/
}
void leave_region(int process)
{
interest[process] = false;
}
void main()
{
repeat
enter_region (int i)
Critical Section
leave_resion (int i)
Remainder Section
until false
}
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
1.
Initially, neither process is in the critical section
2.
A process P0 call enter_region (0)
a)
Set interested[0] = true;
b)
Set turn = 0
3.
go to critical section
4.
the process P1 call enter_region(1) to get into its critical section
a)
set interested[1] = true;
b)
set turn = 1;
5.
since interested[0] = true, it is keep looping for interest [0] =
false
6.
finally process P0 finish its critical section and call leave_region(0)
1.
set interested[0] = false
7.
now P1 find out interest[0] = false, P1 goes to its critical section
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
18
' metadata={'source': '/tmp/tmphw6reamy', 'file_path': '/tmp/tmphw6reamy', 'page': 2, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-19 07:04:31 - INFO - Invoking chain
2024-12-19 07:04:45 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 07:04:45 - INFO - Response: {'cleaned_content': "9/17/2024\n\nMutual Exclusion with Busy Waiting (Using Lock Variable)\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nstatic int lock = 0; // lock is initially 0\nrepeat\n    while lock == 0 do\n        ; // (no-operation) // busy waiting\n    lock = 1;\n    lock = 0;\nuntil false\n\nCritical Section\nRemainder Section\n\nScenario:\n1. Initially lock = 0.\n2. A process P1 tries to get into the critical section.\n3. The process P1 checks lock value = 0.\n4. Process P1's CPU time is over and goes to ready state, before updating lock = 1.\n5. Process P2 tries to get into the critical section.\n6. P2 checks lock value lock = 0.\n7. P2 sets lock = 1 and goes to critical section.\n8. P2's CPU time is over and P1 is rescheduled.\n9. P1 already read lock = 0, P1 sets lock = 1 and goes to the critical section. Now P1 and P2 are in the critical section at the same time.\n   Violating condition #1: mutual exclusion.\n\nMutual Exclusion with Busy Waiting (Strict Alternation)\n- Variable turn can be i or j.\n- If turn = i, process Pi can go to the critical section.\n- Once Pi finishes its job in the critical section, Pi sets turn = j, allowing process Pj to enter the critical section.\n\nCritical Section\nRemainder Section\nTurn is i or j\nrepeat\n    while turn == i do\n        ; // (no-operation)\n    turn = j;\nuntil false\n\nLet us assume initially turn = 0:\n1. P0 is in the critical section while P1 is in the remainder section.\n2. P0 completes the critical section and sets turn = 1, while P1 is still in the remainder section.\n3. P0 finishes the remainder section and wants to go to the critical section, but turn = 1.\n4. P1 encounters a fatal error in the remainder section and is trapped out by the OS.\n5. P0 is waiting forever to enter the critical section.\n   Violating conditions:\n   2. No process running outside its critical region may block other processes.\n   3. No process should have to wait forever to enter the critical region.\n\nMutual Exclusion with Busy Waiting (Peterson’s Solution)\n- Peterson’s solution provides a good algorithmic description of solving the critical-section problem and illustrates some of the complexities involved in designing software that addresses the requirements of mutual exclusion, progress, and bounded waiting.\n- Peterson’s solution is restricted to two processes that alternate execution between their critical sections and remainder sections.\n- The processes are numbered P0 and P1.\n- For convenience, when presenting Pi, we use Pj to denote the other process; that is, j equals 1 - i.\n\n#define false 0\n#define true 1\n#define n 2\nint turn;\nint interested[n];\nvoid enter_region(int process) {\n    int other;\n    other = 1 - process;\n    interested[process] = true;\n    turn = process;\n    while (turn == process && interested[other] == true)\n        ; // no operation – busy waiting\n}\nvoid leave_region(int process) {\n    interested[process] = false;\n}\nvoid main() {\n    repeat\n        enter_region(int i);\n        Critical Section;\n        leave_region(int i);\n        Remainder Section;\n    until false;\n}\n\nMutual Exclusion with Busy Waiting (Peterson’s Solution)\n1. Initially, neither process is in the critical section.\n2. A process P0 calls enter_region(0):\n   a) Set interested[0] = true;\n   b) Set turn = 0;\n3. Go to the critical section.\n4. The process P1 calls enter_region(1) to get into its critical section:\n   a) Set interested[1] = true;\n   b) Set turn = 1;\n5. Since interested[0] = true, it keeps looping for interested[0] = false.\n6. Finally, process P0 finishes its critical section and calls leave_region(0):\n   1. Set interested[0] = false;\n7. Now P1 finds out interested[0] = false, and P1 goes to its critical section."}
2024-12-19 07:04:45 - INFO - Finished clean_files_chain
2024-12-19 07:04:45 - INFO - Successfully cleaned document 3 from 450Slides10.pdf
2024-12-19 07:04:45 - INFO - Document 4 (450Slides10.pdf) of 5
2024-12-19 07:04:45 - INFO - Starting clean_files_chain
2024-12-19 07:04:45 - INFO - Document: page_content='9/17/2024
4
Mutual Exclusion with Busy Waiting
(Peterson’s Solution)
Prove for Peterson’s Solution)

Lets consider the case both P0 and P1 call enter_region(0) and enter_region(1) almost
simultaneously.

Lets interest[0]= true and interest[1] = true at the same time

But turn can be only turn = 0 or turn = 1 which ever store is done last is the one that
counts!!
Case 1) turn = 0
Inside enter_region(0)
◼
Since turn =0 and interest [1] = ture, P0 keep looping in no-operation until P1 set interested[1] =
false.
Inside enter_region(1)
◼
Since turn = 0 and interest[0] = true, P1 goes to its critical section.
Case 2) turn = 1
Inside enter_region(0)
◼
Since turn =1 and interest [1] = ture,. P0 goes to its critical section
Inside enter_region(1)
◼
Since turn = 1 and interest[0] = true, P1 keep looping in no-operation until P0 set interested[0] =
false.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
19
Mutual Exclusion with Busy Waiting
(Test and Set Lock – hardware solution)

Since TSL instruction is a hardware instruction. The operations of reading the
lock and storing into register are guaranteed to be indivisible.

Instruction test and set lock
TSL RX, LOCK
1. Read the content at the memory address of LOCK into register RX.
2. Store a non-zero value at the memory address of LOCK

The operations of reading the content of LOCK and storing into it are guaranteed
to be indivisible.

How to use Test and Set Lock instruction for solving race condition?
◼
When LOCK = 0, any process may set LOCK = 1 by using TSL instruction and go to
its critical section.
◼
When the process finish its critical section, set LOCK = 0 using the original move
instruction.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
20
Mutual Exclusion with Busy Waiting
(Test and Set Lock – hardware solution)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
21
Enter_region
TSL Register, LOCK
CMP Register, #0
JNE Enter_region
Set LOCK, #1
RET
Leave_region
MOVE LOCK, #0
RET
Repeat
Enter_region
Leave_region
until false
Critical Section
Remainder Section
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
Two general memory models
◼Strongly ordered Memory –a memory modification on one processor is
immediately visible to all other processors
◼Weakly ordered Memory – a memory modification on one processor may not
be immediately visible to other processors.
With Strongly ordered memory, computer architectures provide
instructions that can force any changes in memory to be
propagated to all other processors, thereby ensuring that memory
modifications are visible to threads (or processes) running on other
processors.
Such instructions are known as memory barriers or memory
fences.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
22
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
A memory barrier is a type of barrier instruction that causes a
central processing unit (CPU) or compiler to enforce an ordering
constraint on memory operations issued before and after the
barrier instruction.
This typically means that operations issued prior to the barrier are
guaranteed to be performed before operations issued after the
barrier.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
23
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
Ex)
Lets assume two threads (or processes) are running on different
part of program by sharing two variables. (bool flag = false; int x=0;)
Thread 1 might print 0 or 100 depends on the order of execution.
By using memory barrier instruction Thread1 always print 100.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
24
while (!flag)
print x;
x = 100
flag = true;
Thread 1
Thread 2
' metadata={'source': '/tmp/tmphw6reamy', 'file_path': '/tmp/tmphw6reamy', 'page': 3, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-19 07:04:45 - INFO - Invoking chain
2024-12-19 07:05:01 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 07:05:01 - INFO - Response: {'cleaned_content': "9/17/2024\n\nMutual Exclusion with Busy Waiting (Peterson’s Solution)\n\nProve for Peterson’s Solution:\n\nLet's consider the case where both P0 and P1 call enter_region(0) and enter_region(1) almost simultaneously.\n\nLet's set interest[0] = true and interest[1] = true at the same time. However, turn can only be either turn = 0 or turn = 1, whichever store is done last is the one that counts.\n\nCase 1: turn = 0\n- Inside enter_region(0):\n  - Since turn = 0 and interest[1] = true, P0 keeps looping in no-operation until P1 sets interest[1] = false.\n\n- Inside enter_region(1):\n  - Since turn = 0 and interest[0] = true, P1 goes to its critical section.\n\nCase 2: turn = 1\n- Inside enter_region(0):\n  - Since turn = 1 and interest[1] = true, P0 goes to its critical section.\n\n- Inside enter_region(1):\n  - Since turn = 1 and interest[0] = true, P1 keeps looping in no-operation until P0 sets interest[0] = false.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Busy Waiting (Test and Set Lock – hardware solution)\n\nSince the Test and Set Lock (TSL) instruction is a hardware instruction, the operations of reading the lock and storing into a register are guaranteed to be indivisible.\n\nInstruction test and set lock: TSL RX, LOCK\n1. Read the content at the memory address of LOCK into register RX.\n2. Store a non-zero value at the memory address of LOCK.\n\nThe operations of reading the content of LOCK and storing into it are guaranteed to be indivisible.\n\nHow to use the Test and Set Lock instruction for solving race conditions:\n- When LOCK = 0, any process may set LOCK = 1 by using the TSL instruction and go to its critical section.\n- When the process finishes its critical section, it sets LOCK = 0 using the original move instruction.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nEnter_region:\n- TSL Register, LOCK\n- CMP Register, #0\n- JNE Enter_region\n- Set LOCK, #1\n- RET\n\nLeave_region:\n- MOVE LOCK, #0\n- RET\n\nRepeat:\n- Enter_region\n- Leave_region\n- until false\n\nCritical Section\nRemainder Section\n\nMutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)\n\nTwo general memory models:\n- Strongly ordered Memory: A memory modification on one processor is immediately visible to all other processors.\n- Weakly ordered Memory: A memory modification on one processor may not be immediately visible to other processors.\n\nWith strongly ordered memory, computer architectures provide instructions that can force any changes in memory to be propagated to all other processors, thereby ensuring that memory modifications are visible to threads (or processes) running on other processors. Such instructions are known as memory barriers or memory fences.\n\nMutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)\n\nA memory barrier is a type of barrier instruction that causes a central processing unit (CPU) or compiler to enforce an ordering constraint on memory operations issued before and after the barrier instruction. This typically means that operations issued prior to the barrier are guaranteed to be performed before operations issued after the barrier.\n\nMutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)\nExample:\n- Let's assume two threads (or processes) are running on different parts of the program by sharing two variables: (bool flag = false; int x = 0;).\n- Thread 1 might print 0 or 100 depending on the order of execution.\n- By using a memory barrier instruction, Thread 1 always prints 100.\n\nwhile (!flag)\n    print x;\n    x = 100;\n    flag = true;\n\nThread 1\nThread 2"}
2024-12-19 07:05:01 - INFO - Finished clean_files_chain
2024-12-19 07:05:01 - INFO - Successfully cleaned document 4 from 450Slides10.pdf
2024-12-19 07:05:01 - INFO - Document 5 (450Slides10.pdf) of 5
2024-12-19 07:05:01 - INFO - Starting clean_files_chain
2024-12-19 07:05:01 - INFO - Document: page_content='9/17/2024
5
Mutual Exclusion with Busy Waiting
(Memory Barriers– hardware solution)
Now it is guarantee that the value of flag is loaded before the value of x
Also it is guarantee that assignment to x occurs before the assignment to flag.
So Thread 1 always print 100
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
25
while (!flag)
memory_barrier();
print x;
x = 100;
memory_barrier();
flag = true;
Thread 1
Thread 2
Mutual Exclusion with Busy Waiting
(Atomic Variables– hardware solution)
We can avoid mutual exclusion by using atomic operations.
When a thread (or process) performs an atomic operation, the
other threads (or process) see it as happening instantaneously.
The advantage of atomic operations is that they are relatively quick
compared to locks, and do not suffer from deadlock and convoying.
The disadvantage is that they only do a limited set of operations,
and often these are not enough to synthesize more complicated
operations efficiently.
But nonetheless you should not pass up an opportunity to use an
atomic operation in place of mutual exclusion.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
26
Mutual Exclusion with Busy Waiting
(Priority Inversion Problem)
Peterson's solution, test and set lock, Memory Barrier, Atomic variable method –
busy waiting – (wasting CPU time)
Priority Inversion problem with busy waiting method
A computer with two processes PH with high priorities, and PL with low priorities.
The scheduling rules are such that PH get CPU time whenever it is in ready state.
(preemptive priority scheduling)
1. At a time T0: PL is in critical section, and PH is in block state.
2. At a time T1: PH change sate from block to ready state and try to enter the critical
section. PL still in critical section.
3. Based on scheduling rule, short-term scheduler select PH, PH hold CPU and try to enter
into critical section.
4. Since PL is in critical section, PH run busy waiting outside critical section forever since
PL does not have a chance to get CPU time to finish its critical section.
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
27
Mutual Exclusion with Busy Waiting
(Priority Inversion Problem)
COSC450 Operating System, Fall2024
Dr. Sang-Eon Park
28
Block
Running
Ready
T0 :
PL: running state in critical section
PH: block state
PH
PL
Block
Running
Ready
PH
PL
T1 : PH become ready state
PL: ready state in critical section
PH: ready state
CPU scheduler will select higher
priority process
Block
Running
Ready
PH
PL
Ti>1
PL: ready state in critical section
PH: busy waiting in running state
PH become ready state
Scheduler keep selecting
PH since higher priority
The scheduling rules : CPU scheduler will always select higher priority process.
' metadata={'source': '/tmp/tmphw6reamy', 'file_path': '/tmp/tmphw6reamy', 'page': 4, 'total_pages': 5, 'format': 'PDF 1.7', 'title': '', 'author': '', 'subject': '', 'keywords': '', 'creator': 'Mozilla Firefox 132.0.2', 'producer': 'cairo 1.18.0 (https://cairographics.org)', 'creationDate': "D:20241212024700-05'00", 'modDate': '', 'trapped': ''}
2024-12-19 07:05:01 - INFO - Invoking chain
2024-12-19 07:05:09 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 07:05:09 - INFO - Response: {'cleaned_content': "9/17/2024\n\nMutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)\n\n- It is guaranteed that the value of flag is loaded before the value of x.\n- It is also guaranteed that the assignment to x occurs before the assignment to flag.\n- Therefore, Thread 1 will always print 100.\n\nCode Example:\n\nwhile (!flag) {\n    memory_barrier();\n}\nprint x;\n x = 100;\nmemory_barrier();\nflag = true;\n\nThread 1\nThread 2\n\nMutual Exclusion with Busy Waiting (Atomic Variables – hardware solution)\n\n- We can avoid mutual exclusion by using atomic operations.\n- When a thread (or process) performs an atomic operation, the other threads (or processes) see it as happening instantaneously.\n- The advantage of atomic operations is that they are relatively quick compared to locks, and do not suffer from deadlock and convoying.\n- The disadvantage is that they only allow a limited set of operations, and often these are not enough to synthesize more complicated operations efficiently.\n- Nonetheless, you should not pass up an opportunity to use an atomic operation in place of mutual exclusion.\n\nMutual Exclusion with Busy Waiting (Priority Inversion Problem)\n\n- Peterson's solution, test and set lock, Memory Barrier, and Atomic variable method – busy waiting – can waste CPU time.\n- The Priority Inversion problem with busy waiting method occurs in a system with two processes: PH (high priority) and PL (low priority).\n- The scheduling rules dictate that PH gets CPU time whenever it is in a ready state (preemptive priority scheduling).\n\n1. At time T0: PL is in the critical section, and PH is in a blocked state.\n2. At time T1: PH changes state from blocked to ready and attempts to enter the critical section, but PL is still in the critical section.\n3. Based on the scheduling rule, the short-term scheduler selects PH, which holds the CPU and tries to enter the critical section.\n4. Since PL is in the critical section, PH will be busy waiting outside forever because PL does not have a chance to finish its critical section.\n\nThe scheduling rules state that the CPU scheduler will always select the higher priority process."}
2024-12-19 07:05:09 - INFO - Finished clean_files_chain
2024-12-19 07:05:09 - INFO - Successfully cleaned document 5 from 450Slides10.pdf
2024-12-19 07:05:09 - INFO - Pages: []
2024-12-19 07:05:09 - INFO - Full response: 9/17/2024

Inter-Process Communication

- Race Condition
- Critical Section (or region)
- Solutions for Mutual Exclusion in a Critical Section
  - With Busy Waiting
    - Disabling Interrupts – non-preemptive kernel
    - Lock Variables – violating the first necessary condition (mutual exclusion)
    - Strict Alternation – violating the second necessary condition (block by a process outside critical section)
    - Peterson’s Solution
    - Hardware Solution
      - Test and Set Lock
      - Memory Barriers
      - Atomic Variable
  - Priority Inversion problems with busy waiting

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Interprocess Communication

Three issues in interprocess communication:
1. How one process can pass information to another (communication between processes) – with IPCS (shared memory, message queue, FIFO, PIPE, socket, etc.)
2. How to make sure two or more processes do not get into the critical section (mutual exclusion) – with mutex, semaphore
3. Proper sequencing (Synchronization) when dependencies are present (e.g., A creates outputs, B consumes the outputs)

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Race Condition

- A situation where two or more processes are reading or writing some shared data and the final result depends on who runs precisely when, are called race condition.

Critical section (critical region)

- The part of the program where the shared memory is accessed.

Mutual Exclusion in a critical section can avoid race conditions:
- If we could arrange matters such that no two processes were ever in their critical regions at the same time, we can avoid race conditions.

Slots for file names:
- When a process wants to print a file, it enters a file name in a special spooler directory in the printer.
- The printer daemon periodically checks the spooler directory for any file that needs to be printed.

Shared variable

Race Condition:
- Process A tries to send a job to the spooler. Process A reads in = 7, process A times out and goes to ready state before updating in = in + 1.
- Process B tries to send a job to the spooler. Process B reads in = 7, loads its job name in slot 7, updates i = i + 1 = 8, and then goes to blocked state waiting for the job.
- Process A is rescheduled by the scheduler. Process A already read in = 7. Process A loads its job name in slot 7, updates i = i + 1 = 9, and then goes to blocked state waiting for this job to finish.

How to avoid race conditions?
- Mutual exclusion – some way of making sure that if one process is using a shared variable or file, the other processes will be excluded from doing the same thing.
- The choice of the algorithm for achieving mutual exclusion is a major design issue in any operating system.
- A solution for the race condition should have the following four conditions:
  1. No two processes may be simultaneously inside their critical regions – mutual exclusion
  2. No process running outside its critical region may block other processes
  3. No process should have to wait forever to enter the critical region
  4. No assumptions may be made about speeds or the number of CPUs.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park9/17/2024

Interprocess Communication (Race Condition)

Two approaches for mutual exclusion solutions:
1. Busy wait – A process will wait until the resource becomes available or the CPU time term expires.
2. Sleep and Wakeup – A process checks a resource; if it is not available, it goes to sleep. When the resource becomes available, the process will be woken up by the system or the process releases the resource.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting

Each process has a time term. A process keeps checking the possibility of entering the critical section.

Methods of Mutual Exclusion with Busy Waiting:
- Disabling Interrupts – non-preemptive kernel
- Lock Variables
- Strict Alternation
- Peterson’s Solution
- Hardware Solutions
- Test and Set Lock
- Memory Barriers
- Atomic Variable

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Disabling Interrupt – Nonprimitive Kernel)

Disabling Interrupt:
- Once a process enters the critical section, interrupts are set to disable.
- Other processes cannot get CPU time until the process finishes its job in the critical section.
- Since each user process has the power to control interrupts, it might cause the end of the system.
- We can build a simple program that can disable the entire system since the user has control over system interrupts (vulnerable system).

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Example: End of the system with Disabling Interrupt
1. A process enters the critical section.
2. It disables all the interrupts, meaning all other processes are sleeping until the job is done in the critical section.
3. The process is blocked outside the critical section just before enabling all the interrupts and never returns again, causing the end of the system.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Using Lock Variable)

There is a variable called "Lock":
- A process can enter its critical section when Lock = 0.
- Lock = 0 means no process is currently running in the critical section; set Lock = 1 and enter the critical section.
- Once a process finishes its job in the critical section, it sets Lock = 0 to let other processes enter the critical section.
- Lock = 1 means there is a process running in the critical section; a process will do busy waiting until Lock becomes 0.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Code Example:
static int lock = 0; // lock variable is initially 0
repeat
    while (lock == 0) do
        ; // (no-operation) // Busy waiting
    lock = 1;
    lock = 0;
until false

Critical Section
Remainder Section9/17/2024

Mutual Exclusion with Busy Waiting (Using Lock Variable)
COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

static int lock = 0; // lock is initially 0
repeat
    while lock == 0 do
        ; // (no-operation) // busy waiting
    lock = 1;
    lock = 0;
until false

Critical Section
Remainder Section

Scenario:
1. Initially lock = 0.
2. A process P1 tries to get into the critical section.
3. The process P1 checks lock value = 0.
4. Process P1's CPU time is over and goes to ready state, before updating lock = 1.
5. Process P2 tries to get into the critical section.
6. P2 checks lock value lock = 0.
7. P2 sets lock = 1 and goes to critical section.
8. P2's CPU time is over and P1 is rescheduled.
9. P1 already read lock = 0, P1 sets lock = 1 and goes to the critical section. Now P1 and P2 are in the critical section at the same time.
   Violating condition #1: mutual exclusion.

Mutual Exclusion with Busy Waiting (Strict Alternation)
- Variable turn can be i or j.
- If turn = i, process Pi can go to the critical section.
- Once Pi finishes its job in the critical section, Pi sets turn = j, allowing process Pj to enter the critical section.

Critical Section
Remainder Section
Turn is i or j
repeat
    while turn == i do
        ; // (no-operation)
    turn = j;
until false

Let us assume initially turn = 0:
1. P0 is in the critical section while P1 is in the remainder section.
2. P0 completes the critical section and sets turn = 1, while P1 is still in the remainder section.
3. P0 finishes the remainder section and wants to go to the critical section, but turn = 1.
4. P1 encounters a fatal error in the remainder section and is trapped out by the OS.
5. P0 is waiting forever to enter the critical section.
   Violating conditions:
   2. No process running outside its critical region may block other processes.
   3. No process should have to wait forever to enter the critical region.

Mutual Exclusion with Busy Waiting (Peterson’s Solution)
- Peterson’s solution provides a good algorithmic description of solving the critical-section problem and illustrates some of the complexities involved in designing software that addresses the requirements of mutual exclusion, progress, and bounded waiting.
- Peterson’s solution is restricted to two processes that alternate execution between their critical sections and remainder sections.
- The processes are numbered P0 and P1.
- For convenience, when presenting Pi, we use Pj to denote the other process; that is, j equals 1 - i.

#define false 0
#define true 1
#define n 2
int turn;
int interested[n];
void enter_region(int process) {
    int other;
    other = 1 - process;
    interested[process] = true;
    turn = process;
    while (turn == process && interested[other] == true)
        ; // no operation – busy waiting
}
void leave_region(int process) {
    interested[process] = false;
}
void main() {
    repeat
        enter_region(int i);
        Critical Section;
        leave_region(int i);
        Remainder Section;
    until false;
}

Mutual Exclusion with Busy Waiting (Peterson’s Solution)
1. Initially, neither process is in the critical section.
2. A process P0 calls enter_region(0):
   a) Set interested[0] = true;
   b) Set turn = 0;
3. Go to the critical section.
4. The process P1 calls enter_region(1) to get into its critical section:
   a) Set interested[1] = true;
   b) Set turn = 1;
5. Since interested[0] = true, it keeps looping for interested[0] = false.
6. Finally, process P0 finishes its critical section and calls leave_region(0):
   1. Set interested[0] = false;
7. Now P1 finds out interested[0] = false, and P1 goes to its critical section.9/17/2024

Mutual Exclusion with Busy Waiting (Peterson’s Solution)

Prove for Peterson’s Solution:

Let's consider the case where both P0 and P1 call enter_region(0) and enter_region(1) almost simultaneously.

Let's set interest[0] = true and interest[1] = true at the same time. However, turn can only be either turn = 0 or turn = 1, whichever store is done last is the one that counts.

Case 1: turn = 0
- Inside enter_region(0):
  - Since turn = 0 and interest[1] = true, P0 keeps looping in no-operation until P1 sets interest[1] = false.

- Inside enter_region(1):
  - Since turn = 0 and interest[0] = true, P1 goes to its critical section.

Case 2: turn = 1
- Inside enter_region(0):
  - Since turn = 1 and interest[1] = true, P0 goes to its critical section.

- Inside enter_region(1):
  - Since turn = 1 and interest[0] = true, P1 keeps looping in no-operation until P0 sets interest[0] = false.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Busy Waiting (Test and Set Lock – hardware solution)

Since the Test and Set Lock (TSL) instruction is a hardware instruction, the operations of reading the lock and storing into a register are guaranteed to be indivisible.

Instruction test and set lock: TSL RX, LOCK
1. Read the content at the memory address of LOCK into register RX.
2. Store a non-zero value at the memory address of LOCK.

The operations of reading the content of LOCK and storing into it are guaranteed to be indivisible.

How to use the Test and Set Lock instruction for solving race conditions:
- When LOCK = 0, any process may set LOCK = 1 by using the TSL instruction and go to its critical section.
- When the process finishes its critical section, it sets LOCK = 0 using the original move instruction.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Enter_region:
- TSL Register, LOCK
- CMP Register, #0
- JNE Enter_region
- Set LOCK, #1
- RET

Leave_region:
- MOVE LOCK, #0
- RET

Repeat:
- Enter_region
- Leave_region
- until false

Critical Section
Remainder Section

Mutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)

Two general memory models:
- Strongly ordered Memory: A memory modification on one processor is immediately visible to all other processors.
- Weakly ordered Memory: A memory modification on one processor may not be immediately visible to other processors.

With strongly ordered memory, computer architectures provide instructions that can force any changes in memory to be propagated to all other processors, thereby ensuring that memory modifications are visible to threads (or processes) running on other processors. Such instructions are known as memory barriers or memory fences.

Mutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)

A memory barrier is a type of barrier instruction that causes a central processing unit (CPU) or compiler to enforce an ordering constraint on memory operations issued before and after the barrier instruction. This typically means that operations issued prior to the barrier are guaranteed to be performed before operations issued after the barrier.

Mutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)
Example:
- Let's assume two threads (or processes) are running on different parts of the program by sharing two variables: (bool flag = false; int x = 0;).
- Thread 1 might print 0 or 100 depending on the order of execution.
- By using a memory barrier instruction, Thread 1 always prints 100.

while (!flag)
    print x;
    x = 100;
    flag = true;

Thread 1
Thread 29/17/2024

Mutual Exclusion with Busy Waiting (Memory Barriers – hardware solution)

- It is guaranteed that the value of flag is loaded before the value of x.
- It is also guaranteed that the assignment to x occurs before the assignment to flag.
- Therefore, Thread 1 will always print 100.

Code Example:

while (!flag) {
    memory_barrier();
}
print x;
 x = 100;
memory_barrier();
flag = true;

Thread 1
Thread 2

Mutual Exclusion with Busy Waiting (Atomic Variables – hardware solution)

- We can avoid mutual exclusion by using atomic operations.
- When a thread (or process) performs an atomic operation, the other threads (or processes) see it as happening instantaneously.
- The advantage of atomic operations is that they are relatively quick compared to locks, and do not suffer from deadlock and convoying.
- The disadvantage is that they only allow a limited set of operations, and often these are not enough to synthesize more complicated operations efficiently.
- Nonetheless, you should not pass up an opportunity to use an atomic operation in place of mutual exclusion.

Mutual Exclusion with Busy Waiting (Priority Inversion Problem)

- Peterson's solution, test and set lock, Memory Barrier, and Atomic variable method – busy waiting – can waste CPU time.
- The Priority Inversion problem with busy waiting method occurs in a system with two processes: PH (high priority) and PL (low priority).
- The scheduling rules dictate that PH gets CPU time whenever it is in a ready state (preemptive priority scheduling).

1. At time T0: PL is in the critical section, and PH is in a blocked state.
2. At time T1: PH changes state from blocked to ready and attempts to enter the critical section, but PL is still in the critical section.
3. Based on the scheduling rule, the short-term scheduler selects PH, which holds the CPU and tries to enter the critical section.
4. Since PL is in the critical section, PH will be busy waiting outside forever because PL does not have a chance to finish its critical section.

The scheduling rules state that the CPU scheduler will always select the higher priority process.
2024-12-19 07:05:09 - INFO - Processing pages: 0, full_response: Yes
2024-12-19 07:05:09 - INFO - Created 1 tasks for question generation
2024-12-19 07:05:09 - INFO - Starting question_generate_chain
2024-12-19 07:05:09 - INFO - Setting up question generation chain
2024-12-19 07:05:09 - INFO - Chain type: <class 'langchain_core.runnables.base.RunnableSequence'>
2024-12-19 07:05:09 - INFO - Question generation chain setup complete
2024-12-19 07:05:17 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-19 07:05:17 - INFO - Generated 5 questions for Operating Systems with the following questions: [QAPair(question='Which of the following is NOT a method of achieving mutual exclusion with busy waiting?', answer='Sleep and Wakeup', q_type='multiple_choice', choices=['Disabling Interrupts', 'Lock Variables', 'Strict Alternation', 'Sleep and Wakeup']), QAPair(question="Peterson's solution is a mutual exclusion algorithm restricted to how many processes?", answer='2', q_type='multiple_choice', choices=['1', '2', '3', '4']), QAPair(question='True or False: A race condition occurs when processes are prevented from accessing shared data simultaneously.', answer='False', q_type='TF', choices=['True', 'False']), QAPair(question='True or False: Memory barriers ensure that memory modifications on one processor are immediately visible to all other processors.', answer='True', q_type='TF', choices=['True', 'False']), QAPair(question='Explain the concept of a critical section and its significance in inter-process communication.', answer='A critical section is a part of a program where shared memory is accessed. Its significance lies in the need to ensure that when one process is executing in its critical section, no other process can enter its own critical section, thus preventing race conditions and ensuring data integrity.', q_type='written', choices=[])]
2024-12-19 07:05:17 - INFO - Finished question_generate_chain
2024-12-19 07:05:17 - INFO - Completed question generation. Number of results: 1
2024-12-19 07:05:17 - INFO - Generated test list with 1 tests
2024-12-19 07:05:17 - INFO - Preparing judge_kwargs with 9 parameters
2024-12-19 07:05:17 - INFO - FINAL TEST:
{
    "questions": [
        {
            "question": "Which of the following is NOT a method of achieving mutual exclusion with busy waiting?",
            "answer": "Sleep and Wakeup",
            "q_type": "multiple_choice",
            "choices": [
                "Disabling Interrupts",
                "Lock Variables",
                "Strict Alternation",
                "Sleep and Wakeup"
            ]
        },
        {
            "question": "Peterson's solution is a mutual exclusion algorithm restricted to how many processes?",
            "answer": "2",
            "q_type": "multiple_choice",
            "choices": [
                "1",
                "2",
                "3",
                "4"
            ]
        },
        {
            "question": "True or False: A race condition occurs when processes are prevented from accessing shared data simultaneously.",
            "answer": "False",
            "q_type": "TF",
            "choices": [
                "True",
                "False"
            ]
        },
        {
            "question": "True or False: Memory barriers ensure that memory modifications on one processor are immediately visible to all other processors.",
            "answer": "True",
            "q_type": "TF",
            "choices": [
                "True",
                "False"
            ]
        },
        {
            "question": "Explain the concept of a critical section and its significance in inter-process communication.",
            "answer": "A critical section is a part of a program where shared memory is accessed. Its significance lies in the need to ensure that when one process is executing in its critical section, no other process can enter its own critical section, thus preventing race conditions and ensuring data integrity.",
            "q_type": "written",
            "choices": []
        }
    ]
}
2024-12-19 07:05:17 - INFO - All tasks completed. Number of results: 1
2024-12-19 07:05:17 - INFO - Generated 1 tests
2024-12-19 07:05:17 - INFO - Cleaning up temp files
2024-12-19 07:05:17 - INFO - Deleted temp file: /tmp/tmphw6reamy
2024-12-19 07:05:17 - INFO - Temp files cleaned
2024-12-19 07:05:17 - INFO - Run function completed
2024-12-19 07:05:17 - INFO - Test generated successfully
2024-12-19 07:05:21 - INFO - GET request received for index page
