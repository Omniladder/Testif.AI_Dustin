2024-12-18 09:26:44 - INFO - Static files mounted
2024-12-18 09:26:44 - INFO - toLetter filter added to Jinja2 environment
2024-12-18 09:26:51 - INFO - GET request received for index page
2024-12-18 09:27:06 - INFO - POST request received for /generate
2024-12-18 09:27:06 - INFO - Form data: title='OS' course='OS' professor='Dr. Park' number_of_written_questions=1 number_of_mcq_questions=2 number_of_TF_questions=2 level='Normal' school_type='Undergraduate' difficulty='Extreme' testing_philosophy='Fail them all' url_1=None url_2=None subject_material=[UploadFile(filename='450Slides9.pdf', size=233626, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides9.pdf"', 'content-type': 'application/pdf'})), UploadFile(filename='450Slides11.pdf', size=343833, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides11.pdf"', 'content-type': 'application/pdf'})), UploadFile(filename='cosc450_11.pdf', size=343833, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="cosc450_11.pdf"', 'content-type': 'application/pdf'}))]
2024-12-18 09:27:06 - INFO - Starting run function
2024-12-18 09:27:06 - INFO - Form data accessed
2024-12-18 09:27:06 - INFO - Form Title: OS
2024-12-18 09:27:06 - INFO - Form Course: OS
2024-12-18 09:27:06 - INFO - Form Professor: Dr. Park
2024-12-18 09:27:06 - INFO - Form Number of MCQ Questions: 2
2024-12-18 09:27:06 - INFO - Form Number of TF Questions: 2
2024-12-18 09:27:06 - INFO - Form Number of Written Questions: 1
2024-12-18 09:27:06 - INFO - Form School Type: Undergraduate
2024-12-18 09:27:06 - INFO - Form Difficulty: Extreme
2024-12-18 09:27:06 - INFO - Form Testing Philosophy: Fail them all
2024-12-18 09:27:06 - INFO - Moving to files...
2024-12-18 09:27:06 - INFO - Starting to process files
2024-12-18 09:27:06 - INFO - Processing file: 450Slides9.pdf
2024-12-18 09:27:06 - INFO - Getting loader for file: UploadFile(filename='450Slides9.pdf', size=233626, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides9.pdf"', 'content-type': 'application/pdf'}))
2024-12-18 09:27:06 - INFO - File extension: .pdf
2024-12-18 09:27:06 - INFO - Processing PDF file: 450Slides9.pdf
2024-12-18 09:27:06 - INFO - Using loader type: PyMuPDFLoader for UploadFile(filename='450Slides9.pdf', size=233626, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides9.pdf"', 'content-type': 'application/pdf'}))
2024-12-18 09:27:06 - INFO - Processing file: 450Slides11.pdf
2024-12-18 09:27:06 - INFO - Getting loader for file: UploadFile(filename='450Slides11.pdf', size=343833, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides11.pdf"', 'content-type': 'application/pdf'}))
2024-12-18 09:27:06 - INFO - File extension: .pdf
2024-12-18 09:27:06 - INFO - Processing PDF file: 450Slides11.pdf
2024-12-18 09:27:06 - INFO - Using loader type: PyMuPDFLoader for UploadFile(filename='450Slides11.pdf', size=343833, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="450Slides11.pdf"', 'content-type': 'application/pdf'}))
2024-12-18 09:27:06 - INFO - Processing file: cosc450_11.pdf
2024-12-18 09:27:06 - INFO - Getting loader for file: UploadFile(filename='cosc450_11.pdf', size=343833, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="cosc450_11.pdf"', 'content-type': 'application/pdf'}))
2024-12-18 09:27:06 - INFO - File extension: .pdf
2024-12-18 09:27:06 - INFO - Processing PDF file: cosc450_11.pdf
2024-12-18 09:27:06 - INFO - Using loader type: PyMuPDFLoader for UploadFile(filename='cosc450_11.pdf', size=343833, headers=Headers({'content-disposition': 'form-data; name="subject_material"; filename="cosc450_11.pdf"', 'content-type': 'application/pdf'}))
2024-12-18 09:27:06 - INFO - URLs: []
2024-12-18 09:27:06 - INFO - Processing 3 files and 0 URLs
2024-12-18 09:27:06 - INFO - Processing 450Slides9.pdf
2024-12-18 09:27:06 - INFO - Using loader type: PyMuPDFLoader for 450Slides9.pdf
2024-12-18 09:27:06 - INFO - Processing 450Slides9.pdf as a regular document using PyMuPDFLoader
2024-12-18 09:27:06 - INFO - Processing 450Slides11.pdf
2024-12-18 09:27:06 - INFO - Using loader type: PyMuPDFLoader for 450Slides11.pdf
2024-12-18 09:27:06 - INFO - Processing 450Slides11.pdf as a regular document using PyMuPDFLoader
2024-12-18 09:27:06 - INFO - Processing cosc450_11.pdf
2024-12-18 09:27:06 - INFO - Using loader type: PyMuPDFLoader for cosc450_11.pdf
2024-12-18 09:27:06 - INFO - Processing cosc450_11.pdf as a regular document using PyMuPDFLoader
2024-12-18 09:27:06 - INFO - Successfully loaded 4 documents from: 450Slides9.pdf
2024-12-18 09:27:06 - INFO - Docs: [Document(metadata={'source': '/tmp/tmpjdeb42g0', 'file_path': '/tmp/tmpjdeb42g0', 'page': 0, 'total_pages': 4, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240917075958-04'00'", 'modDate': "D:20240917075958-04'00'", 'trapped': ''}, page_content="9/17/2024\n1\nPreview\n\uf070Real-Time CPU Scheduling\n\uf06eMinimizing Latency\n\uf06ePreemptive Priority-Based Scheduling\n\uf06eRate-Monotonic Scheduling\n\uf06eEarliest-Deadline-First Scheduling\n\uf06eProportional Share Scheduling\n\uf070Criteria for selecting an algorithm\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n1\nReal-Time CPU Scheduling \n\uf070CPU scheduling for real-time operating systems involves special \nissues. In general, we can distinguish between hard real-time \nsystems and soft real-time systems.\n\uf070Hard real-time systems - A task must be serviced by its deadline; \nservice after the deadline has expired is the same as no service at \nall. Any missed deadline to be a system failure. \n\uf06eAn Inkjet printer has a print head with control software for depositing the \ncorrect amount of ink onto a specific part of the paper. If a deadline is missed \nthen the print job is ruined.\n\uf06eAir France Flight 447 crashed into the ocean after a sensor malfunction \ncaused a series of system errors.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n2\nReal-Time CPU Scheduling \n\uf070Soft real-time system allows for frequently missed deadlines, and \nas long as tasks are timely executed their results continue to have \nvalue. Completed tasks may have increasing value up to the \ndeadline and decreasing value past it.\n\uf06eWeather stations have many sensors for reading temperature, humidity, wind \nspeed, etc. The readings should be taken and transmitted at regular intervals, \nhowever the sensors are not synchronized. Even though a sensor reading may \nbe early or late compared with the others it can still be relevant as long as it \nis close enough.\n\uf06eThe sound system in computer. If you miss a few bits, no big deal, but miss \ntoo many and you're going to eventually degrade the system.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n3\nReal-Time CPU Scheduling  \n(Minimizing Latency)\n\uf070A real-time system is typically waiting for an event in real time to \noccur. Events may arise either in software (as when a timer \nexpires)or in hardware (when a remote-controlled vehicle detects \nthat it is approaching an obstruction). \n\uf070When an event occurs, the system must respond to and service it \nas quickly as possible.\n\uf070Event latency is the amount of time that elapses from when an \nevent occurs to when it is serviced.\n\uf070Different events have different latency requirements in a system.\n\uf06eFor an antilock brake system – 3 to 5 milliseconds.\n\uf06eIf antilock brake system does not respond within, car accident might occurs  \nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n4\nReal-Time CPU Scheduling  \n(Minimizing Latency)\n\uf070Two types of latencies affect the performance of real-time systems\n1. Interrupt latency –.\n\uf06eWhen an interrupt occurs, \n\uf070the OS complete the instruction it is executing and \n\uf070determine the type of interrupt that occurred. \n\uf070save the state of the current process before servicing the interrupt using the specific interrupt \nservice routine (ISR).\n\uf06eA Interrupt latency is the period of time from the arrival of an interrupt at the \nCPU to the start of the routine that services the interrupt\n2. Dispatch latency – The amount of time required for the scheduling \ndispatcher to stop one process and start another\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n5\nReal-Time CPU Scheduling  \n(Minimizing Latency)\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n6\n: from current process to interrupt service routine\n"), Document(metadata={'source': '/tmp/tmpjdeb42g0', 'file_path': '/tmp/tmpjdeb42g0', 'page': 1, 'total_pages': 4, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240917075958-04'00'", 'modDate': "D:20240917075958-04'00'", 'trapped': ''}, page_content='9/17/2024\n2\nReal-Time CPU Scheduling  \n(Minimizing Latency)\n\uf070Two types of latencies affect the performance of real-time systems\n1. Interrupt latency –\n2. Dispatch latency –\n\uf06eDispatch latency is the amount of time required for the scheduling dispatcher \nto stop one process and start another\n\uf06eThe most effective technique for keeping dispatch latency low is to provide \npreemptive kernels. For hard real-time systems, dispatch latency is typically \nmeasured in several microseconds.\n\uf06eTwo components of conflict phase of dispatch latency:\n\uf070Preemption of any process running in the kernel\n\uf070Release by low-priority processes of resources needed by a high-priority process\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n7\nReal-Time CPU Scheduling  \n(Minimizing Latency)\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n8\nFig. Dispatch Latency\nReal-Time CPU Scheduling  \n(Preemptive Priority-Based Scheduling)\n\uf070The most important feature of a real-time operating system is to \nrespond immediately to a real-time process.\n\uf070In Priority-Based scheduling, scheduler always select highest \npriority process; more important tasks are assigned higher \npriorities than those deemed less important.\n\uf070With Preemptive, process currently running on the CPU will be \npreempted if a higher-priority process becomes available to run.\n\uf070Preemptive, priority-based scheduler only guarantees soft real-time \nfunctionality\n\uf070Since hard real-time system need consider deadline, the scheduler \nrequires additional scheduling features.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n9\nReal-Time CPU Scheduling  \n\uf070Characteristics for a process require to consider for real-time CPU \nscheduler.\n\uf06ePeriod (p)- That is, process require the CPU at constant intervals (periods).\n\uf06eDeadline (d)\n\uf06eProcessing time (t)–fixed processing time\n\uf070The relationship of the processing time, the deadline, and the \nperiod can be expressed as \n\uf06e0 ≤ t ≤ d ≤ p. \n\uf070The rate of a periodic task is 1∕p.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n10\nReal-Time CPU Scheduling \n\uf070A process have to provide its deadline requirement to the scheduler. Then, the \nscheduler either admit the process guaranteeing that the process will complete \non time, or rejects the request as impossible (admission-control algorithm)\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n11\nFig. Periodic task.\nReal-Time CPU Scheduling  \n(Rate-Monotonic Scheduling)\n\uf070Rate-monotonic scheduling assumes that the processing time of a \nperiodic process is the same for each CPU burst. That is, every \ntime a process acquires the CPU, the duration of its CPU burst is \nthe same. \n\uf070Upon entering the system, priority is assigned to a process based \non length of period (p). The shorter the period, the higher the \npriority.\n\uf070The rate-monotonic scheduling algorithm schedules periodic tasks \nusing a static priority policy with preemption.\n\uf070If a lower-priority process is running and a higher-priority process \nbecomes available to run, it will preempt the lower-priority \nprocess.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n12\n'), Document(metadata={'source': '/tmp/tmpjdeb42g0', 'file_path': '/tmp/tmpjdeb42g0', 'page': 2, 'total_pages': 4, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240917075958-04'00'", 'modDate': "D:20240917075958-04'00'", 'trapped': ''}, page_content='9/17/2024\n3\nReal-Time CPU Scheduling  \n(Rate-Monotonic Scheduling)\n\uf070Ex) Two process P1, P2\n\uf06ep1= 50, t1=20, d1= by the start of its next period\n\uf070CPU utilization of P1= p1/t1=20/50 = 0.4\n\uf06ep2=100, t2=35, d2 = by the start of its next period\n\uf070CPU utilization of P1= p2/t2=35/100 = 0.35\n\uf06eSince t1 \uf03ct2, P1 has higher priority than P2\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n13\n110\n0\n120\n150\n160\n170\n180\n190\n200\n130\n140\n100\n30\n40\n50\n60\n70\n80\n90\n20\n10\nP2\nP1\nP1\nP2\nP2\nP1\nP1\nP2\np2\np1\np1\np1\np2\nP1 ,P2 deadline =200\nP1 deadline =150\nP1 deadline =50\nP1 ,P2 deadline =100\nReal-Time CPU Scheduling  \n(Rate-Monotonic Scheduling)\n\uf070Ex) Two process P1, P2\n\uf06ep1= 50, t1=25, d1= by the start of its next period\n\uf070CPU utilization of P1= p1/t1=25/50 = 0.5\n\uf06ep2=80, t2=35, d2 = by the start of its next period\n\uf070CPU utilization of P2 = p2/t2=35/80 = 0.4375\n\uf06eSince t1 \uf03ct2, P1 has higher priority than P2\n\uf06erate-monotonic scheduling cannot guarantee that they can be scheduled so that they \nmeet their deadlines.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n14\n110\n0\n120\n150\n160\n170\n180\n190\n200\n130\n140\n100\n30\n40\n50\n60\n70\n80\n90\n20\n10\nP2\nP1\nP1\nP2\np2\np1\nP1 deadline =50\np2\np2\np1\np1\np1\nP2 deadline =80\nReal-Time CPU Scheduling  \n(Earliest-Deadline-First Scheduling)\n\uf070Earliest-deadline-firs (EDF) scheduling assigns priorities \ndynamically according to deadline. \n\uf06eThe earlier the deadline, the higher the priority; \n\uf06eThe later the deadline, the lower the priority\n\uf070When a process becomes runnable (ready state), it must \nannounce its deadline requirements to the system. \n\uf070Priorities have to be adjusted to reflect the deadline of \nthe newly runnable process.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n15\nP2\nP1\nP2\nP1\nP2\nP1\nReal-Time CPU Scheduling  \n(Earliest-Deadline-First Scheduling)\n\uf070Ex) Two process P1, P2\n\uf06ep1= 50, t1=25, d1= by the start of its next period\n\uf070CPU utilization of P1= p1/t1=25/50 = 0.5\n\uf06ep2=80, t2=35, d2 = by the start of its next period\n\uf070CPU utilization of P2 = p2/t2=35/80 = 0.4375\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n16\n110\n0\n120\n150\n160\n170\n180\n190\n200\n130\n140\n100\n30\n40\n50\n60\n70\n80\n90\n20\n10\np1\nP2\np2\np2\np1\np1\np1\np2\nP1\nP1\nP2\nP1\nReal-Time CPU Scheduling  \n(Earliest-Deadline-First Scheduling)\n\uf070EDF scheduling is theoretically optimal—theoretically, it \ncan schedule processes so that each process can meet its \ndeadline requirements and CPU utilization will be 100 \npercent. \n\uf070In practice, it is not possible to achieve this level of CPU \nutilization due to the cost of context switching between \nprocesses and interrupt handling.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n17\nReal-Time CPU Scheduling  \n(Proportional Share Scheduling)\n\uf070Proportional share schedulers operate by allocating T shares \namong all processes.\n\uf070An process can receive N shares of time, ensuring that the process \nwill have N∕T of the total processor time.\n\uf070Ex) There are three processes P1, P2, and P3. And, total of share T \n= 100.\n\uf06eP1 is assigned 50 shares, P2 is assigned 15 shares, and P3 is assigned 20 \nshares.\n\uf06eMeans that P1 will have 50 %, P2 will have 15 %, and P3 will have 20 % of \ntotal processor time.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n18\n'), Document(metadata={'source': '/tmp/tmpjdeb42g0', 'file_path': '/tmp/tmpjdeb42g0', 'page': 3, 'total_pages': 4, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240917075958-04'00'", 'modDate': "D:20240917075958-04'00'", 'trapped': ''}, page_content='9/17/2024\n4\nReal-Time CPU Scheduling  \n(Proportional Share Scheduling)\n\uf070Proportional share schedulers must work in conjunction \nwith an admission-control policy to guarantee that an \napplication receives its allocated shares of time.\n\uf070An admission-control policy will admit a process \nrequesting a particular number of shares only if sufficient \nshares are available.\n\uf06eIn previous example, we have allocated 50 + 15 + 20 = 85 \nshares of the total of 100 shares. \n\uf06eIf a new process P4 requested 30 shares, the admission \ncontroller would deny P4 entry into the system.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n19\nScheduling Algorithm Evaluation\n\uf070Criteria for selecting an algorithm.\n\uf06eCPU Utilization\n\uf06eThroughput\n\uf06eResponse time\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n20\n')] for 450Slides9.pdf using PyMuPDFLoader
2024-12-18 09:27:06 - INFO - Document 1 (450Slides9.pdf) of 4
2024-12-18 09:27:06 - INFO - Starting clean_files_chain
2024-12-18 09:27:06 - INFO - Document: page_content='9/17/2024
1
Preview
Real-Time CPU Scheduling
Minimizing Latency
Preemptive Priority-Based Scheduling
Rate-Monotonic Scheduling
Earliest-Deadline-First Scheduling
Proportional Share Scheduling
Criteria for selecting an algorithm
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
1
Real-Time CPU Scheduling 
CPU scheduling for real-time operating systems involves special 
issues. In general, we can distinguish between hard real-time 
systems and soft real-time systems.
Hard real-time systems - A task must be serviced by its deadline; 
service after the deadline has expired is the same as no service at 
all. Any missed deadline to be a system failure. 
An Inkjet printer has a print head with control software for depositing the 
correct amount of ink onto a specific part of the paper. If a deadline is missed 
then the print job is ruined.
Air France Flight 447 crashed into the ocean after a sensor malfunction 
caused a series of system errors.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
2
Real-Time CPU Scheduling 
Soft real-time system allows for frequently missed deadlines, and 
as long as tasks are timely executed their results continue to have 
value. Completed tasks may have increasing value up to the 
deadline and decreasing value past it.
Weather stations have many sensors for reading temperature, humidity, wind 
speed, etc. The readings should be taken and transmitted at regular intervals, 
however the sensors are not synchronized. Even though a sensor reading may 
be early or late compared with the others it can still be relevant as long as it 
is close enough.
The sound system in computer. If you miss a few bits, no big deal, but miss 
too many and you're going to eventually degrade the system.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
3
Real-Time CPU Scheduling  
(Minimizing Latency)
A real-time system is typically waiting for an event in real time to 
occur. Events may arise either in software (as when a timer 
expires)or in hardware (when a remote-controlled vehicle detects 
that it is approaching an obstruction). 
When an event occurs, the system must respond to and service it 
as quickly as possible.
Event latency is the amount of time that elapses from when an 
event occurs to when it is serviced.
Different events have different latency requirements in a system.
For an antilock brake system – 3 to 5 milliseconds.
If antilock brake system does not respond within, car accident might occurs  
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
4
Real-Time CPU Scheduling  
(Minimizing Latency)
Two types of latencies affect the performance of real-time systems
1. Interrupt latency –.
When an interrupt occurs, 
the OS complete the instruction it is executing and 
determine the type of interrupt that occurred. 
save the state of the current process before servicing the interrupt using the specific interrupt 
service routine (ISR).
A Interrupt latency is the period of time from the arrival of an interrupt at the 
CPU to the start of the routine that services the interrupt
2. Dispatch latency – The amount of time required for the scheduling 
dispatcher to stop one process and start another
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
5
Real-Time CPU Scheduling  
(Minimizing Latency)
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
6
: from current process to interrupt service routine
' metadata={'source': '/tmp/tmpjdeb42g0', 'file_path': '/tmp/tmpjdeb42g0', 'page': 0, 'total_pages': 4, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240917075958-04'00'", 'modDate': "D:20240917075958-04'00'", 'trapped': ''}
2024-12-18 09:27:06 - INFO - Invoking chain
2024-12-18 09:27:06 - INFO - Successfully loaded 5 documents from: cosc450_11.pdf
2024-12-18 09:27:06 - INFO - Docs: [Document(metadata={'source': '/tmp/tmp20n96_gc', 'file_path': '/tmp/tmp20n96_gc', 'page': 0, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}, page_content='9/26/2024\n1\nReview\nInter-Process Communication\n\uf070Race Condition\n\uf070Critical Section (or region) \n\uf070Solutions for Mutual Exclusion in a Critical Section\n\uf06eWith Busy Waiting\n\uf070Disabling Interrupts –non-preemptive kernel\n\uf070Lock Variables –violating the first necessary condition (mutual exclusion )\n\uf070Strict Alternation –violating the second necessary condition ( block by a process outside critical section)\n\uf070Peterson’s Solution\n\uf070Hardware Solution\n\uf0a7\nTest and Set Lock –\n\uf0a7\nMemory Barriers\n\uf0a7\nAtomic Variable\n\uf070Priority Inversion problems with busy waiting\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n1\nPreview\n\uf070Mutual Exclusion in a Critical Section\n\uf06eWith Sleep and Wake up\n\uf070Producer Consumer Problem\n\uf070Race Condition Producer Consumer problem\n\uf070Semaphore\n\uf0a7\nConcept of Semaphore\n\uf0a7\nSemaphore Operation\n\uf0a7\nSemaphore Implementation\n\uf0a7\nProducer Consumer problem with semaphores\n\uf0a7\nCareless Usage of semaphore causes deadlock \n\uf070Dining Philosophers Problem\n\uf070Reader’s and Writer’s Problem\n\uf070Mutexes\n\uf070Monitor\n\uf0a7\nImplementation of Monitor\n\uf0a7\nProducer Consumer with Monitor\n\uf070Message Passing\n\uf0a7\nProducer Consumer with Message Passing\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n2\nMutual Exclusion with Sleep and Wakeup\n\uf070Sleep and Wakeup-\n\uf06eA process check a resource (critical section), if not available go \nto sleep. \n\uf06eWhen the resource become available, the process will be waked \nup by system or the process release the resource.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n3\nThe Producer-Consumer Problem\nDescription\n\uf070Two processes share a common, fixed-sized buffer. \n\uf070Producer puts information into the buffer, and consumer takes it \nout.\nTroubles arises \n\uf070When the producer wants to put a new item in the buffer, but it is \nalready full.\n\uf070When the consumer tries to take a item from the buffer, but buffer \nis already empty.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n4\nThe Producer-Consumer Problem\n\uf070When the producer wants to put a new item in the buffer, \nbut it is already full.\n\uf06eSolution – producer is go to sleep, awakened by customer when \ncustomer has removed on or more items.\n\uf070When the consumer tries to take a item from the buffer, \nbut buffer is already empty.\n\uf06eSolution – customer is go to sleep, awakened by the producer \nwhen producer puts one or more information into the buffer.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n5\nThe Producer-Consumer Problem\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n6\n#define N 100 //buffer size\nint count = 0;//# of item\nvoid producer()\n{\nint item\nwhile (true)\n{\nitem = produce_item();\nif (count == N)\nsleep();\ninsert_item(item)\ncount = count + 1;\nif (count ==1)\nwakeup(consumer);\n}\n}\nvoid consumer()\n{\nint item;\nwhile(true)\n{\nif (count == 0)\nsleep();\nitem = remove_item();\ncount = count – 1;\nif (count == N – 1)\nwakeup(producer);\nconsume_item(item);\n}\n}\n'), Document(metadata={'source': '/tmp/tmp20n96_gc', 'file_path': '/tmp/tmp20n96_gc', 'page': 1, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}, page_content='9/26/2024\n2\nSemaphores – by E. W. Dijkstra \n\uf070A semaphore is an integer variable which could have \nvalue \n\uf06e0:  no wakeups are saved\n\uf06e+ i: i wakeups are pending\n\uf070A semaphore is accessed only through two standard \natomic operations down (or P) and up (or V).\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n7\nConcept of Semaphores\n\uf070Modification to the integer value of the semaphore in the \ndown and up operations are executed indivisibly. \n\uf070Which means that when a process is modifying the \nsemaphore value, no other process can simultaneously \nmodify that same semaphore value.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n8\nSemaphore Operation\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n9\nvoid down (S)\n{\nif S == 0\n{\n1. Add this process to the sleeping list\n2. block;\n}\nS = S – 1;\n}\nvoid up (S)\n{\nS = S + 1;\nIf S = 1\n{\n1. choose one process P from the \nsleeping list or let them move to \nready state\n2. wakeup(P) to finish down operation\n}\n}\nSemaphore Implementation\nThe normal way for implementing a semaphore\n\uf070Implement semaphore operations up and down as \nsystem call.\n\uf070operating system briefly disabling all interrupts while it is \ntesting the semaphore, updating it and putting the \nprocess to sleep.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n10\nSolving the Producer-Consumer Problem using \nSemaphores\n#define N 100\ntypedef int semaphore;\nsemaphore mutex = 1;  //mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of item\nvoid producer ()\n{\nint item;\nwhile (ture)\n{\nitem = produce_item(); //produce item\ndown (&empty); //check empty space\ndown (&mutex); //check mutual exclusion\ninsert_item(item); //insert item\nup(&mutex); //out from critical section\nup(&full); //increase # of item\n}\n}\nvoid consumer()\n{\nint item;\nwhile (true)\n{\ndown(&full); //check item in buffer\ndown(&mutex) //check mutual exclusion\nitem = remove_item(); //remove a item\nup(&mutex); //out from critical section\nup(&empty); //increase the empty space\nconsume_item(item);\n}\n}\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n11\nCareless usage of Semaphore causes deadlock\n#define N 100\ntypedef int semaphore;\nsemaphore mutex = 1; //mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of item\nvoid producer ()\n{\nint item;\nwhile (ture)\n{\nitem = produce_item();\ndown (&mutex);\ndown (&empty);\ninsert_item(item);\nup(&mutex);\nup(&full);\n}\n}\nvoid consumer()\n{\nint item;\nwhile (true)\n{\ndown(&full)\ndown(&mutex)\nitem = remove_item();\nup(&mutex);\nup(&empty);\nconsume_item(item);\n}\n}\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n12\n'), Document(metadata={'source': '/tmp/tmp20n96_gc', 'file_path': '/tmp/tmp20n96_gc', 'page': 2, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}, page_content="9/26/2024\n3\nCareless usage of Semaphore causes deadlock\n#define N 100\ntypedef int semaphore;\nsemaphore mutex = 1; //mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of item\nvoid producer ()\n{\nint item;\nwhile (ture)\n{\nitem = produce_item();\ndown (&empty);\ndown (&mutex);\ninsert_item(item);\nup(&mutex);\nup(&full);\n}\n}\nvoid consumer()\n{\nint item;\nwhile (true)\n{\ndown(&mutex);\ndown(&full);\nitem = remove_item();\nup(&mutex);\nup(&empty);\nconsume_item(item);\n}\n}\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n13\nDining Philosophers Problem\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n14\nDining Philosophers Problem\n\uf070Five silent philosophers sit at a round table with bowls of spaghetti. Chopsticks \nare placed between each pair of adjacent philosophers.\n\uf070Each philosopher must alternately think and eat. However, a philosopher can \nonly eat spaghetti when they have both left and right chopsticks. \n\uf070Each chopstick can be held by only one philosopher and so a philosopher can use \nthe chopstick only if it is not being used by another philosopher. \n\uf070After an individual philosopher finishes eating, they need to put down both \nchopsticks so that the chopstick s become available to others. A philosopher can \ntake the chopstick on their right or the one on their left as they become \navailable, but cannot start eating before getting both chopsticks.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n15\nReaders-Writers Problem\n\uf070Process reader R and writers W are sharing resources at one time. \nOnly one process (reader or writer) can access the shared \nresources at any time.\n1. It is possible that a reader R1 might have the lock to a shared resource, and \nthen another reader R2 requests access. It would be foolish for R2 to wait \nuntil R1 was done before starting its own read operation; instead R1 and R2\ncan read same resource at the same time since both are reading.\n2. It is possible that a reader R1 might have the lock, a writer W be waiting for \nthe lock, and then a reader R2 requests access. It would be unfair for R2 to \njump in immediately, ahead of W; if that happened often \nenough, W would starve.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n16\nReaders-Writers Problem\nW2\nR3\nW1\nR2\nR1\nW2\nW1\nR1\nR2\nR3\nR4\nR3\nR2\nW1\nR1\nW1\nR1\nR4\nR2\nR3\nUnfair for W1 (starvation)\nMight be better\nShared resource(database)\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n17\nMutexes\n\uf070When the semaphore's ability to count is not needed, the simplified \nversion of the semaphore, called mutex is used.\n\uf070It is good for managing a mutual exclusion to some shared \nresources or pieces of code\n\uf070It is useful in thread packages that are implemented in user’s \nspace.\n\uf070A mutex is a variable that can be in one of two state: unlocked (0), \nlocked(1).\n\uf070A mutex concept is same as binary semaphore which has value 0 \nor 1.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n18\n"), Document(metadata={'source': '/tmp/tmp20n96_gc', 'file_path': '/tmp/tmp20n96_gc', 'page': 3, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}, page_content='9/26/2024\n4\nMutexes\nmutexes mutex = 0\nrepeat\nmutex_lock (mutex);\nmutex_unlock (mutex);\nuntil false\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n19\nCritical Section\nRemainder Section\nMonitor\n\uf070\nMonitor – High level synchronizing primitive \n\uf06e\nA collection of procedures, variables, and data structures that are all grouped \ntogether in a special kind of module.\n\uf06e\nOnly one process can be active in a monitor at any instant.\n\uf06e\nCompiler knows that monitors are special and can handle calls to monitor \nprocedure differently from other procedure call (create special code for \nmonitor).\n\uf06e\nWhen a process call a procedure inside a monitor, \n1.\ncheck whether any process is active within monitor or not. \n2.\nIf so, the calling process will be suspended until the other process has left the \nmonitor.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n20\nImplementation of Monitor\n\uf070Since monitor is a construct for a programming \nlanguage, Monitor implementation is based on the \ncompiler\n\uf070Compiler knows monitor is special kind of module, \ncompiler use mutex or binary semaphore for mutual \nexclusion.\n\uf070Monitor provide an easy way to achieve mutual exclusion. \nBut we need to consider, how a process can be blocked \nand how blocked process can be waked up?\n\uf06eIntroduction of Condition variables\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n21\nImplementation of Monitor\n\uf070Conditional variables are used in the monitor. \n\uf070There are two operation on the conditional variables (wait, signal).\n\uf070When a monitor procedure discovers that it cannot continue, it does wait \non some condition variable (ex full). This action causes the calling \nprocess to block. – allows other process get into the monitor.\n\uf070Other process (ex. consumer) can wake up its sleeping partner by doing \na signal on the condition variable that its partner is waiting on.\n\uf070If there are more than one processes are waiting on a condition variable, \nsystem scheduler choose one of them \nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n22\nImplementation of Monitor\nOnce a process do a signal, what is next step for the process do a \nsignal, to avoid having two active processes in the monitor at the \nsame time?\nSolution 1) by Hoare\n\uf06eLetting the newly awakened process run, suspending the one do the signal\nSolution 2) by Brinch Hansen\n\uf06eA signal statement may appear only as the final statement in a monitor \nprocedure.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n23\nProducer-Consumer with Monitor\nmonitor ProducerConsumer\ncondition full, empty;\ninteger count;\nprocedure insert (item: integer);\nbegin\nif count = N then\nwait (full);\ninsert_item(item);\ncount :=count + 1;\nif count = 1 then\nsignal (empty)\nend;\nfunction remove: integer;\nbegin\nif count = 0 then\nwait (empty);\nremove = remove_item;\ncount := count – 1;\nif count = N – 1 then\nsignal (full);\nend;\ncount := 0;\nend monitor\nprocedure producer\nbegin\nwhile true do\nbegin\nitem = produce_item;\nProducerConsumer.insert(item)\nend\nend;\nprocedure consumer;\nbegin\nwhile true do\nbegin\nitem = ProducerConsumer.remove;\nconsume_item(item)\nend\nend;\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n24\n'), Document(metadata={'source': '/tmp/tmp20n96_gc', 'file_path': '/tmp/tmp20n96_gc', 'page': 4, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}, page_content='9/26/2024\n5\nMessage Passing\n\uf070Message Passing is a method of interprocess communication by using two \nprimitive system calls\n\uf06esend(destination, &message);\n\uf06ereceive(source, &message);\n\uf070Usually Message Passing is used between processes located in different system \nsince it is slower than using semaphore or monitor in the same system.\n\uf070If there is no message is available, the receiver will be blocked by system until \none arrived.\n\uf070If there is no message to send, the sender will be blocked by system until one \nbecome available.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n25\nMessage Passing\n(Design Issues for Message Passing System)\n\uf070Message can be lost\n\uf06eSolution: \n\uf070When a message is received, receiver send acknowledgement message.\n\uf070If sender has not received the ack. message within a certain time interval, retransmits the \nmessage.\n\uf06eThis solution cause new design issue. \n\uf070Receiver receive a message from sender, receiver send Ack. message. If the Ack. \nmessage lost, sender send same message again. Then receiver receive same \nmessage twice.\n\uf06eSolution:\n\uf070Each message is assigned with sequence number.\n\uf070Receiver site system can recognize duplicated message and discard one of them.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n26\nProducer-Consumer Problem \n(with Message Passing)\n#define N 100\n/* number of slots in the buffer */\nvoid producer ()\n{\nint item;\nmessage m;\n/* message buffer */\nwhile (ture)\n{\nitem = produce_item();\n/* generate item to put in buffer */\nreceive(consumer, &m);\n/* wait for an empty slot (ACK)*/\nbuild_message(&m, item);\n/* construct a message to send */\nsend(consumer, &m);\n/* send item to consumer */\n}\n}\nvoid consumer()\n{\nint item, i;\nmessage m;\nfor (i=0; i < N; i++)\n/* send N empty messages*/\nsend(producer, &m);\nwhile (true)\n{\nreceive(producer, &m);\n/* receive a message from producer */\nitem = extract_item(&m);\n/* extract a message */\nsend(producer, &m)\n/* send an empty message to producer (ACK)*/\nconsume_item(item);\n}\n}\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n27\n')] for cosc450_11.pdf using PyMuPDFLoader
2024-12-18 09:27:06 - INFO - Document 1 (cosc450_11.pdf) of 5
2024-12-18 09:27:06 - INFO - Starting clean_files_chain
2024-12-18 09:27:06 - INFO - Document: page_content='9/26/2024
1
Review
Inter-Process Communication
Race Condition
Critical Section (or region) 
Solutions for Mutual Exclusion in a Critical Section
With Busy Waiting
Disabling Interrupts –non-preemptive kernel
Lock Variables –violating the first necessary condition (mutual exclusion )
Strict Alternation –violating the second necessary condition ( block by a process outside critical section)
Peterson’s Solution
Hardware Solution

Test and Set Lock –

Memory Barriers

Atomic Variable
Priority Inversion problems with busy waiting
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
1
Preview
Mutual Exclusion in a Critical Section
With Sleep and Wake up
Producer Consumer Problem
Race Condition Producer Consumer problem
Semaphore

Concept of Semaphore

Semaphore Operation

Semaphore Implementation

Producer Consumer problem with semaphores

Careless Usage of semaphore causes deadlock 
Dining Philosophers Problem
Reader’s and Writer’s Problem
Mutexes
Monitor

Implementation of Monitor

Producer Consumer with Monitor
Message Passing

Producer Consumer with Message Passing
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
2
Mutual Exclusion with Sleep and Wakeup
Sleep and Wakeup-
A process check a resource (critical section), if not available go 
to sleep. 
When the resource become available, the process will be waked 
up by system or the process release the resource.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
3
The Producer-Consumer Problem
Description
Two processes share a common, fixed-sized buffer. 
Producer puts information into the buffer, and consumer takes it 
out.
Troubles arises 
When the producer wants to put a new item in the buffer, but it is 
already full.
When the consumer tries to take a item from the buffer, but buffer 
is already empty.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
4
The Producer-Consumer Problem
When the producer wants to put a new item in the buffer, 
but it is already full.
Solution – producer is go to sleep, awakened by customer when 
customer has removed on or more items.
When the consumer tries to take a item from the buffer, 
but buffer is already empty.
Solution – customer is go to sleep, awakened by the producer 
when producer puts one or more information into the buffer.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
5
The Producer-Consumer Problem
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
6
#define N 100 //buffer size
int count = 0;//# of item
void producer()
{
int item
while (true)
{
item = produce_item();
if (count == N)
sleep();
insert_item(item)
count = count + 1;
if (count ==1)
wakeup(consumer);
}
}
void consumer()
{
int item;
while(true)
{
if (count == 0)
sleep();
item = remove_item();
count = count – 1;
if (count == N – 1)
wakeup(producer);
consume_item(item);
}
}
' metadata={'source': '/tmp/tmp20n96_gc', 'file_path': '/tmp/tmp20n96_gc', 'page': 0, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}
2024-12-18 09:27:06 - INFO - Invoking chain
2024-12-18 09:27:06 - INFO - Successfully loaded 5 documents from: 450Slides11.pdf
2024-12-18 09:27:06 - INFO - Docs: [Document(metadata={'source': '/tmp/tmpy8ecv6xy', 'file_path': '/tmp/tmpy8ecv6xy', 'page': 0, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}, page_content='9/26/2024\n1\nReview\nInter-Process Communication\n\uf070Race Condition\n\uf070Critical Section (or region) \n\uf070Solutions for Mutual Exclusion in a Critical Section\n\uf06eWith Busy Waiting\n\uf070Disabling Interrupts –non-preemptive kernel\n\uf070Lock Variables –violating the first necessary condition (mutual exclusion )\n\uf070Strict Alternation –violating the second necessary condition ( block by a process outside critical section)\n\uf070Peterson’s Solution\n\uf070Hardware Solution\n\uf0a7\nTest and Set Lock –\n\uf0a7\nMemory Barriers\n\uf0a7\nAtomic Variable\n\uf070Priority Inversion problems with busy waiting\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n1\nPreview\n\uf070Mutual Exclusion in a Critical Section\n\uf06eWith Sleep and Wake up\n\uf070Producer Consumer Problem\n\uf070Race Condition Producer Consumer problem\n\uf070Semaphore\n\uf0a7\nConcept of Semaphore\n\uf0a7\nSemaphore Operation\n\uf0a7\nSemaphore Implementation\n\uf0a7\nProducer Consumer problem with semaphores\n\uf0a7\nCareless Usage of semaphore causes deadlock \n\uf070Dining Philosophers Problem\n\uf070Reader’s and Writer’s Problem\n\uf070Mutexes\n\uf070Monitor\n\uf0a7\nImplementation of Monitor\n\uf0a7\nProducer Consumer with Monitor\n\uf070Message Passing\n\uf0a7\nProducer Consumer with Message Passing\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n2\nMutual Exclusion with Sleep and Wakeup\n\uf070Sleep and Wakeup-\n\uf06eA process check a resource (critical section), if not available go \nto sleep. \n\uf06eWhen the resource become available, the process will be waked \nup by system or the process release the resource.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n3\nThe Producer-Consumer Problem\nDescription\n\uf070Two processes share a common, fixed-sized buffer. \n\uf070Producer puts information into the buffer, and consumer takes it \nout.\nTroubles arises \n\uf070When the producer wants to put a new item in the buffer, but it is \nalready full.\n\uf070When the consumer tries to take a item from the buffer, but buffer \nis already empty.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n4\nThe Producer-Consumer Problem\n\uf070When the producer wants to put a new item in the buffer, \nbut it is already full.\n\uf06eSolution – producer is go to sleep, awakened by customer when \ncustomer has removed on or more items.\n\uf070When the consumer tries to take a item from the buffer, \nbut buffer is already empty.\n\uf06eSolution – customer is go to sleep, awakened by the producer \nwhen producer puts one or more information into the buffer.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n5\nThe Producer-Consumer Problem\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n6\n#define N 100 //buffer size\nint count = 0;//# of item\nvoid producer()\n{\nint item\nwhile (true)\n{\nitem = produce_item();\nif (count == N)\nsleep();\ninsert_item(item)\ncount = count + 1;\nif (count ==1)\nwakeup(consumer);\n}\n}\nvoid consumer()\n{\nint item;\nwhile(true)\n{\nif (count == 0)\nsleep();\nitem = remove_item();\ncount = count – 1;\nif (count == N – 1)\nwakeup(producer);\nconsume_item(item);\n}\n}\n'), Document(metadata={'source': '/tmp/tmpy8ecv6xy', 'file_path': '/tmp/tmpy8ecv6xy', 'page': 1, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}, page_content='9/26/2024\n2\nSemaphores – by E. W. Dijkstra \n\uf070A semaphore is an integer variable which could have \nvalue \n\uf06e0:  no wakeups are saved\n\uf06e+ i: i wakeups are pending\n\uf070A semaphore is accessed only through two standard \natomic operations down (or P) and up (or V).\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n7\nConcept of Semaphores\n\uf070Modification to the integer value of the semaphore in the \ndown and up operations are executed indivisibly. \n\uf070Which means that when a process is modifying the \nsemaphore value, no other process can simultaneously \nmodify that same semaphore value.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n8\nSemaphore Operation\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n9\nvoid down (S)\n{\nif S == 0\n{\n1. Add this process to the sleeping list\n2. block;\n}\nS = S – 1;\n}\nvoid up (S)\n{\nS = S + 1;\nIf S = 1\n{\n1. choose one process P from the \nsleeping list or let them move to \nready state\n2. wakeup(P) to finish down operation\n}\n}\nSemaphore Implementation\nThe normal way for implementing a semaphore\n\uf070Implement semaphore operations up and down as \nsystem call.\n\uf070operating system briefly disabling all interrupts while it is \ntesting the semaphore, updating it and putting the \nprocess to sleep.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n10\nSolving the Producer-Consumer Problem using \nSemaphores\n#define N 100\ntypedef int semaphore;\nsemaphore mutex = 1;  //mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of item\nvoid producer ()\n{\nint item;\nwhile (ture)\n{\nitem = produce_item(); //produce item\ndown (&empty); //check empty space\ndown (&mutex); //check mutual exclusion\ninsert_item(item); //insert item\nup(&mutex); //out from critical section\nup(&full); //increase # of item\n}\n}\nvoid consumer()\n{\nint item;\nwhile (true)\n{\ndown(&full); //check item in buffer\ndown(&mutex) //check mutual exclusion\nitem = remove_item(); //remove a item\nup(&mutex); //out from critical section\nup(&empty); //increase the empty space\nconsume_item(item);\n}\n}\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n11\nCareless usage of Semaphore causes deadlock\n#define N 100\ntypedef int semaphore;\nsemaphore mutex = 1; //mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of item\nvoid producer ()\n{\nint item;\nwhile (ture)\n{\nitem = produce_item();\ndown (&mutex);\ndown (&empty);\ninsert_item(item);\nup(&mutex);\nup(&full);\n}\n}\nvoid consumer()\n{\nint item;\nwhile (true)\n{\ndown(&full)\ndown(&mutex)\nitem = remove_item();\nup(&mutex);\nup(&empty);\nconsume_item(item);\n}\n}\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n12\n'), Document(metadata={'source': '/tmp/tmpy8ecv6xy', 'file_path': '/tmp/tmpy8ecv6xy', 'page': 2, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}, page_content="9/26/2024\n3\nCareless usage of Semaphore causes deadlock\n#define N 100\ntypedef int semaphore;\nsemaphore mutex = 1; //mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of item\nvoid producer ()\n{\nint item;\nwhile (ture)\n{\nitem = produce_item();\ndown (&empty);\ndown (&mutex);\ninsert_item(item);\nup(&mutex);\nup(&full);\n}\n}\nvoid consumer()\n{\nint item;\nwhile (true)\n{\ndown(&mutex);\ndown(&full);\nitem = remove_item();\nup(&mutex);\nup(&empty);\nconsume_item(item);\n}\n}\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n13\nDining Philosophers Problem\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n14\nDining Philosophers Problem\n\uf070Five silent philosophers sit at a round table with bowls of spaghetti. Chopsticks \nare placed between each pair of adjacent philosophers.\n\uf070Each philosopher must alternately think and eat. However, a philosopher can \nonly eat spaghetti when they have both left and right chopsticks. \n\uf070Each chopstick can be held by only one philosopher and so a philosopher can use \nthe chopstick only if it is not being used by another philosopher. \n\uf070After an individual philosopher finishes eating, they need to put down both \nchopsticks so that the chopstick s become available to others. A philosopher can \ntake the chopstick on their right or the one on their left as they become \navailable, but cannot start eating before getting both chopsticks.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n15\nReaders-Writers Problem\n\uf070Process reader R and writers W are sharing resources at one time. \nOnly one process (reader or writer) can access the shared \nresources at any time.\n1. It is possible that a reader R1 might have the lock to a shared resource, and \nthen another reader R2 requests access. It would be foolish for R2 to wait \nuntil R1 was done before starting its own read operation; instead R1 and R2\ncan read same resource at the same time since both are reading.\n2. It is possible that a reader R1 might have the lock, a writer W be waiting for \nthe lock, and then a reader R2 requests access. It would be unfair for R2 to \njump in immediately, ahead of W; if that happened often \nenough, W would starve.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n16\nReaders-Writers Problem\nW2\nR3\nW1\nR2\nR1\nW2\nW1\nR1\nR2\nR3\nR4\nR3\nR2\nW1\nR1\nW1\nR1\nR4\nR2\nR3\nUnfair for W1 (starvation)\nMight be better\nShared resource(database)\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n17\nMutexes\n\uf070When the semaphore's ability to count is not needed, the simplified \nversion of the semaphore, called mutex is used.\n\uf070It is good for managing a mutual exclusion to some shared \nresources or pieces of code\n\uf070It is useful in thread packages that are implemented in user’s \nspace.\n\uf070A mutex is a variable that can be in one of two state: unlocked (0), \nlocked(1).\n\uf070A mutex concept is same as binary semaphore which has value 0 \nor 1.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n18\n"), Document(metadata={'source': '/tmp/tmpy8ecv6xy', 'file_path': '/tmp/tmpy8ecv6xy', 'page': 3, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}, page_content='9/26/2024\n4\nMutexes\nmutexes mutex = 0\nrepeat\nmutex_lock (mutex);\nmutex_unlock (mutex);\nuntil false\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n19\nCritical Section\nRemainder Section\nMonitor\n\uf070\nMonitor – High level synchronizing primitive \n\uf06e\nA collection of procedures, variables, and data structures that are all grouped \ntogether in a special kind of module.\n\uf06e\nOnly one process can be active in a monitor at any instant.\n\uf06e\nCompiler knows that monitors are special and can handle calls to monitor \nprocedure differently from other procedure call (create special code for \nmonitor).\n\uf06e\nWhen a process call a procedure inside a monitor, \n1.\ncheck whether any process is active within monitor or not. \n2.\nIf so, the calling process will be suspended until the other process has left the \nmonitor.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n20\nImplementation of Monitor\n\uf070Since monitor is a construct for a programming \nlanguage, Monitor implementation is based on the \ncompiler\n\uf070Compiler knows monitor is special kind of module, \ncompiler use mutex or binary semaphore for mutual \nexclusion.\n\uf070Monitor provide an easy way to achieve mutual exclusion. \nBut we need to consider, how a process can be blocked \nand how blocked process can be waked up?\n\uf06eIntroduction of Condition variables\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n21\nImplementation of Monitor\n\uf070Conditional variables are used in the monitor. \n\uf070There are two operation on the conditional variables (wait, signal).\n\uf070When a monitor procedure discovers that it cannot continue, it does wait \non some condition variable (ex full). This action causes the calling \nprocess to block. – allows other process get into the monitor.\n\uf070Other process (ex. consumer) can wake up its sleeping partner by doing \na signal on the condition variable that its partner is waiting on.\n\uf070If there are more than one processes are waiting on a condition variable, \nsystem scheduler choose one of them \nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n22\nImplementation of Monitor\nOnce a process do a signal, what is next step for the process do a \nsignal, to avoid having two active processes in the monitor at the \nsame time?\nSolution 1) by Hoare\n\uf06eLetting the newly awakened process run, suspending the one do the signal\nSolution 2) by Brinch Hansen\n\uf06eA signal statement may appear only as the final statement in a monitor \nprocedure.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n23\nProducer-Consumer with Monitor\nmonitor ProducerConsumer\ncondition full, empty;\ninteger count;\nprocedure insert (item: integer);\nbegin\nif count = N then\nwait (full);\ninsert_item(item);\ncount :=count + 1;\nif count = 1 then\nsignal (empty)\nend;\nfunction remove: integer;\nbegin\nif count = 0 then\nwait (empty);\nremove = remove_item;\ncount := count – 1;\nif count = N – 1 then\nsignal (full);\nend;\ncount := 0;\nend monitor\nprocedure producer\nbegin\nwhile true do\nbegin\nitem = produce_item;\nProducerConsumer.insert(item)\nend\nend;\nprocedure consumer;\nbegin\nwhile true do\nbegin\nitem = ProducerConsumer.remove;\nconsume_item(item)\nend\nend;\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n24\n'), Document(metadata={'source': '/tmp/tmpy8ecv6xy', 'file_path': '/tmp/tmpy8ecv6xy', 'page': 4, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}, page_content='9/26/2024\n5\nMessage Passing\n\uf070Message Passing is a method of interprocess communication by using two \nprimitive system calls\n\uf06esend(destination, &message);\n\uf06ereceive(source, &message);\n\uf070Usually Message Passing is used between processes located in different system \nsince it is slower than using semaphore or monitor in the same system.\n\uf070If there is no message is available, the receiver will be blocked by system until \none arrived.\n\uf070If there is no message to send, the sender will be blocked by system until one \nbecome available.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n25\nMessage Passing\n(Design Issues for Message Passing System)\n\uf070Message can be lost\n\uf06eSolution: \n\uf070When a message is received, receiver send acknowledgement message.\n\uf070If sender has not received the ack. message within a certain time interval, retransmits the \nmessage.\n\uf06eThis solution cause new design issue. \n\uf070Receiver receive a message from sender, receiver send Ack. message. If the Ack. \nmessage lost, sender send same message again. Then receiver receive same \nmessage twice.\n\uf06eSolution:\n\uf070Each message is assigned with sequence number.\n\uf070Receiver site system can recognize duplicated message and discard one of them.\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n26\nProducer-Consumer Problem \n(with Message Passing)\n#define N 100\n/* number of slots in the buffer */\nvoid producer ()\n{\nint item;\nmessage m;\n/* message buffer */\nwhile (ture)\n{\nitem = produce_item();\n/* generate item to put in buffer */\nreceive(consumer, &m);\n/* wait for an empty slot (ACK)*/\nbuild_message(&m, item);\n/* construct a message to send */\nsend(consumer, &m);\n/* send item to consumer */\n}\n}\nvoid consumer()\n{\nint item, i;\nmessage m;\nfor (i=0; i < N; i++)\n/* send N empty messages*/\nsend(producer, &m);\nwhile (true)\n{\nreceive(producer, &m);\n/* receive a message from producer */\nitem = extract_item(&m);\n/* extract a message */\nsend(producer, &m)\n/* send an empty message to producer (ACK)*/\nconsume_item(item);\n}\n}\nCOSC450  Operating System, Fall 2024                                               \nDr. Sang-Eon Park\n27\n')] for 450Slides11.pdf using PyMuPDFLoader
2024-12-18 09:27:06 - INFO - Document 1 (450Slides11.pdf) of 5
2024-12-18 09:27:06 - INFO - Starting clean_files_chain
2024-12-18 09:27:06 - INFO - Document: page_content='9/26/2024
1
Review
Inter-Process Communication
Race Condition
Critical Section (or region) 
Solutions for Mutual Exclusion in a Critical Section
With Busy Waiting
Disabling Interrupts –non-preemptive kernel
Lock Variables –violating the first necessary condition (mutual exclusion )
Strict Alternation –violating the second necessary condition ( block by a process outside critical section)
Peterson’s Solution
Hardware Solution

Test and Set Lock –

Memory Barriers

Atomic Variable
Priority Inversion problems with busy waiting
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
1
Preview
Mutual Exclusion in a Critical Section
With Sleep and Wake up
Producer Consumer Problem
Race Condition Producer Consumer problem
Semaphore

Concept of Semaphore

Semaphore Operation

Semaphore Implementation

Producer Consumer problem with semaphores

Careless Usage of semaphore causes deadlock 
Dining Philosophers Problem
Reader’s and Writer’s Problem
Mutexes
Monitor

Implementation of Monitor

Producer Consumer with Monitor
Message Passing

Producer Consumer with Message Passing
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
2
Mutual Exclusion with Sleep and Wakeup
Sleep and Wakeup-
A process check a resource (critical section), if not available go 
to sleep. 
When the resource become available, the process will be waked 
up by system or the process release the resource.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
3
The Producer-Consumer Problem
Description
Two processes share a common, fixed-sized buffer. 
Producer puts information into the buffer, and consumer takes it 
out.
Troubles arises 
When the producer wants to put a new item in the buffer, but it is 
already full.
When the consumer tries to take a item from the buffer, but buffer 
is already empty.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
4
The Producer-Consumer Problem
When the producer wants to put a new item in the buffer, 
but it is already full.
Solution – producer is go to sleep, awakened by customer when 
customer has removed on or more items.
When the consumer tries to take a item from the buffer, 
but buffer is already empty.
Solution – customer is go to sleep, awakened by the producer 
when producer puts one or more information into the buffer.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
5
The Producer-Consumer Problem
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
6
#define N 100 //buffer size
int count = 0;//# of item
void producer()
{
int item
while (true)
{
item = produce_item();
if (count == N)
sleep();
insert_item(item)
count = count + 1;
if (count ==1)
wakeup(consumer);
}
}
void consumer()
{
int item;
while(true)
{
if (count == 0)
sleep();
item = remove_item();
count = count – 1;
if (count == N – 1)
wakeup(producer);
consume_item(item);
}
}
' metadata={'source': '/tmp/tmpy8ecv6xy', 'file_path': '/tmp/tmpy8ecv6xy', 'page': 0, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}
2024-12-18 09:27:06 - INFO - Invoking chain
2024-12-18 09:27:18 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-18 09:27:18 - INFO - Response: {'cleaned_content': 'Date: 9/17/2024\n\nTitle: Real-Time CPU Scheduling\n\nTopics Covered:\n- Minimizing Latency\n- Preemptive Priority-Based Scheduling\n- Rate-Monotonic Scheduling\n- Earliest-Deadline-First Scheduling\n- Proportional Share Scheduling\n\nCriteria for Selecting an Algorithm\n\nCourse: COSC450 Operating Systems, Fall 2024\nInstructor: Dr. Sang-Eon Park\n\n---\n\n**Real-Time CPU Scheduling**\n\nCPU scheduling for real-time operating systems involves special issues. In general, we can distinguish between hard real-time systems and soft real-time systems.\n\n- **Hard real-time systems**: A task must be serviced by its deadline; service after the deadline has expired is equivalent to no service at all. Any missed deadline constitutes a system failure.\n    - Example: An inkjet printer has a print head with control software that deposits the correct amount of ink onto a specific part of the paper. If a deadline is missed, the print job is ruined.\n    - Example: Air France Flight 447 crashed into the ocean after a sensor malfunction caused a series of system errors.\n\n---\n\n- **Soft real-time systems**: These systems allow for frequently missed deadlines. As long as tasks are executed in a timely manner, their results continue to have value. Completed tasks may have increasing value up to the deadline and decreasing value past it.\n    - Example: Weather stations have many sensors for reading temperature, humidity, wind speed, etc. The readings should be taken and transmitted at regular intervals; however, the sensors are not synchronized. Even if a sensor reading is early or late compared to others, it can still be relevant as long as it is close enough.\n    - Example: In a computer sound system, missing a few bits may not be significant, but missing too many can degrade the system.\n\n---\n\n**Minimizing Latency**\n\nA real-time system typically waits for an event in real time to occur. Events may arise either in software (e.g., when a timer expires) or in hardware (e.g., when a remote-controlled vehicle detects an obstruction).\n\nWhen an event occurs, the system must respond to and service it as quickly as possible. Event latency is the amount of time that elapses from when an event occurs to when it is serviced. Different events have different latency requirements in a system:\n- For an antilock brake system: 3 to 5 milliseconds. If the antilock brake system does not respond within this time, a car accident may occur.\n\n---\n\nTwo types of latencies affect the performance of real-time systems:\n1. **Interrupt latency**: When an interrupt occurs, the OS must:\n   - Complete the instruction it is currently executing.\n   - Determine the type of interrupt that occurred.\n   - Save the state of the current process before servicing the interrupt using the specific interrupt service routine (ISR).\n   - Interrupt latency is the period of time from the arrival of an interrupt at the CPU to the start of the routine that services the interrupt.\n\n2. **Dispatch latency**: The amount of time required for the scheduling dispatcher to stop one process and start another.\n\n---'}
2024-12-18 09:27:18 - INFO - Finished clean_files_chain
2024-12-18 09:27:18 - INFO - Successfully cleaned document 1 from 450Slides9.pdf
2024-12-18 09:27:18 - INFO - Document 2 (450Slides9.pdf) of 4
2024-12-18 09:27:18 - INFO - Starting clean_files_chain
2024-12-18 09:27:18 - INFO - Document: page_content='9/17/2024
2
Real-Time CPU Scheduling  
(Minimizing Latency)
Two types of latencies affect the performance of real-time systems
1. Interrupt latency –
2. Dispatch latency –
Dispatch latency is the amount of time required for the scheduling dispatcher 
to stop one process and start another
The most effective technique for keeping dispatch latency low is to provide 
preemptive kernels. For hard real-time systems, dispatch latency is typically 
measured in several microseconds.
Two components of conflict phase of dispatch latency:
Preemption of any process running in the kernel
Release by low-priority processes of resources needed by a high-priority process
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
7
Real-Time CPU Scheduling  
(Minimizing Latency)
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
8
Fig. Dispatch Latency
Real-Time CPU Scheduling  
(Preemptive Priority-Based Scheduling)
The most important feature of a real-time operating system is to 
respond immediately to a real-time process.
In Priority-Based scheduling, scheduler always select highest 
priority process; more important tasks are assigned higher 
priorities than those deemed less important.
With Preemptive, process currently running on the CPU will be 
preempted if a higher-priority process becomes available to run.
Preemptive, priority-based scheduler only guarantees soft real-time 
functionality
Since hard real-time system need consider deadline, the scheduler 
requires additional scheduling features.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
9
Real-Time CPU Scheduling  
Characteristics for a process require to consider for real-time CPU 
scheduler.
Period (p)- That is, process require the CPU at constant intervals (periods).
Deadline (d)
Processing time (t)–fixed processing time
The relationship of the processing time, the deadline, and the 
period can be expressed as 
0 ≤ t ≤ d ≤ p. 
The rate of a periodic task is 1∕p.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
10
Real-Time CPU Scheduling 
A process have to provide its deadline requirement to the scheduler. Then, the 
scheduler either admit the process guaranteeing that the process will complete 
on time, or rejects the request as impossible (admission-control algorithm)
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
11
Fig. Periodic task.
Real-Time CPU Scheduling  
(Rate-Monotonic Scheduling)
Rate-monotonic scheduling assumes that the processing time of a 
periodic process is the same for each CPU burst. That is, every 
time a process acquires the CPU, the duration of its CPU burst is 
the same. 
Upon entering the system, priority is assigned to a process based 
on length of period (p). The shorter the period, the higher the 
priority.
The rate-monotonic scheduling algorithm schedules periodic tasks 
using a static priority policy with preemption.
If a lower-priority process is running and a higher-priority process 
becomes available to run, it will preempt the lower-priority 
process.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
12
' metadata={'source': '/tmp/tmpjdeb42g0', 'file_path': '/tmp/tmpjdeb42g0', 'page': 1, 'total_pages': 4, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240917075958-04'00'", 'modDate': "D:20240917075958-04'00'", 'trapped': ''}
2024-12-18 09:27:18 - INFO - Invoking chain
2024-12-18 09:27:20 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-18 09:27:20 - INFO - Response: {'cleaned_content': 'Date: 9/26/2024\n\n1. Review\n   - Inter-Process Communication\n     - Race Condition\n     - Critical Section (or region)\n     - Solutions for Mutual Exclusion in a Critical Section\n       - With Busy Waiting\n         - Disabling Interrupts – non-preemptive kernel\n         - Lock Variables – violating the first necessary condition (mutual exclusion)\n         - Strict Alternation – violating the second necessary condition (block by a process outside critical section)\n         - Peterson’s Solution\n         - Hardware Solution\n           - Test and Set Lock\n           - Memory Barriers\n           - Atomic Variable\n       - Priority Inversion problems with busy waiting\n\n2. Preview\n   - Mutual Exclusion in a Critical Section\n     - With Sleep and Wake up\n   - Producer Consumer Problem\n   - Race Condition in Producer Consumer problem\n   - Semaphore\n     - Concept of Semaphore\n     - Semaphore Operation\n     - Semaphore Implementation\n     - Producer Consumer problem with semaphores\n     - Careless Usage of semaphore causes deadlock\n   - Dining Philosophers Problem\n   - Reader’s and Writer’s Problem\n   - Mutexes\n   - Monitor\n     - Implementation of Monitor\n     - Producer Consumer with Monitor\n   - Message Passing\n     - Producer Consumer with Message Passing\n\n3. Mutual Exclusion with Sleep and Wakeup\n   - Sleep and Wakeup:\n     - A process checks a resource (critical section); if not available, it goes to sleep.\n     - When the resource becomes available, the process will be woken up by the system or the process that releases the resource.\n\n4. The Producer-Consumer Problem\n   - Description:\n     - Two processes share a common, fixed-sized buffer.\n     - Producer puts information into the buffer, and consumer takes it out.\n   - Troubles arise:\n     - When the producer wants to put a new item in the buffer, but it is already full.\n     - When the consumer tries to take an item from the buffer, but the buffer is already empty.\n\n5. The Producer-Consumer Problem\n   - When the producer wants to put a new item in the buffer, but it is already full:\n     - Solution: The producer goes to sleep, awakened by the consumer when the consumer has removed one or more items.\n   - When the consumer tries to take an item from the buffer, but the buffer is already empty:\n     - Solution: The consumer goes to sleep, awakened by the producer when the producer puts one or more items into the buffer.\n\n6. Implementation Example:\n   \n   #define N 100 // buffer size\n   int count = 0; // number of items\n   \n   void producer() {\n       int item;\n       while (true) {\n           item = produce_item();\n           if (count == N) {\n               sleep();\n           }\n           insert_item(item);\n           count = count + 1;\n           if (count == 1) {\n               wakeup(consumer);\n           }\n       }\n   }\n   \n   void consumer() {\n       int item;\n       while (true) {\n           if (count == 0) {\n               sleep();\n           }\n           item = remove_item();\n           count = count - 1;\n           if (count == N - 1) {\n               wakeup(producer);\n           }\n           consume_item(item);\n       }\n   }'}
2024-12-18 09:27:20 - INFO - Finished clean_files_chain
2024-12-18 09:27:20 - INFO - Successfully cleaned document 1 from 450Slides11.pdf
2024-12-18 09:27:20 - INFO - Document 2 (450Slides11.pdf) of 5
2024-12-18 09:27:20 - INFO - Starting clean_files_chain
2024-12-18 09:27:20 - INFO - Document: page_content='9/26/2024
2
Semaphores – by E. W. Dijkstra 
A semaphore is an integer variable which could have 
value 
0:  no wakeups are saved
+ i: i wakeups are pending
A semaphore is accessed only through two standard 
atomic operations down (or P) and up (or V).
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
7
Concept of Semaphores
Modification to the integer value of the semaphore in the 
down and up operations are executed indivisibly. 
Which means that when a process is modifying the 
semaphore value, no other process can simultaneously 
modify that same semaphore value.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
8
Semaphore Operation
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
9
void down (S)
{
if S == 0
{
1. Add this process to the sleeping list
2. block;
}
S = S – 1;
}
void up (S)
{
S = S + 1;
If S = 1
{
1. choose one process P from the 
sleeping list or let them move to 
ready state
2. wakeup(P) to finish down operation
}
}
Semaphore Implementation
The normal way for implementing a semaphore
Implement semaphore operations up and down as 
system call.
operating system briefly disabling all interrupts while it is 
testing the semaphore, updating it and putting the 
process to sleep.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
10
Solving the Producer-Consumer Problem using 
Semaphores
#define N 100
typedef int semaphore;
semaphore mutex = 1;  //mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of item
void producer ()
{
int item;
while (ture)
{
item = produce_item(); //produce item
down (&empty); //check empty space
down (&mutex); //check mutual exclusion
insert_item(item); //insert item
up(&mutex); //out from critical section
up(&full); //increase # of item
}
}
void consumer()
{
int item;
while (true)
{
down(&full); //check item in buffer
down(&mutex) //check mutual exclusion
item = remove_item(); //remove a item
up(&mutex); //out from critical section
up(&empty); //increase the empty space
consume_item(item);
}
}
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
11
Careless usage of Semaphore causes deadlock
#define N 100
typedef int semaphore;
semaphore mutex = 1; //mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of item
void producer ()
{
int item;
while (ture)
{
item = produce_item();
down (&mutex);
down (&empty);
insert_item(item);
up(&mutex);
up(&full);
}
}
void consumer()
{
int item;
while (true)
{
down(&full)
down(&mutex)
item = remove_item();
up(&mutex);
up(&empty);
consume_item(item);
}
}
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
12
' metadata={'source': '/tmp/tmpy8ecv6xy', 'file_path': '/tmp/tmpy8ecv6xy', 'page': 1, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}
2024-12-18 09:27:20 - INFO - Invoking chain
2024-12-18 09:27:20 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-18 09:27:20 - INFO - Response: {'cleaned_content': '9/26/2024\n\nReview\nInter-Process Communication\n- Race Condition\n- Critical Section (or region)\n- Solutions for Mutual Exclusion in a Critical Section\n  - With Busy Waiting\n    - Disabling Interrupts – non-preemptive kernel\n    - Lock Variables – violating the first necessary condition (mutual exclusion)\n    - Strict Alternation – violating the second necessary condition (block by a process outside critical section)\n    - Peterson’s Solution\n    - Hardware Solution\n      - Test and Set Lock\n      - Memory Barriers\n      - Atomic Variable\n- Priority Inversion problems with busy waiting\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nPreview\n- Mutual Exclusion in a Critical Section\n  - With Sleep and Wake up\n- Producer Consumer Problem\n- Race Condition Producer Consumer problem\n- Semaphore\n  - Concept of Semaphore\n  - Semaphore Operation\n  - Semaphore Implementation\n  - Producer Consumer problem with semaphores\n  - Careless Usage of semaphore causes deadlock\n- Dining Philosophers Problem\n- Reader’s and Writer’s Problem\n- Mutexes\n- Monitor\n  - Implementation of Monitor\n  - Producer Consumer with Monitor\n- Message Passing\n  - Producer Consumer with Message Passing\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMutual Exclusion with Sleep and Wakeup\n- Sleep and Wakeup:\n  - A process checks a resource (critical section), if not available go to sleep.\n  - When the resource becomes available, the process will be woken up by the system or the process releases the resource.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nThe Producer-Consumer Problem\nDescription\n- Two processes share a common, fixed-sized buffer.\n- Producer puts information into the buffer, and consumer takes it out.\n\nTroubles arise\n- When the producer wants to put a new item in the buffer, but it is already full.\n- When the consumer tries to take an item from the buffer, but the buffer is already empty.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nThe Producer-Consumer Problem\n- When the producer wants to put a new item in the buffer, but it is already full.\n  - Solution – the producer goes to sleep, awakened by the consumer when the consumer has removed one or more items.\n- When the consumer tries to take an item from the buffer, but the buffer is already empty.\n  - Solution – the consumer goes to sleep, awakened by the producer when the producer puts one or more items into the buffer.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nThe Producer-Consumer Problem\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\n#define N 100 // buffer size\nint count = 0; // number of items\n\nvoid producer() {\n    int item;\n    while (true) {\n        item = produce_item();\n        if (count == N) sleep();\n        insert_item(item);\n        count = count + 1;\n        if (count == 1) wakeup(consumer);\n    }\n}\n\nvoid consumer() {\n    int item;\n    while (true) {\n        if (count == 0) sleep();\n        item = remove_item();\n        count = count - 1;\n        if (count == N - 1) wakeup(producer);\n        consume_item(item);\n    }\n}'}
2024-12-18 09:27:20 - INFO - Finished clean_files_chain
2024-12-18 09:27:20 - INFO - Successfully cleaned document 1 from cosc450_11.pdf
2024-12-18 09:27:20 - INFO - Document 2 (cosc450_11.pdf) of 5
2024-12-18 09:27:20 - INFO - Starting clean_files_chain
2024-12-18 09:27:20 - INFO - Document: page_content='9/26/2024
2
Semaphores – by E. W. Dijkstra 
A semaphore is an integer variable which could have 
value 
0:  no wakeups are saved
+ i: i wakeups are pending
A semaphore is accessed only through two standard 
atomic operations down (or P) and up (or V).
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
7
Concept of Semaphores
Modification to the integer value of the semaphore in the 
down and up operations are executed indivisibly. 
Which means that when a process is modifying the 
semaphore value, no other process can simultaneously 
modify that same semaphore value.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
8
Semaphore Operation
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
9
void down (S)
{
if S == 0
{
1. Add this process to the sleeping list
2. block;
}
S = S – 1;
}
void up (S)
{
S = S + 1;
If S = 1
{
1. choose one process P from the 
sleeping list or let them move to 
ready state
2. wakeup(P) to finish down operation
}
}
Semaphore Implementation
The normal way for implementing a semaphore
Implement semaphore operations up and down as 
system call.
operating system briefly disabling all interrupts while it is 
testing the semaphore, updating it and putting the 
process to sleep.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
10
Solving the Producer-Consumer Problem using 
Semaphores
#define N 100
typedef int semaphore;
semaphore mutex = 1;  //mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of item
void producer ()
{
int item;
while (ture)
{
item = produce_item(); //produce item
down (&empty); //check empty space
down (&mutex); //check mutual exclusion
insert_item(item); //insert item
up(&mutex); //out from critical section
up(&full); //increase # of item
}
}
void consumer()
{
int item;
while (true)
{
down(&full); //check item in buffer
down(&mutex) //check mutual exclusion
item = remove_item(); //remove a item
up(&mutex); //out from critical section
up(&empty); //increase the empty space
consume_item(item);
}
}
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
11
Careless usage of Semaphore causes deadlock
#define N 100
typedef int semaphore;
semaphore mutex = 1; //mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of item
void producer ()
{
int item;
while (ture)
{
item = produce_item();
down (&mutex);
down (&empty);
insert_item(item);
up(&mutex);
up(&full);
}
}
void consumer()
{
int item;
while (true)
{
down(&full)
down(&mutex)
item = remove_item();
up(&mutex);
up(&empty);
consume_item(item);
}
}
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
12
' metadata={'source': '/tmp/tmp20n96_gc', 'file_path': '/tmp/tmp20n96_gc', 'page': 1, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}
2024-12-18 09:27:20 - INFO - Invoking chain
2024-12-18 09:27:31 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-18 09:27:31 - INFO - Response: {'cleaned_content': '9/17/2024\n\nReal-Time CPU Scheduling (Minimizing Latency)\n\nTwo types of latencies affect the performance of real-time systems:\n1. Interrupt latency\n2. Dispatch latency\n- Dispatch latency is the amount of time required for the scheduling dispatcher to stop one process and start another.\n- The most effective technique for keeping dispatch latency low is to provide preemptive kernels. For hard real-time systems, dispatch latency is typically measured in several microseconds.\n- Two components of the conflict phase of dispatch latency are:\n  - Preemption of any process running in the kernel.\n  - Release by low-priority processes of resources needed by a high-priority process.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nReal-Time CPU Scheduling (Minimizing Latency)\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nReal-Time CPU Scheduling (Preemptive Priority-Based Scheduling)\n\nThe most important feature of a real-time operating system is to respond immediately to a real-time process.\nIn priority-based scheduling, the scheduler always selects the highest priority process; more important tasks are assigned higher priorities than those deemed less important.\nWith preemptive scheduling, the process currently running on the CPU will be preempted if a higher-priority process becomes available to run.\nA preemptive, priority-based scheduler only guarantees soft real-time functionality.\nSince hard real-time systems need to consider deadlines, the scheduler requires additional scheduling features.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nReal-Time CPU Scheduling\n\nCharacteristics for a process that must be considered for a real-time CPU scheduler include:\n- Period (p): That is, the process requires the CPU at constant intervals (periods).\n- Deadline (d)\n- Processing time (t): fixed processing time\n\nThe relationship between the processing time, the deadline, and the period can be expressed as:\n0 ≤ t ≤ d ≤ p.\n\nThe rate of a periodic task is 1/p.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nReal-Time CPU Scheduling\n\nA process must provide its deadline requirement to the scheduler. The scheduler then either admits the process, guaranteeing that the process will complete on time, or rejects the request as impossible (admission-control algorithm).\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nReal-Time CPU Scheduling (Rate-Monotonic Scheduling)\n\nRate-monotonic scheduling assumes that the processing time of a periodic process is the same for each CPU burst. This means that every time a process acquires the CPU, the duration of its CPU burst is the same. \nUpon entering the system, priority is assigned to a process based on the length of the period (p). The shorter the period, the higher the priority.\nThe rate-monotonic scheduling algorithm schedules periodic tasks using a static priority policy with preemption.\nIf a lower-priority process is running and a higher-priority process becomes available to run, it will preempt the lower-priority process.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park'}
2024-12-18 09:27:31 - INFO - Finished clean_files_chain
2024-12-18 09:27:31 - INFO - Successfully cleaned document 2 from 450Slides9.pdf
2024-12-18 09:27:31 - INFO - Document 3 (450Slides9.pdf) of 4
2024-12-18 09:27:31 - INFO - Starting clean_files_chain
2024-12-18 09:27:31 - INFO - Document: page_content='9/17/2024
3
Real-Time CPU Scheduling  
(Rate-Monotonic Scheduling)
Ex) Two process P1, P2
p1= 50, t1=20, d1= by the start of its next period
CPU utilization of P1= p1/t1=20/50 = 0.4
p2=100, t2=35, d2 = by the start of its next period
CPU utilization of P1= p2/t2=35/100 = 0.35
Since t1 t2, P1 has higher priority than P2
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
13
110
0
120
150
160
170
180
190
200
130
140
100
30
40
50
60
70
80
90
20
10
P2
P1
P1
P2
P2
P1
P1
P2
p2
p1
p1
p1
p2
P1 ,P2 deadline =200
P1 deadline =150
P1 deadline =50
P1 ,P2 deadline =100
Real-Time CPU Scheduling  
(Rate-Monotonic Scheduling)
Ex) Two process P1, P2
p1= 50, t1=25, d1= by the start of its next period
CPU utilization of P1= p1/t1=25/50 = 0.5
p2=80, t2=35, d2 = by the start of its next period
CPU utilization of P2 = p2/t2=35/80 = 0.4375
Since t1 t2, P1 has higher priority than P2
rate-monotonic scheduling cannot guarantee that they can be scheduled so that they 
meet their deadlines.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
14
110
0
120
150
160
170
180
190
200
130
140
100
30
40
50
60
70
80
90
20
10
P2
P1
P1
P2
p2
p1
P1 deadline =50
p2
p2
p1
p1
p1
P2 deadline =80
Real-Time CPU Scheduling  
(Earliest-Deadline-First Scheduling)
Earliest-deadline-firs (EDF) scheduling assigns priorities 
dynamically according to deadline. 
The earlier the deadline, the higher the priority; 
The later the deadline, the lower the priority
When a process becomes runnable (ready state), it must 
announce its deadline requirements to the system. 
Priorities have to be adjusted to reflect the deadline of 
the newly runnable process.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
15
P2
P1
P2
P1
P2
P1
Real-Time CPU Scheduling  
(Earliest-Deadline-First Scheduling)
Ex) Two process P1, P2
p1= 50, t1=25, d1= by the start of its next period
CPU utilization of P1= p1/t1=25/50 = 0.5
p2=80, t2=35, d2 = by the start of its next period
CPU utilization of P2 = p2/t2=35/80 = 0.4375
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
16
110
0
120
150
160
170
180
190
200
130
140
100
30
40
50
60
70
80
90
20
10
p1
P2
p2
p2
p1
p1
p1
p2
P1
P1
P2
P1
Real-Time CPU Scheduling  
(Earliest-Deadline-First Scheduling)
EDF scheduling is theoretically optimal—theoretically, it 
can schedule processes so that each process can meet its 
deadline requirements and CPU utilization will be 100 
percent. 
In practice, it is not possible to achieve this level of CPU 
utilization due to the cost of context switching between 
processes and interrupt handling.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
17
Real-Time CPU Scheduling  
(Proportional Share Scheduling)
Proportional share schedulers operate by allocating T shares 
among all processes.
An process can receive N shares of time, ensuring that the process 
will have N∕T of the total processor time.
Ex) There are three processes P1, P2, and P3. And, total of share T 
= 100.
P1 is assigned 50 shares, P2 is assigned 15 shares, and P3 is assigned 20 
shares.
Means that P1 will have 50 %, P2 will have 15 %, and P3 will have 20 % of 
total processor time.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
18
' metadata={'source': '/tmp/tmpjdeb42g0', 'file_path': '/tmp/tmpjdeb42g0', 'page': 2, 'total_pages': 4, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240917075958-04'00'", 'modDate': "D:20240917075958-04'00'", 'trapped': ''}
2024-12-18 09:27:31 - INFO - Invoking chain
2024-12-18 09:27:32 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-18 09:27:32 - INFO - Response: {'cleaned_content': 'Date: 9/26/2024\n\nSemaphores – by E. W. Dijkstra\n\nA semaphore is an integer variable which can have the following values:\n- 0: No wakeups are saved\n- +i: i wakeups are pending\n\nA semaphore is accessed only through two standard atomic operations: down (or P) and up (or V).\n\nConcept of Semaphores:\n- Modification to the integer value of the semaphore in the down and up operations are executed indivisibly. This means that when a process is modifying the semaphore value, no other process can simultaneously modify that same semaphore value.\n\nSemaphore Operation:\n\nvoid down (S) {\n    if S == 0 {\n        1. Add this process to the sleeping list\n        2. block;\n    }\n    S = S - 1;\n}\n\nvoid up (S) {\n    S = S + 1;\n    if S = 1 {\n        1. Choose one process P from the sleeping list or let them move to ready state\n        2. wakeup(P) to finish down operation\n    }\n}\n\nSemaphore Implementation:\nThe normal way for implementing a semaphore is:\n- Implement semaphore operations up and down as system calls.\n- The operating system briefly disables all interrupts while it is testing the semaphore, updating it, and putting the process to sleep.\n\nSolving the Producer-Consumer Problem using Semaphores:\n#define N 100\ntypedef int semaphore;\nsemaphore mutex = 1;  // mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of items\n\nvoid producer() {\n    int item;\n    while (true) {\n        item = produce_item(); // produce item\n        down(&empty); // check empty space\n        down(&mutex); // check mutual exclusion\n        insert_item(item); // insert item\n        up(&mutex); // out from critical section\n        up(&full); // increase number of items\n    }\n}\n\nvoid consumer() {\n    int item;\n    while (true) {\n        down(&full); // check item in buffer\n        down(&mutex); // check mutual exclusion\n        item = remove_item(); // remove an item\n        up(&mutex); // out from critical section\n        up(&empty); // increase the empty space\n        consume_item(item);\n    }\n}\n\nCareless usage of Semaphore causes deadlock:\n#define N 100\ntypedef int semaphore;\nsemaphore mutex = 1; // mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of items\n\nvoid producer() {\n    int item;\n    while (true) {\n        item = produce_item();\n        down(&mutex);\n        down(&empty);\n        insert_item(item);\n        up(&mutex);\n        up(&full);\n    }\n}\n\nvoid consumer() {\n    int item;\n    while (true) {\n        down(&full);\n        down(&mutex);\n        item = remove_item();\n        up(&mutex);\n        up(&empty);\n        consume_item(item);\n    }\n}'}
2024-12-18 09:27:32 - INFO - Finished clean_files_chain
2024-12-18 09:27:32 - INFO - Successfully cleaned document 2 from 450Slides11.pdf
2024-12-18 09:27:32 - INFO - Document 3 (450Slides11.pdf) of 5
2024-12-18 09:27:32 - INFO - Starting clean_files_chain
2024-12-18 09:27:32 - INFO - Document: page_content='9/26/2024
3
Careless usage of Semaphore causes deadlock
#define N 100
typedef int semaphore;
semaphore mutex = 1; //mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of item
void producer ()
{
int item;
while (ture)
{
item = produce_item();
down (&empty);
down (&mutex);
insert_item(item);
up(&mutex);
up(&full);
}
}
void consumer()
{
int item;
while (true)
{
down(&mutex);
down(&full);
item = remove_item();
up(&mutex);
up(&empty);
consume_item(item);
}
}
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
13
Dining Philosophers Problem
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
14
Dining Philosophers Problem
Five silent philosophers sit at a round table with bowls of spaghetti. Chopsticks 
are placed between each pair of adjacent philosophers.
Each philosopher must alternately think and eat. However, a philosopher can 
only eat spaghetti when they have both left and right chopsticks. 
Each chopstick can be held by only one philosopher and so a philosopher can use 
the chopstick only if it is not being used by another philosopher. 
After an individual philosopher finishes eating, they need to put down both 
chopsticks so that the chopstick s become available to others. A philosopher can 
take the chopstick on their right or the one on their left as they become 
available, but cannot start eating before getting both chopsticks.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
15
Readers-Writers Problem
Process reader R and writers W are sharing resources at one time. 
Only one process (reader or writer) can access the shared 
resources at any time.
1. It is possible that a reader R1 might have the lock to a shared resource, and 
then another reader R2 requests access. It would be foolish for R2 to wait 
until R1 was done before starting its own read operation; instead R1 and R2
can read same resource at the same time since both are reading.
2. It is possible that a reader R1 might have the lock, a writer W be waiting for 
the lock, and then a reader R2 requests access. It would be unfair for R2 to 
jump in immediately, ahead of W; if that happened often 
enough, W would starve.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
16
Readers-Writers Problem
W2
R3
W1
R2
R1
W2
W1
R1
R2
R3
R4
R3
R2
W1
R1
W1
R1
R4
R2
R3
Unfair for W1 (starvation)
Might be better
Shared resource(database)
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
17
Mutexes
When the semaphore's ability to count is not needed, the simplified 
version of the semaphore, called mutex is used.
It is good for managing a mutual exclusion to some shared 
resources or pieces of code
It is useful in thread packages that are implemented in user’s 
space.
A mutex is a variable that can be in one of two state: unlocked (0), 
locked(1).
A mutex concept is same as binary semaphore which has value 0 
or 1.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
18
' metadata={'source': '/tmp/tmpy8ecv6xy', 'file_path': '/tmp/tmpy8ecv6xy', 'page': 2, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}
2024-12-18 09:27:32 - INFO - Invoking chain
2024-12-18 09:27:33 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-18 09:27:33 - INFO - Response: {'cleaned_content': '9/26/2024\n\nSemaphores – by E. W. Dijkstra\n\nA semaphore is an integer variable which could have the following values:\n- 0: no wakeups are saved\n- +i: i wakeups are pending\n\nA semaphore is accessed only through two standard atomic operations: down (or P) and up (or V).\n\nConcept of Semaphores:\n\nModification to the integer value of the semaphore in the down and up operations are executed indivisibly. This means that when a process is modifying the semaphore value, no other process can simultaneously modify that same semaphore value.\n\nSemaphore Operation:\n\nvoid down(S) {\n    if S == 0 {\n        1. Add this process to the sleeping list\n        2. block;\n    }\n    S = S - 1;\n}\n\nvoid up(S) {\n    S = S + 1;\n    if S == 1 {\n        1. choose one process P from the sleeping list or let them move to ready state\n        2. wakeup(P) to finish down operation\n    }\n}\n\nSemaphore Implementation:\nThe normal way for implementing a semaphore is to:\n- Implement semaphore operations up and down as system calls.\n- The operating system briefly disables all interrupts while it is testing the semaphore, updating it, and putting the process to sleep.\n\nSolving the Producer-Consumer Problem using Semaphores:\n\n#define N 100\n\ntypedef int semaphore;\nsemaphore mutex = 1;  // mutual exclusion\nsemaphore empty = N;  // empty space\nsemaphore full = 0;   // number of items\n\nvoid producer() {\n    int item;\n    while (true) {\n        item = produce_item(); // produce item\n        down(&empty); // check empty space\n        down(&mutex); // check mutual exclusion\n        insert_item(item); // insert item\n        up(&mutex); // out from critical section\n        up(&full); // increase # of items\n    }\n}\n\nvoid consumer() {\n    int item;\n    while (true) {\n        down(&full); // check item in buffer\n        down(&mutex); // check mutual exclusion\n        item = remove_item(); // remove an item\n        up(&mutex); // out from critical section\n        up(&empty); // increase the empty space\n        consume_item(item);\n    }\n}\n\nCareless usage of Semaphore causes deadlock:\n\n#define N 100\n\ntypedef int semaphore;\nsemaphore mutex = 1; // mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of items\n\nvoid producer() {\n    int item;\n    while (true) {\n        item = produce_item();\n        down(&mutex);\n        down(&empty);\n        insert_item(item);\n        up(&mutex);\n        up(&full);\n    }\n}\n\nvoid consumer() {\n    int item;\n    while (true) {\n        down(&full);\n        down(&mutex);\n        item = remove_item();\n        up(&mutex);\n        up(&empty);\n        consume_item(item);\n    }\n}'}
2024-12-18 09:27:33 - INFO - Finished clean_files_chain
2024-12-18 09:27:33 - INFO - Successfully cleaned document 2 from cosc450_11.pdf
2024-12-18 09:27:33 - INFO - Document 3 (cosc450_11.pdf) of 5
2024-12-18 09:27:33 - INFO - Starting clean_files_chain
2024-12-18 09:27:33 - INFO - Document: page_content='9/26/2024
3
Careless usage of Semaphore causes deadlock
#define N 100
typedef int semaphore;
semaphore mutex = 1; //mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of item
void producer ()
{
int item;
while (ture)
{
item = produce_item();
down (&empty);
down (&mutex);
insert_item(item);
up(&mutex);
up(&full);
}
}
void consumer()
{
int item;
while (true)
{
down(&mutex);
down(&full);
item = remove_item();
up(&mutex);
up(&empty);
consume_item(item);
}
}
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
13
Dining Philosophers Problem
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
14
Dining Philosophers Problem
Five silent philosophers sit at a round table with bowls of spaghetti. Chopsticks 
are placed between each pair of adjacent philosophers.
Each philosopher must alternately think and eat. However, a philosopher can 
only eat spaghetti when they have both left and right chopsticks. 
Each chopstick can be held by only one philosopher and so a philosopher can use 
the chopstick only if it is not being used by another philosopher. 
After an individual philosopher finishes eating, they need to put down both 
chopsticks so that the chopstick s become available to others. A philosopher can 
take the chopstick on their right or the one on their left as they become 
available, but cannot start eating before getting both chopsticks.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
15
Readers-Writers Problem
Process reader R and writers W are sharing resources at one time. 
Only one process (reader or writer) can access the shared 
resources at any time.
1. It is possible that a reader R1 might have the lock to a shared resource, and 
then another reader R2 requests access. It would be foolish for R2 to wait 
until R1 was done before starting its own read operation; instead R1 and R2
can read same resource at the same time since both are reading.
2. It is possible that a reader R1 might have the lock, a writer W be waiting for 
the lock, and then a reader R2 requests access. It would be unfair for R2 to 
jump in immediately, ahead of W; if that happened often 
enough, W would starve.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
16
Readers-Writers Problem
W2
R3
W1
R2
R1
W2
W1
R1
R2
R3
R4
R3
R2
W1
R1
W1
R1
R4
R2
R3
Unfair for W1 (starvation)
Might be better
Shared resource(database)
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
17
Mutexes
When the semaphore's ability to count is not needed, the simplified 
version of the semaphore, called mutex is used.
It is good for managing a mutual exclusion to some shared 
resources or pieces of code
It is useful in thread packages that are implemented in user’s 
space.
A mutex is a variable that can be in one of two state: unlocked (0), 
locked(1).
A mutex concept is same as binary semaphore which has value 0 
or 1.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
18
' metadata={'source': '/tmp/tmp20n96_gc', 'file_path': '/tmp/tmp20n96_gc', 'page': 2, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}
2024-12-18 09:27:33 - INFO - Invoking chain
2024-12-18 09:27:45 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-18 09:27:45 - INFO - Response: {'cleaned_content': "Date: 9/26/2024\n\nCareless use of Semaphore causes deadlock:\n\n#define N 100\n\ntypedef int semaphore;\nsemaphore mutex = 1; // mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of items\n\nvoid producer() {\n    int item;\n    while (true) {\n        item = produce_item();\n        down(&empty);\n        down(&mutex);\n        insert_item(item);\n        up(&mutex);\n        up(&full);\n    }\n}\n\nvoid consumer() {\n    int item;\n    while (true) {\n        down(&mutex);\n        down(&full);\n        item = remove_item();\n        up(&mutex);\n        up(&empty);\n        consume_item(item);\n    }\n}\n\nCourse: COSC450 Operating System, Fall 2024\nInstructor: Dr. Sang-Eon Park\n\nDining Philosophers Problem:\n- Five silent philosophers sit at a round table with bowls of spaghetti. Chopsticks are placed between each pair of adjacent philosophers.\n- Each philosopher must alternately think and eat. However, a philosopher can only eat spaghetti when they have both left and right chopsticks.\n- Each chopstick can be held by only one philosopher, so a philosopher can use the chopstick only if it is not being used by another philosopher.\n- After finishing eating, a philosopher needs to put down both chopsticks, making them available to others. A philosopher can take the chopstick on their right or the one on their left as they become available, but cannot start eating before getting both chopsticks.\n\nReaders-Writers Problem:\n- Process reader R and writers W share resources at one time. Only one process (reader or writer) can access the shared resources at any time.\n1. It is possible for a reader R1 to hold the lock to a shared resource, and then another reader R2 requests access. It would be inefficient for R2 to wait until R1 is finished before starting its read operation; instead, R1 and R2 can read the same resource simultaneously since both are reading.\n2. It is also possible for a reader R1 to hold the lock, while a writer W waits for access, and then a reader R2 requests access. It would be unfair for R2 to jump in immediately ahead of W; if this occurs frequently, W could experience starvation.\n\nMutexes:\n- When the semaphore's counting capability is not needed, a simplified version called a mutex is used.\n- Mutexes are beneficial for managing mutual exclusion to shared resources or sections of code.\n- They are useful in thread packages implemented in user space.\n- A mutex is a variable that can be in one of two states: unlocked (0) or locked (1).\n- The concept of a mutex is the same as a binary semaphore, which has a value of either 0 or 1."}
2024-12-18 09:27:45 - INFO - Finished clean_files_chain
2024-12-18 09:27:45 - INFO - Successfully cleaned document 3 from 450Slides11.pdf
2024-12-18 09:27:45 - INFO - Document 4 (450Slides11.pdf) of 5
2024-12-18 09:27:45 - INFO - Starting clean_files_chain
2024-12-18 09:27:45 - INFO - Document: page_content='9/26/2024
4
Mutexes
mutexes mutex = 0
repeat
mutex_lock (mutex);
mutex_unlock (mutex);
until false
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
19
Critical Section
Remainder Section
Monitor

Monitor – High level synchronizing primitive 

A collection of procedures, variables, and data structures that are all grouped 
together in a special kind of module.

Only one process can be active in a monitor at any instant.

Compiler knows that monitors are special and can handle calls to monitor 
procedure differently from other procedure call (create special code for 
monitor).

When a process call a procedure inside a monitor, 
1.
check whether any process is active within monitor or not. 
2.
If so, the calling process will be suspended until the other process has left the 
monitor.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
20
Implementation of Monitor
Since monitor is a construct for a programming 
language, Monitor implementation is based on the 
compiler
Compiler knows monitor is special kind of module, 
compiler use mutex or binary semaphore for mutual 
exclusion.
Monitor provide an easy way to achieve mutual exclusion. 
But we need to consider, how a process can be blocked 
and how blocked process can be waked up?
Introduction of Condition variables
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
21
Implementation of Monitor
Conditional variables are used in the monitor. 
There are two operation on the conditional variables (wait, signal).
When a monitor procedure discovers that it cannot continue, it does wait 
on some condition variable (ex full). This action causes the calling 
process to block. – allows other process get into the monitor.
Other process (ex. consumer) can wake up its sleeping partner by doing 
a signal on the condition variable that its partner is waiting on.
If there are more than one processes are waiting on a condition variable, 
system scheduler choose one of them 
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
22
Implementation of Monitor
Once a process do a signal, what is next step for the process do a 
signal, to avoid having two active processes in the monitor at the 
same time?
Solution 1) by Hoare
Letting the newly awakened process run, suspending the one do the signal
Solution 2) by Brinch Hansen
A signal statement may appear only as the final statement in a monitor 
procedure.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
23
Producer-Consumer with Monitor
monitor ProducerConsumer
condition full, empty;
integer count;
procedure insert (item: integer);
begin
if count = N then
wait (full);
insert_item(item);
count :=count + 1;
if count = 1 then
signal (empty)
end;
function remove: integer;
begin
if count = 0 then
wait (empty);
remove = remove_item;
count := count – 1;
if count = N – 1 then
signal (full);
end;
count := 0;
end monitor
procedure producer
begin
while true do
begin
item = produce_item;
ProducerConsumer.insert(item)
end
end;
procedure consumer;
begin
while true do
begin
item = ProducerConsumer.remove;
consume_item(item)
end
end;
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
24
' metadata={'source': '/tmp/tmpy8ecv6xy', 'file_path': '/tmp/tmpy8ecv6xy', 'page': 3, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}
2024-12-18 09:27:45 - INFO - Invoking chain
2024-12-18 09:27:46 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-18 09:27:46 - INFO - Response: {'cleaned_content': "Date: 9/26/2024\n\nCareless usage of Semaphore causes deadlock.\n\n#define N 100\n\ntypedef int semaphore;\nsemaphore mutex = 1; // mutual exclusion\nsemaphore empty = N; // empty space\nsemaphore full = 0; // number of items\n\nvoid producer() {\n    int item;\n    while (true) {\n        item = produce_item();\n        down(&empty);\n        down(&mutex);\n        insert_item(item);\n        up(&mutex);\n        up(&full);\n    }\n}\n\nvoid consumer() {\n    int item;\n    while (true) {\n        down(&mutex);\n        down(&full);\n        item = remove_item();\n        up(&mutex);\n        up(&empty);\n        consume_item(item);\n    }\n}\n\nCourse: COSC450 Operating System, Fall 2024\nInstructor: Dr. Sang-Eon Park\n\nDining Philosophers Problem:\n- Five silent philosophers sit at a round table with bowls of spaghetti. Chopsticks are placed between each pair of adjacent philosophers.\n- Each philosopher must alternately think and eat. However, a philosopher can only eat spaghetti when they have both left and right chopsticks.\n- Each chopstick can be held by only one philosopher, so a philosopher can use the chopstick only if it is not being used by another philosopher.\n- After an individual philosopher finishes eating, they need to put down both chopsticks, making them available to others. A philosopher can take the chopstick on their right or the one on their left as they become available, but cannot start eating before getting both chopsticks.\n\nCourse: COSC450 Operating System, Fall 2024\nInstructor: Dr. Sang-Eon Park\n\nReaders-Writers Problem:\n- Process reader R and writers W share resources at one time. Only one process (reader or writer) can access the shared resources at any time.\n1. It is possible that a reader R1 might have the lock to a shared resource, and then another reader R2 requests access. It would be inefficient for R2 to wait until R1 is done before starting its own read operation; instead, R1 and R2 can read the same resource at the same time since both are reading.\n2. It is possible that a reader R1 might have the lock, a writer W be waiting for the lock, and then a reader R2 requests access. It would be unfair for R2 to jump in immediately ahead of W; if that happened often enough, W would starve.\n\nCourse: COSC450 Operating System, Fall 2024\nInstructor: Dr. Sang-Eon Park\n\nMutexes:\n- When the semaphore's ability to count is not needed, the simplified version of the semaphore, called a mutex, is used.\n- It is good for managing mutual exclusion to some shared resources or pieces of code.\n- It is useful in thread packages that are implemented in user space.\n- A mutex is a variable that can be in one of two states: unlocked (0) or locked (1).\n- The concept of a mutex is the same as a binary semaphore, which has a value of 0 or 1.\n\nCourse: COSC450 Operating System, Fall 2024\nInstructor: Dr. Sang-Eon Park"}
2024-12-18 09:27:46 - INFO - Finished clean_files_chain
2024-12-18 09:27:46 - INFO - Successfully cleaned document 3 from cosc450_11.pdf
2024-12-18 09:27:46 - INFO - Document 4 (cosc450_11.pdf) of 5
2024-12-18 09:27:46 - INFO - Starting clean_files_chain
2024-12-18 09:27:46 - INFO - Document: page_content='9/26/2024
4
Mutexes
mutexes mutex = 0
repeat
mutex_lock (mutex);
mutex_unlock (mutex);
until false
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
19
Critical Section
Remainder Section
Monitor

Monitor – High level synchronizing primitive 

A collection of procedures, variables, and data structures that are all grouped 
together in a special kind of module.

Only one process can be active in a monitor at any instant.

Compiler knows that monitors are special and can handle calls to monitor 
procedure differently from other procedure call (create special code for 
monitor).

When a process call a procedure inside a monitor, 
1.
check whether any process is active within monitor or not. 
2.
If so, the calling process will be suspended until the other process has left the 
monitor.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
20
Implementation of Monitor
Since monitor is a construct for a programming 
language, Monitor implementation is based on the 
compiler
Compiler knows monitor is special kind of module, 
compiler use mutex or binary semaphore for mutual 
exclusion.
Monitor provide an easy way to achieve mutual exclusion. 
But we need to consider, how a process can be blocked 
and how blocked process can be waked up?
Introduction of Condition variables
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
21
Implementation of Monitor
Conditional variables are used in the monitor. 
There are two operation on the conditional variables (wait, signal).
When a monitor procedure discovers that it cannot continue, it does wait 
on some condition variable (ex full). This action causes the calling 
process to block. – allows other process get into the monitor.
Other process (ex. consumer) can wake up its sleeping partner by doing 
a signal on the condition variable that its partner is waiting on.
If there are more than one processes are waiting on a condition variable, 
system scheduler choose one of them 
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
22
Implementation of Monitor
Once a process do a signal, what is next step for the process do a 
signal, to avoid having two active processes in the monitor at the 
same time?
Solution 1) by Hoare
Letting the newly awakened process run, suspending the one do the signal
Solution 2) by Brinch Hansen
A signal statement may appear only as the final statement in a monitor 
procedure.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
23
Producer-Consumer with Monitor
monitor ProducerConsumer
condition full, empty;
integer count;
procedure insert (item: integer);
begin
if count = N then
wait (full);
insert_item(item);
count :=count + 1;
if count = 1 then
signal (empty)
end;
function remove: integer;
begin
if count = 0 then
wait (empty);
remove = remove_item;
count := count – 1;
if count = N – 1 then
signal (full);
end;
count := 0;
end monitor
procedure producer
begin
while true do
begin
item = produce_item;
ProducerConsumer.insert(item)
end
end;
procedure consumer;
begin
while true do
begin
item = ProducerConsumer.remove;
consume_item(item)
end
end;
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
24
' metadata={'source': '/tmp/tmp20n96_gc', 'file_path': '/tmp/tmp20n96_gc', 'page': 3, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}
2024-12-18 09:27:46 - INFO - Invoking chain
2024-12-18 09:28:01 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-18 09:28:01 - INFO - Response: {'cleaned_content': 'Date: 9/17/2024\n\nReal-Time CPU Scheduling (Rate-Monotonic Scheduling)\n\nExample: Two processes P1 and P2\n- For P1: processing time (p1) = 50, period (t1) = 20, deadline (d1) = by the start of its next period\n- CPU utilization of P1 = p1/t1 = 20/50 = 0.4\n- For P2: processing time (p2) = 100, period (t2) = 35, deadline (d2) = by the start of its next period\n- CPU utilization of P2 = p2/t2 = 35/100 = 0.35\n\nSince t1 < t2, P1 has a higher priority than P2.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nDeadline Analysis:\n- P1, P2 deadline = 200\n- P1 deadline = 150\n- P1 deadline = 50\n- P1, P2 deadline = 100\n\nReal-Time CPU Scheduling (Rate-Monotonic Scheduling)\n\nExample: Two processes P1 and P2\n- For P1: processing time (p1) = 50, period (t1) = 25, deadline (d1) = by the start of its next period\n- CPU utilization of P1 = p1/t1 = 25/50 = 0.5\n- For P2: processing time (p2) = 80, period (t2) = 35, deadline (d2) = by the start of its next period\n- CPU utilization of P2 = p2/t2 = 35/80 = 0.4375\n\nSince t1 < t2, P1 has a higher priority than P2. Rate-monotonic scheduling cannot guarantee that they can be scheduled so that they meet their deadlines.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nReal-Time CPU Scheduling (Earliest-Deadline-First Scheduling)\n\nEarliest-deadline-first (EDF) scheduling assigns priorities dynamically according to deadlines:\n- The earlier the deadline, the higher the priority.\n- The later the deadline, the lower the priority.\n\nWhen a process becomes runnable (in the ready state), it must announce its deadline requirements to the system. Priorities must be adjusted to reflect the deadline of the newly runnable process.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nExample: Two processes P1 and P2\n- For P1: processing time (p1) = 50, period (t1) = 25, deadline (d1) = by the start of its next period\n- CPU utilization of P1 = p1/t1 = 25/50 = 0.5\n- For P2: processing time (p2) = 80, period (t2) = 35, deadline (d2) = by the start of its next period\n- CPU utilization of P2 = p2/t2 = 35/80 = 0.4375\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nReal-Time CPU Scheduling (Earliest-Deadline-First Scheduling)\n\nEDF scheduling is theoretically optimal; it can schedule processes so that each process meets its deadline requirements, achieving 100% CPU utilization. However, in practice, this level of CPU utilization is not achievable due to the costs of context switching between processes and handling interrupts.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nReal-Time CPU Scheduling (Proportional Share Scheduling)\n\nProportional share schedulers operate by allocating T shares among all processes. A process can receive N shares of time, ensuring that the process will have N/T of the total processor time.\n\nExample: There are three processes P1, P2, and P3, with a total of shares T = 100.\n- P1 is assigned 50 shares, P2 is assigned 15 shares, and P3 is assigned 20 shares.\n- This means that P1 will have 50%, P2 will have 15%, and P3 will have 20% of the total processor time.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park'}
2024-12-18 09:28:01 - INFO - Finished clean_files_chain
2024-12-18 09:28:01 - INFO - Successfully cleaned document 3 from 450Slides9.pdf
2024-12-18 09:28:01 - INFO - Document 4 (450Slides9.pdf) of 4
2024-12-18 09:28:01 - INFO - Starting clean_files_chain
2024-12-18 09:28:01 - INFO - Document: page_content='9/17/2024
4
Real-Time CPU Scheduling  
(Proportional Share Scheduling)
Proportional share schedulers must work in conjunction 
with an admission-control policy to guarantee that an 
application receives its allocated shares of time.
An admission-control policy will admit a process 
requesting a particular number of shares only if sufficient 
shares are available.
In previous example, we have allocated 50 + 15 + 20 = 85 
shares of the total of 100 shares. 
If a new process P4 requested 30 shares, the admission 
controller would deny P4 entry into the system.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
19
Scheduling Algorithm Evaluation
Criteria for selecting an algorithm.
CPU Utilization
Throughput
Response time
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
20
' metadata={'source': '/tmp/tmpjdeb42g0', 'file_path': '/tmp/tmpjdeb42g0', 'page': 3, 'total_pages': 4, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240917075958-04'00'", 'modDate': "D:20240917075958-04'00'", 'trapped': ''}
2024-12-18 09:28:01 - INFO - Invoking chain
2024-12-18 09:28:04 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-18 09:28:04 - INFO - Response: {'cleaned_content': '9/26/2024\n\nMutexes\n\nmutexes mutex = 0\nrepeat\n    mutex_lock(mutex);\n    mutex_unlock(mutex);\nuntil false\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nCritical Section\nRemainder Section\n\nMonitor\n- Monitor – High level synchronizing primitive.\n- A collection of procedures, variables, and data structures that are all grouped together in a special kind of module.\n- Only one process can be active in a monitor at any instant.\n- The compiler knows that monitors are special and can handle calls to monitor procedures differently from other procedure calls (it creates special code for monitors).\n- When a process calls a procedure inside a monitor:\n  1. It checks whether any process is active within the monitor or not.\n  2. If so, the calling process will be suspended until the other process has left the monitor.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nImplementation of Monitor\n- Since the monitor is a construct for a programming language, monitor implementation is based on the compiler.\n- The compiler knows that the monitor is a special kind of module and uses mutex or binary semaphore for mutual exclusion.\n- Monitors provide an easy way to achieve mutual exclusion, but we need to consider how a process can be blocked and how a blocked process can be awakened.\n- This introduces condition variables.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nImplementation of Monitor\n- Conditional variables are used in the monitor.\n- There are two operations on the conditional variables: wait and signal.\n- When a monitor procedure discovers that it cannot continue, it waits on some condition variable (e.g., full). This action causes the calling process to block, allowing other processes to enter the monitor.\n- Other processes (e.g., the consumer) can wake up their sleeping partner by signaling the condition variable that their partner is waiting on.\n- If more than one process is waiting on a condition variable, the system scheduler chooses one of them.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nImplementation of Monitor\nOnce a process performs a signal, what is the next step to avoid having two active processes in the monitor at the same time?\n\nSolution 1) by Hoare\n- Letting the newly awakened process run while suspending the one that performed the signal.\n\nSolution 2) by Brinch Hansen\n- A signal statement may appear only as the final statement in a monitor procedure.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nProducer-Consumer with Monitor\n\nmonitor ProducerConsumer\n    condition full, empty;\n    integer count;\n\n    procedure insert(item: integer);\n    begin\n        if count = N then\n            wait(full);\n        insert_item(item);\n        count := count + 1;\n        if count = 1 then\n            signal(empty);\n    end;\n\n    function remove: integer;\n    begin\n        if count = 0 then\n            wait(empty);\n        remove = remove_item;\n        count := count - 1;\n        if count = N - 1 then\n            signal(full);\n    end;\n\ncount := 0;\nend monitor\n\nprocedure producer\nbegin\n    while true do\n    begin\n        item = produce_item;\n        ProducerConsumer.insert(item);\n    end;\nend;\n\nprocedure consumer\nbegin\n    while true do\n    begin\n        item = ProducerConsumer.remove;\n        consume_item(item);\n    end;\nend;\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park'}
2024-12-18 09:28:04 - INFO - Finished clean_files_chain
2024-12-18 09:28:04 - INFO - Successfully cleaned document 4 from 450Slides11.pdf
2024-12-18 09:28:04 - INFO - Document 5 (450Slides11.pdf) of 5
2024-12-18 09:28:04 - INFO - Starting clean_files_chain
2024-12-18 09:28:04 - INFO - Document: page_content='9/26/2024
5
Message Passing
Message Passing is a method of interprocess communication by using two 
primitive system calls
send(destination, &message);
receive(source, &message);
Usually Message Passing is used between processes located in different system 
since it is slower than using semaphore or monitor in the same system.
If there is no message is available, the receiver will be blocked by system until 
one arrived.
If there is no message to send, the sender will be blocked by system until one 
become available.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
25
Message Passing
(Design Issues for Message Passing System)
Message can be lost
Solution: 
When a message is received, receiver send acknowledgement message.
If sender has not received the ack. message within a certain time interval, retransmits the 
message.
This solution cause new design issue. 
Receiver receive a message from sender, receiver send Ack. message. If the Ack. 
message lost, sender send same message again. Then receiver receive same 
message twice.
Solution:
Each message is assigned with sequence number.
Receiver site system can recognize duplicated message and discard one of them.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
26
Producer-Consumer Problem 
(with Message Passing)
#define N 100
/* number of slots in the buffer */
void producer ()
{
int item;
message m;
/* message buffer */
while (ture)
{
item = produce_item();
/* generate item to put in buffer */
receive(consumer, &m);
/* wait for an empty slot (ACK)*/
build_message(&m, item);
/* construct a message to send */
send(consumer, &m);
/* send item to consumer */
}
}
void consumer()
{
int item, i;
message m;
for (i=0; i < N; i++)
/* send N empty messages*/
send(producer, &m);
while (true)
{
receive(producer, &m);
/* receive a message from producer */
item = extract_item(&m);
/* extract a message */
send(producer, &m)
/* send an empty message to producer (ACK)*/
consume_item(item);
}
}
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
27
' metadata={'source': '/tmp/tmpy8ecv6xy', 'file_path': '/tmp/tmpy8ecv6xy', 'page': 4, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}
2024-12-18 09:28:04 - INFO - Invoking chain
2024-12-18 09:28:04 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-18 09:28:04 - INFO - Response: {'cleaned_content': 'Date: 9/17/2024\n\nReal-Time CPU Scheduling (Proportional Share Scheduling)\n\n- Proportional share schedulers must work in conjunction with an admission-control policy to guarantee that an application receives its allocated shares of time.\n- An admission-control policy will admit a process requesting a particular number of shares only if sufficient shares are available.\n  - In a previous example, we allocated 50 + 15 + 20 = 85 shares of the total of 100 shares.\n  - If a new process P4 requested 30 shares, the admission controller would deny P4 entry into the system.\n\nScheduling Algorithm Evaluation\n- Criteria for selecting an algorithm:\n  - CPU Utilization\n  - Throughput\n  - Response time\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park'}
2024-12-18 09:28:04 - INFO - Finished clean_files_chain
2024-12-18 09:28:04 - INFO - Successfully cleaned document 4 from 450Slides9.pdf
2024-12-18 09:28:09 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-18 09:28:09 - INFO - Response: {'cleaned_content': '9/26/2024\n\nMutexes\n\nmutexes mutex = 0;\nrepeat\n    mutex_lock(mutex);\n    mutex_unlock(mutex);\nuntil false\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nCritical Section\nRemainder Section\n\nMonitor\n- Monitor – High level synchronizing primitive\n  - A collection of procedures, variables, and data structures that are all grouped together in a special kind of module.\n  - Only one process can be active in a monitor at any instant.\n  - Compiler knows that monitors are special and can handle calls to monitor procedures differently from other procedure calls (create special code for monitor).\n  - When a process calls a procedure inside a monitor:\n    1. Check whether any process is active within the monitor.\n    2. If so, the calling process will be suspended until the other process has left the monitor.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nImplementation of Monitor\n- Since the monitor is a construct for a programming language, monitor implementation is based on the compiler.\n- The compiler knows the monitor is a special kind of module; it uses mutex or binary semaphore for mutual exclusion.\n- The monitor provides an easy way to achieve mutual exclusion. However, we need to consider how a process can be blocked and how a blocked process can be woken up.\n  - Introduction of Condition variables\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nImplementation of Monitor\n- Conditional variables are used in the monitor.\n- There are two operations on the conditional variables (wait, signal).\n- When a monitor procedure discovers that it cannot continue, it waits on some condition variable (e.g., full). This action causes the calling process to block, allowing other processes to enter the monitor.\n- Other processes (e.g., consumer) can wake up their sleeping partner by signaling the condition variable that their partner is waiting on.\n- If there is more than one process waiting on a condition variable, the system scheduler chooses one of them.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nImplementation of Monitor\nOnce a process does a signal, what is the next step to avoid having two active processes in the monitor at the same time?\nSolution 1: by Hoare\n- Letting the newly awakened process run, suspending the one that issued the signal.\nSolution 2: by Brinch Hansen\n- A signal statement may appear only as the final statement in a monitor procedure.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nProducer-Consumer with Monitor\nmonitor ProducerConsumer\n    condition full, empty;\n    integer count;\n    procedure insert(item: integer);\n    begin\n        if count = N then\n            wait(full);\n        insert_item(item);\n        count := count + 1;\n        if count = 1 then\n            signal(empty);\n    end;\n\n    function remove: integer;\n    begin\n        if count = 0 then\n            wait(empty);\n        remove = remove_item;\n        count := count - 1;\n        if count = N - 1 then\n            signal(full);\n    end;\n\ncount := 0;\nend monitor\n\nprocedure producer;\nbegin\n    while true do\n    begin\n        item = produce_item;\n        ProducerConsumer.insert(item);\n    end;\nend;\n\nprocedure consumer;\nbegin\n    while true do\n    begin\n        item = ProducerConsumer.remove;\n        consume_item(item);\n    end;\nend;\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park'}
2024-12-18 09:28:09 - INFO - Finished clean_files_chain
2024-12-18 09:28:09 - INFO - Successfully cleaned document 4 from cosc450_11.pdf
2024-12-18 09:28:09 - INFO - Document 5 (cosc450_11.pdf) of 5
2024-12-18 09:28:09 - INFO - Starting clean_files_chain
2024-12-18 09:28:09 - INFO - Document: page_content='9/26/2024
5
Message Passing
Message Passing is a method of interprocess communication by using two 
primitive system calls
send(destination, &message);
receive(source, &message);
Usually Message Passing is used between processes located in different system 
since it is slower than using semaphore or monitor in the same system.
If there is no message is available, the receiver will be blocked by system until 
one arrived.
If there is no message to send, the sender will be blocked by system until one 
become available.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
25
Message Passing
(Design Issues for Message Passing System)
Message can be lost
Solution: 
When a message is received, receiver send acknowledgement message.
If sender has not received the ack. message within a certain time interval, retransmits the 
message.
This solution cause new design issue. 
Receiver receive a message from sender, receiver send Ack. message. If the Ack. 
message lost, sender send same message again. Then receiver receive same 
message twice.
Solution:
Each message is assigned with sequence number.
Receiver site system can recognize duplicated message and discard one of them.
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
26
Producer-Consumer Problem 
(with Message Passing)
#define N 100
/* number of slots in the buffer */
void producer ()
{
int item;
message m;
/* message buffer */
while (ture)
{
item = produce_item();
/* generate item to put in buffer */
receive(consumer, &m);
/* wait for an empty slot (ACK)*/
build_message(&m, item);
/* construct a message to send */
send(consumer, &m);
/* send item to consumer */
}
}
void consumer()
{
int item, i;
message m;
for (i=0; i < N; i++)
/* send N empty messages*/
send(producer, &m);
while (true)
{
receive(producer, &m);
/* receive a message from producer */
item = extract_item(&m);
/* extract a message */
send(producer, &m)
/* send an empty message to producer (ACK)*/
consume_item(item);
}
}
COSC450  Operating System, Fall 2024                                               
Dr. Sang-Eon Park
27
' metadata={'source': '/tmp/tmp20n96_gc', 'file_path': '/tmp/tmp20n96_gc', 'page': 4, 'total_pages': 5, 'format': 'PDF 1.7', 'title': 'Preview', 'author': 'Sang-Eon Park', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240926124054-04'00'", 'modDate': "D:20240926124054-04'00'", 'trapped': ''}
2024-12-18 09:28:09 - INFO - Invoking chain
2024-12-18 09:28:14 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-18 09:28:14 - INFO - Response: {'cleaned_content': "9/26/2024\n\nMessage Passing\n- Message Passing is a method of interprocess communication using two primitive system calls:\n  1. send(destination, &message);\n  2. receive(source, &message);\n- Typically, Message Passing is used between processes located in different systems since it is slower than using semaphore or monitor in the same system.\n- If no message is available, the receiver will be blocked by the system until one arrives.\n- If there is no message to send, the sender will be blocked by the system until one becomes available.\n\nCOSC450 Operating System, Fall 2024  \nDr. Sang-Eon Park\n\nMessage Passing (Design Issues for Message Passing System)\n- Messages can be lost.\n  - Solution:\n    - When a message is received, the receiver sends an acknowledgement (ACK) message.\n    - If the sender has not received the ACK message within a certain time interval, it retransmits the message.\n  - This solution causes a new design issue:\n    - The receiver receives a message from the sender and sends an ACK message. If the ACK message is lost, the sender sends the same message again. Then the receiver receives the same message twice.\n  - Solution:\n    - Each message is assigned a sequence number.\n    - The receiver's system can recognize duplicate messages and discard one of them.\n\nCOSC450 Operating System, Fall 2024  \nDr. Sang-Eon Park\n\nProducer-Consumer Problem (with Message Passing)\n#define N 100  // number of slots in the buffer\n\nvoid producer() {\n    int item;\n    message m;  // message buffer\n    while (true) {\n        item = produce_item();  // generate item to put in buffer\n        receive(consumer, &m);  // wait for an empty slot (ACK)\n        build_message(&m, item);  // construct a message to send\n        send(consumer, &m);  // send item to consumer\n    }\n}\n\nvoid consumer() {\n    int item, i;\n    message m;\n    for (i = 0; i < N; i++) {  // send N empty messages\n        send(producer, &m);\n    }\n    while (true) {\n        receive(producer, &m);  // receive a message from producer\n        item = extract_item(&m);  // extract a message\n        send(producer, &m);  // send an empty message to producer (ACK)\n        consume_item(item);\n    }\n}\n\nCOSC450 Operating System, Fall 2024  \nDr. Sang-Eon Park"}
2024-12-18 09:28:14 - INFO - Finished clean_files_chain
2024-12-18 09:28:14 - INFO - Successfully cleaned document 5 from 450Slides11.pdf
2024-12-18 09:28:20 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-18 09:28:20 - INFO - Response: {'cleaned_content': "9/26/2024\n\nMessage Passing\n- Message Passing is a method of interprocess communication using two primitive system calls:\n  - send(destination, &message);\n  - receive(source, &message);\n- Usually, Message Passing is used between processes located in different systems since it is slower than using semaphore or monitor in the same system.\n- If there is no message available, the receiver will be blocked by the system until one arrives.\n- If there is no message to send, the sender will be blocked by the system until one becomes available.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nMessage Passing (Design Issues for Message Passing System)\n- Messages can be lost.\n  - Solution:\n    - When a message is received, the receiver sends an acknowledgement message.\n    - If the sender has not received the acknowledgement message within a certain time interval, it retransmits the message.\n  - This solution causes a new design issue:\n    - If the receiver receives a message from the sender and sends an acknowledgement message, but if the acknowledgement message is lost, then the sender sends the same message again, resulting in the receiver receiving the same message twice.\n  - Solution:\n    - Each message is assigned a sequence number.\n    - The receiver's system can recognize duplicated messages and discard one of them.\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park\n\nProducer-Consumer Problem (with Message Passing)\n#define N 100\n/* number of slots in the buffer */\n\nvoid producer() {\n    int item;\n    message m;\n    /* message buffer */\n    while (true) {\n        item = produce_item();\n        /* generate item to put in buffer */\n        receive(consumer, &m);\n        /* wait for an empty slot (ACK) */\n        build_message(&m, item);\n        /* construct a message to send */\n        send(consumer, &m);\n        /* send item to consumer */\n    }\n}\n\nvoid consumer() {\n    int item, i;\n    message m;\n    for (i = 0; i < N; i++)\n        /* send N empty messages */\n        send(producer, &m);\n    while (true) {\n        receive(producer, &m);\n        /* receive a message from producer */\n        item = extract_item(&m);\n        /* extract a message */\n        send(producer, &m);\n        /* send an empty message to producer (ACK) */\n        consume_item(item);\n    }\n}\n\nCOSC450 Operating System, Fall 2024\nDr. Sang-Eon Park"}
2024-12-18 09:28:20 - INFO - Finished clean_files_chain
2024-12-18 09:28:20 - INFO - Successfully cleaned document 5 from cosc450_11.pdf
2024-12-18 09:28:20 - INFO - Pages: []
2024-12-18 09:28:20 - INFO - Full response: Date: 9/17/2024

Title: Real-Time CPU Scheduling

Topics Covered:
- Minimizing Latency
- Preemptive Priority-Based Scheduling
- Rate-Monotonic Scheduling
- Earliest-Deadline-First Scheduling
- Proportional Share Scheduling

Criteria for Selecting an Algorithm

Course: COSC450 Operating Systems, Fall 2024
Instructor: Dr. Sang-Eon Park

---

**Real-Time CPU Scheduling**

CPU scheduling for real-time operating systems involves special issues. In general, we can distinguish between hard real-time systems and soft real-time systems.

- **Hard real-time systems**: A task must be serviced by its deadline; service after the deadline has expired is equivalent to no service at all. Any missed deadline constitutes a system failure.
    - Example: An inkjet printer has a print head with control software that deposits the correct amount of ink onto a specific part of the paper. If a deadline is missed, the print job is ruined.
    - Example: Air France Flight 447 crashed into the ocean after a sensor malfunction caused a series of system errors.

---

- **Soft real-time systems**: These systems allow for frequently missed deadlines. As long as tasks are executed in a timely manner, their results continue to have value. Completed tasks may have increasing value up to the deadline and decreasing value past it.
    - Example: Weather stations have many sensors for reading temperature, humidity, wind speed, etc. The readings should be taken and transmitted at regular intervals; however, the sensors are not synchronized. Even if a sensor reading is early or late compared to others, it can still be relevant as long as it is close enough.
    - Example: In a computer sound system, missing a few bits may not be significant, but missing too many can degrade the system.

---

**Minimizing Latency**

A real-time system typically waits for an event in real time to occur. Events may arise either in software (e.g., when a timer expires) or in hardware (e.g., when a remote-controlled vehicle detects an obstruction).

When an event occurs, the system must respond to and service it as quickly as possible. Event latency is the amount of time that elapses from when an event occurs to when it is serviced. Different events have different latency requirements in a system:
- For an antilock brake system: 3 to 5 milliseconds. If the antilock brake system does not respond within this time, a car accident may occur.

---

Two types of latencies affect the performance of real-time systems:
1. **Interrupt latency**: When an interrupt occurs, the OS must:
   - Complete the instruction it is currently executing.
   - Determine the type of interrupt that occurred.
   - Save the state of the current process before servicing the interrupt using the specific interrupt service routine (ISR).
   - Interrupt latency is the period of time from the arrival of an interrupt at the CPU to the start of the routine that services the interrupt.

2. **Dispatch latency**: The amount of time required for the scheduling dispatcher to stop one process and start another.

---9/17/2024

Real-Time CPU Scheduling (Minimizing Latency)

Two types of latencies affect the performance of real-time systems:
1. Interrupt latency
2. Dispatch latency
- Dispatch latency is the amount of time required for the scheduling dispatcher to stop one process and start another.
- The most effective technique for keeping dispatch latency low is to provide preemptive kernels. For hard real-time systems, dispatch latency is typically measured in several microseconds.
- Two components of the conflict phase of dispatch latency are:
  - Preemption of any process running in the kernel.
  - Release by low-priority processes of resources needed by a high-priority process.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Real-Time CPU Scheduling (Minimizing Latency)

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Real-Time CPU Scheduling (Preemptive Priority-Based Scheduling)

The most important feature of a real-time operating system is to respond immediately to a real-time process.
In priority-based scheduling, the scheduler always selects the highest priority process; more important tasks are assigned higher priorities than those deemed less important.
With preemptive scheduling, the process currently running on the CPU will be preempted if a higher-priority process becomes available to run.
A preemptive, priority-based scheduler only guarantees soft real-time functionality.
Since hard real-time systems need to consider deadlines, the scheduler requires additional scheduling features.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Real-Time CPU Scheduling

Characteristics for a process that must be considered for a real-time CPU scheduler include:
- Period (p): That is, the process requires the CPU at constant intervals (periods).
- Deadline (d)
- Processing time (t): fixed processing time

The relationship between the processing time, the deadline, and the period can be expressed as:
0 ≤ t ≤ d ≤ p.

The rate of a periodic task is 1/p.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Real-Time CPU Scheduling

A process must provide its deadline requirement to the scheduler. The scheduler then either admits the process, guaranteeing that the process will complete on time, or rejects the request as impossible (admission-control algorithm).

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Real-Time CPU Scheduling (Rate-Monotonic Scheduling)

Rate-monotonic scheduling assumes that the processing time of a periodic process is the same for each CPU burst. This means that every time a process acquires the CPU, the duration of its CPU burst is the same. 
Upon entering the system, priority is assigned to a process based on the length of the period (p). The shorter the period, the higher the priority.
The rate-monotonic scheduling algorithm schedules periodic tasks using a static priority policy with preemption.
If a lower-priority process is running and a higher-priority process becomes available to run, it will preempt the lower-priority process.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon ParkDate: 9/17/2024

Real-Time CPU Scheduling (Rate-Monotonic Scheduling)

Example: Two processes P1 and P2
- For P1: processing time (p1) = 50, period (t1) = 20, deadline (d1) = by the start of its next period
- CPU utilization of P1 = p1/t1 = 20/50 = 0.4
- For P2: processing time (p2) = 100, period (t2) = 35, deadline (d2) = by the start of its next period
- CPU utilization of P2 = p2/t2 = 35/100 = 0.35

Since t1 < t2, P1 has a higher priority than P2.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Deadline Analysis:
- P1, P2 deadline = 200
- P1 deadline = 150
- P1 deadline = 50
- P1, P2 deadline = 100

Real-Time CPU Scheduling (Rate-Monotonic Scheduling)

Example: Two processes P1 and P2
- For P1: processing time (p1) = 50, period (t1) = 25, deadline (d1) = by the start of its next period
- CPU utilization of P1 = p1/t1 = 25/50 = 0.5
- For P2: processing time (p2) = 80, period (t2) = 35, deadline (d2) = by the start of its next period
- CPU utilization of P2 = p2/t2 = 35/80 = 0.4375

Since t1 < t2, P1 has a higher priority than P2. Rate-monotonic scheduling cannot guarantee that they can be scheduled so that they meet their deadlines.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Real-Time CPU Scheduling (Earliest-Deadline-First Scheduling)

Earliest-deadline-first (EDF) scheduling assigns priorities dynamically according to deadlines:
- The earlier the deadline, the higher the priority.
- The later the deadline, the lower the priority.

When a process becomes runnable (in the ready state), it must announce its deadline requirements to the system. Priorities must be adjusted to reflect the deadline of the newly runnable process.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Example: Two processes P1 and P2
- For P1: processing time (p1) = 50, period (t1) = 25, deadline (d1) = by the start of its next period
- CPU utilization of P1 = p1/t1 = 25/50 = 0.5
- For P2: processing time (p2) = 80, period (t2) = 35, deadline (d2) = by the start of its next period
- CPU utilization of P2 = p2/t2 = 35/80 = 0.4375

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Real-Time CPU Scheduling (Earliest-Deadline-First Scheduling)

EDF scheduling is theoretically optimal; it can schedule processes so that each process meets its deadline requirements, achieving 100% CPU utilization. However, in practice, this level of CPU utilization is not achievable due to the costs of context switching between processes and handling interrupts.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Real-Time CPU Scheduling (Proportional Share Scheduling)

Proportional share schedulers operate by allocating T shares among all processes. A process can receive N shares of time, ensuring that the process will have N/T of the total processor time.

Example: There are three processes P1, P2, and P3, with a total of shares T = 100.
- P1 is assigned 50 shares, P2 is assigned 15 shares, and P3 is assigned 20 shares.
- This means that P1 will have 50%, P2 will have 15%, and P3 will have 20% of the total processor time.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon ParkDate: 9/17/2024

Real-Time CPU Scheduling (Proportional Share Scheduling)

- Proportional share schedulers must work in conjunction with an admission-control policy to guarantee that an application receives its allocated shares of time.
- An admission-control policy will admit a process requesting a particular number of shares only if sufficient shares are available.
  - In a previous example, we allocated 50 + 15 + 20 = 85 shares of the total of 100 shares.
  - If a new process P4 requested 30 shares, the admission controller would deny P4 entry into the system.

Scheduling Algorithm Evaluation
- Criteria for selecting an algorithm:
  - CPU Utilization
  - Throughput
  - Response time

COSC450 Operating System, Fall 2024
Dr. Sang-Eon ParkDate: 9/26/2024

1. Review
   - Inter-Process Communication
     - Race Condition
     - Critical Section (or region)
     - Solutions for Mutual Exclusion in a Critical Section
       - With Busy Waiting
         - Disabling Interrupts – non-preemptive kernel
         - Lock Variables – violating the first necessary condition (mutual exclusion)
         - Strict Alternation – violating the second necessary condition (block by a process outside critical section)
         - Peterson’s Solution
         - Hardware Solution
           - Test and Set Lock
           - Memory Barriers
           - Atomic Variable
       - Priority Inversion problems with busy waiting

2. Preview
   - Mutual Exclusion in a Critical Section
     - With Sleep and Wake up
   - Producer Consumer Problem
   - Race Condition in Producer Consumer problem
   - Semaphore
     - Concept of Semaphore
     - Semaphore Operation
     - Semaphore Implementation
     - Producer Consumer problem with semaphores
     - Careless Usage of semaphore causes deadlock
   - Dining Philosophers Problem
   - Reader’s and Writer’s Problem
   - Mutexes
   - Monitor
     - Implementation of Monitor
     - Producer Consumer with Monitor
   - Message Passing
     - Producer Consumer with Message Passing

3. Mutual Exclusion with Sleep and Wakeup
   - Sleep and Wakeup:
     - A process checks a resource (critical section); if not available, it goes to sleep.
     - When the resource becomes available, the process will be woken up by the system or the process that releases the resource.

4. The Producer-Consumer Problem
   - Description:
     - Two processes share a common, fixed-sized buffer.
     - Producer puts information into the buffer, and consumer takes it out.
   - Troubles arise:
     - When the producer wants to put a new item in the buffer, but it is already full.
     - When the consumer tries to take an item from the buffer, but the buffer is already empty.

5. The Producer-Consumer Problem
   - When the producer wants to put a new item in the buffer, but it is already full:
     - Solution: The producer goes to sleep, awakened by the consumer when the consumer has removed one or more items.
   - When the consumer tries to take an item from the buffer, but the buffer is already empty:
     - Solution: The consumer goes to sleep, awakened by the producer when the producer puts one or more items into the buffer.

6. Implementation Example:
   
   #define N 100 // buffer size
   int count = 0; // number of items
   
   void producer() {
       int item;
       while (true) {
           item = produce_item();
           if (count == N) {
               sleep();
           }
           insert_item(item);
           count = count + 1;
           if (count == 1) {
               wakeup(consumer);
           }
       }
   }
   
   void consumer() {
       int item;
       while (true) {
           if (count == 0) {
               sleep();
           }
           item = remove_item();
           count = count - 1;
           if (count == N - 1) {
               wakeup(producer);
           }
           consume_item(item);
       }
   }Date: 9/26/2024

Semaphores – by E. W. Dijkstra

A semaphore is an integer variable which can have the following values:
- 0: No wakeups are saved
- +i: i wakeups are pending

A semaphore is accessed only through two standard atomic operations: down (or P) and up (or V).

Concept of Semaphores:
- Modification to the integer value of the semaphore in the down and up operations are executed indivisibly. This means that when a process is modifying the semaphore value, no other process can simultaneously modify that same semaphore value.

Semaphore Operation:

void down (S) {
    if S == 0 {
        1. Add this process to the sleeping list
        2. block;
    }
    S = S - 1;
}

void up (S) {
    S = S + 1;
    if S = 1 {
        1. Choose one process P from the sleeping list or let them move to ready state
        2. wakeup(P) to finish down operation
    }
}

Semaphore Implementation:
The normal way for implementing a semaphore is:
- Implement semaphore operations up and down as system calls.
- The operating system briefly disables all interrupts while it is testing the semaphore, updating it, and putting the process to sleep.

Solving the Producer-Consumer Problem using Semaphores:
#define N 100
typedef int semaphore;
semaphore mutex = 1;  // mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of items

void producer() {
    int item;
    while (true) {
        item = produce_item(); // produce item
        down(&empty); // check empty space
        down(&mutex); // check mutual exclusion
        insert_item(item); // insert item
        up(&mutex); // out from critical section
        up(&full); // increase number of items
    }
}

void consumer() {
    int item;
    while (true) {
        down(&full); // check item in buffer
        down(&mutex); // check mutual exclusion
        item = remove_item(); // remove an item
        up(&mutex); // out from critical section
        up(&empty); // increase the empty space
        consume_item(item);
    }
}

Careless usage of Semaphore causes deadlock:
#define N 100
typedef int semaphore;
semaphore mutex = 1; // mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of items

void producer() {
    int item;
    while (true) {
        item = produce_item();
        down(&mutex);
        down(&empty);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer() {
    int item;
    while (true) {
        down(&full);
        down(&mutex);
        item = remove_item();
        up(&mutex);
        up(&empty);
        consume_item(item);
    }
}Date: 9/26/2024

Careless use of Semaphore causes deadlock:

#define N 100

typedef int semaphore;
semaphore mutex = 1; // mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of items

void producer() {
    int item;
    while (true) {
        item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer() {
    int item;
    while (true) {
        down(&mutex);
        down(&full);
        item = remove_item();
        up(&mutex);
        up(&empty);
        consume_item(item);
    }
}

Course: COSC450 Operating System, Fall 2024
Instructor: Dr. Sang-Eon Park

Dining Philosophers Problem:
- Five silent philosophers sit at a round table with bowls of spaghetti. Chopsticks are placed between each pair of adjacent philosophers.
- Each philosopher must alternately think and eat. However, a philosopher can only eat spaghetti when they have both left and right chopsticks.
- Each chopstick can be held by only one philosopher, so a philosopher can use the chopstick only if it is not being used by another philosopher.
- After finishing eating, a philosopher needs to put down both chopsticks, making them available to others. A philosopher can take the chopstick on their right or the one on their left as they become available, but cannot start eating before getting both chopsticks.

Readers-Writers Problem:
- Process reader R and writers W share resources at one time. Only one process (reader or writer) can access the shared resources at any time.
1. It is possible for a reader R1 to hold the lock to a shared resource, and then another reader R2 requests access. It would be inefficient for R2 to wait until R1 is finished before starting its read operation; instead, R1 and R2 can read the same resource simultaneously since both are reading.
2. It is also possible for a reader R1 to hold the lock, while a writer W waits for access, and then a reader R2 requests access. It would be unfair for R2 to jump in immediately ahead of W; if this occurs frequently, W could experience starvation.

Mutexes:
- When the semaphore's counting capability is not needed, a simplified version called a mutex is used.
- Mutexes are beneficial for managing mutual exclusion to shared resources or sections of code.
- They are useful in thread packages implemented in user space.
- A mutex is a variable that can be in one of two states: unlocked (0) or locked (1).
- The concept of a mutex is the same as a binary semaphore, which has a value of either 0 or 1.9/26/2024

Mutexes

mutexes mutex = 0
repeat
    mutex_lock(mutex);
    mutex_unlock(mutex);
until false

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Critical Section
Remainder Section

Monitor
- Monitor – High level synchronizing primitive.
- A collection of procedures, variables, and data structures that are all grouped together in a special kind of module.
- Only one process can be active in a monitor at any instant.
- The compiler knows that monitors are special and can handle calls to monitor procedures differently from other procedure calls (it creates special code for monitors).
- When a process calls a procedure inside a monitor:
  1. It checks whether any process is active within the monitor or not.
  2. If so, the calling process will be suspended until the other process has left the monitor.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Implementation of Monitor
- Since the monitor is a construct for a programming language, monitor implementation is based on the compiler.
- The compiler knows that the monitor is a special kind of module and uses mutex or binary semaphore for mutual exclusion.
- Monitors provide an easy way to achieve mutual exclusion, but we need to consider how a process can be blocked and how a blocked process can be awakened.
- This introduces condition variables.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Implementation of Monitor
- Conditional variables are used in the monitor.
- There are two operations on the conditional variables: wait and signal.
- When a monitor procedure discovers that it cannot continue, it waits on some condition variable (e.g., full). This action causes the calling process to block, allowing other processes to enter the monitor.
- Other processes (e.g., the consumer) can wake up their sleeping partner by signaling the condition variable that their partner is waiting on.
- If more than one process is waiting on a condition variable, the system scheduler chooses one of them.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Implementation of Monitor
Once a process performs a signal, what is the next step to avoid having two active processes in the monitor at the same time?

Solution 1) by Hoare
- Letting the newly awakened process run while suspending the one that performed the signal.

Solution 2) by Brinch Hansen
- A signal statement may appear only as the final statement in a monitor procedure.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Producer-Consumer with Monitor

monitor ProducerConsumer
    condition full, empty;
    integer count;

    procedure insert(item: integer);
    begin
        if count = N then
            wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then
            signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then
            wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N - 1 then
            signal(full);
    end;

count := 0;
end monitor

procedure producer
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end;
end;

procedure consumer
begin
    while true do
    begin
        item = ProducerConsumer.remove;
        consume_item(item);
    end;
end;

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park9/26/2024

Message Passing
- Message Passing is a method of interprocess communication using two primitive system calls:
  1. send(destination, &message);
  2. receive(source, &message);
- Typically, Message Passing is used between processes located in different systems since it is slower than using semaphore or monitor in the same system.
- If no message is available, the receiver will be blocked by the system until one arrives.
- If there is no message to send, the sender will be blocked by the system until one becomes available.

COSC450 Operating System, Fall 2024  
Dr. Sang-Eon Park

Message Passing (Design Issues for Message Passing System)
- Messages can be lost.
  - Solution:
    - When a message is received, the receiver sends an acknowledgement (ACK) message.
    - If the sender has not received the ACK message within a certain time interval, it retransmits the message.
  - This solution causes a new design issue:
    - The receiver receives a message from the sender and sends an ACK message. If the ACK message is lost, the sender sends the same message again. Then the receiver receives the same message twice.
  - Solution:
    - Each message is assigned a sequence number.
    - The receiver's system can recognize duplicate messages and discard one of them.

COSC450 Operating System, Fall 2024  
Dr. Sang-Eon Park

Producer-Consumer Problem (with Message Passing)
#define N 100  // number of slots in the buffer

void producer() {
    int item;
    message m;  // message buffer
    while (true) {
        item = produce_item();  // generate item to put in buffer
        receive(consumer, &m);  // wait for an empty slot (ACK)
        build_message(&m, item);  // construct a message to send
        send(consumer, &m);  // send item to consumer
    }
}

void consumer() {
    int item, i;
    message m;
    for (i = 0; i < N; i++) {  // send N empty messages
        send(producer, &m);
    }
    while (true) {
        receive(producer, &m);  // receive a message from producer
        item = extract_item(&m);  // extract a message
        send(producer, &m);  // send an empty message to producer (ACK)
        consume_item(item);
    }
}

COSC450 Operating System, Fall 2024  
Dr. Sang-Eon Park9/26/2024

Review
Inter-Process Communication
- Race Condition
- Critical Section (or region)
- Solutions for Mutual Exclusion in a Critical Section
  - With Busy Waiting
    - Disabling Interrupts – non-preemptive kernel
    - Lock Variables – violating the first necessary condition (mutual exclusion)
    - Strict Alternation – violating the second necessary condition (block by a process outside critical section)
    - Peterson’s Solution
    - Hardware Solution
      - Test and Set Lock
      - Memory Barriers
      - Atomic Variable
- Priority Inversion problems with busy waiting

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Preview
- Mutual Exclusion in a Critical Section
  - With Sleep and Wake up
- Producer Consumer Problem
- Race Condition Producer Consumer problem
- Semaphore
  - Concept of Semaphore
  - Semaphore Operation
  - Semaphore Implementation
  - Producer Consumer problem with semaphores
  - Careless Usage of semaphore causes deadlock
- Dining Philosophers Problem
- Reader’s and Writer’s Problem
- Mutexes
- Monitor
  - Implementation of Monitor
  - Producer Consumer with Monitor
- Message Passing
  - Producer Consumer with Message Passing

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Mutual Exclusion with Sleep and Wakeup
- Sleep and Wakeup:
  - A process checks a resource (critical section), if not available go to sleep.
  - When the resource becomes available, the process will be woken up by the system or the process releases the resource.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

The Producer-Consumer Problem
Description
- Two processes share a common, fixed-sized buffer.
- Producer puts information into the buffer, and consumer takes it out.

Troubles arise
- When the producer wants to put a new item in the buffer, but it is already full.
- When the consumer tries to take an item from the buffer, but the buffer is already empty.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

The Producer-Consumer Problem
- When the producer wants to put a new item in the buffer, but it is already full.
  - Solution – the producer goes to sleep, awakened by the consumer when the consumer has removed one or more items.
- When the consumer tries to take an item from the buffer, but the buffer is already empty.
  - Solution – the consumer goes to sleep, awakened by the producer when the producer puts one or more items into the buffer.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

The Producer-Consumer Problem

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

#define N 100 // buffer size
int count = 0; // number of items

void producer() {
    int item;
    while (true) {
        item = produce_item();
        if (count == N) sleep();
        insert_item(item);
        count = count + 1;
        if (count == 1) wakeup(consumer);
    }
}

void consumer() {
    int item;
    while (true) {
        if (count == 0) sleep();
        item = remove_item();
        count = count - 1;
        if (count == N - 1) wakeup(producer);
        consume_item(item);
    }
}9/26/2024

Semaphores – by E. W. Dijkstra

A semaphore is an integer variable which could have the following values:
- 0: no wakeups are saved
- +i: i wakeups are pending

A semaphore is accessed only through two standard atomic operations: down (or P) and up (or V).

Concept of Semaphores:

Modification to the integer value of the semaphore in the down and up operations are executed indivisibly. This means that when a process is modifying the semaphore value, no other process can simultaneously modify that same semaphore value.

Semaphore Operation:

void down(S) {
    if S == 0 {
        1. Add this process to the sleeping list
        2. block;
    }
    S = S - 1;
}

void up(S) {
    S = S + 1;
    if S == 1 {
        1. choose one process P from the sleeping list or let them move to ready state
        2. wakeup(P) to finish down operation
    }
}

Semaphore Implementation:
The normal way for implementing a semaphore is to:
- Implement semaphore operations up and down as system calls.
- The operating system briefly disables all interrupts while it is testing the semaphore, updating it, and putting the process to sleep.

Solving the Producer-Consumer Problem using Semaphores:

#define N 100

typedef int semaphore;
semaphore mutex = 1;  // mutual exclusion
semaphore empty = N;  // empty space
semaphore full = 0;   // number of items

void producer() {
    int item;
    while (true) {
        item = produce_item(); // produce item
        down(&empty); // check empty space
        down(&mutex); // check mutual exclusion
        insert_item(item); // insert item
        up(&mutex); // out from critical section
        up(&full); // increase # of items
    }
}

void consumer() {
    int item;
    while (true) {
        down(&full); // check item in buffer
        down(&mutex); // check mutual exclusion
        item = remove_item(); // remove an item
        up(&mutex); // out from critical section
        up(&empty); // increase the empty space
        consume_item(item);
    }
}

Careless usage of Semaphore causes deadlock:

#define N 100

typedef int semaphore;
semaphore mutex = 1; // mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of items

void producer() {
    int item;
    while (true) {
        item = produce_item();
        down(&mutex);
        down(&empty);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer() {
    int item;
    while (true) {
        down(&full);
        down(&mutex);
        item = remove_item();
        up(&mutex);
        up(&empty);
        consume_item(item);
    }
}Date: 9/26/2024

Careless usage of Semaphore causes deadlock.

#define N 100

typedef int semaphore;
semaphore mutex = 1; // mutual exclusion
semaphore empty = N; // empty space
semaphore full = 0; // number of items

void producer() {
    int item;
    while (true) {
        item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer() {
    int item;
    while (true) {
        down(&mutex);
        down(&full);
        item = remove_item();
        up(&mutex);
        up(&empty);
        consume_item(item);
    }
}

Course: COSC450 Operating System, Fall 2024
Instructor: Dr. Sang-Eon Park

Dining Philosophers Problem:
- Five silent philosophers sit at a round table with bowls of spaghetti. Chopsticks are placed between each pair of adjacent philosophers.
- Each philosopher must alternately think and eat. However, a philosopher can only eat spaghetti when they have both left and right chopsticks.
- Each chopstick can be held by only one philosopher, so a philosopher can use the chopstick only if it is not being used by another philosopher.
- After an individual philosopher finishes eating, they need to put down both chopsticks, making them available to others. A philosopher can take the chopstick on their right or the one on their left as they become available, but cannot start eating before getting both chopsticks.

Course: COSC450 Operating System, Fall 2024
Instructor: Dr. Sang-Eon Park

Readers-Writers Problem:
- Process reader R and writers W share resources at one time. Only one process (reader or writer) can access the shared resources at any time.
1. It is possible that a reader R1 might have the lock to a shared resource, and then another reader R2 requests access. It would be inefficient for R2 to wait until R1 is done before starting its own read operation; instead, R1 and R2 can read the same resource at the same time since both are reading.
2. It is possible that a reader R1 might have the lock, a writer W be waiting for the lock, and then a reader R2 requests access. It would be unfair for R2 to jump in immediately ahead of W; if that happened often enough, W would starve.

Course: COSC450 Operating System, Fall 2024
Instructor: Dr. Sang-Eon Park

Mutexes:
- When the semaphore's ability to count is not needed, the simplified version of the semaphore, called a mutex, is used.
- It is good for managing mutual exclusion to some shared resources or pieces of code.
- It is useful in thread packages that are implemented in user space.
- A mutex is a variable that can be in one of two states: unlocked (0) or locked (1).
- The concept of a mutex is the same as a binary semaphore, which has a value of 0 or 1.

Course: COSC450 Operating System, Fall 2024
Instructor: Dr. Sang-Eon Park9/26/2024

Mutexes

mutexes mutex = 0;
repeat
    mutex_lock(mutex);
    mutex_unlock(mutex);
until false

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Critical Section
Remainder Section

Monitor
- Monitor – High level synchronizing primitive
  - A collection of procedures, variables, and data structures that are all grouped together in a special kind of module.
  - Only one process can be active in a monitor at any instant.
  - Compiler knows that monitors are special and can handle calls to monitor procedures differently from other procedure calls (create special code for monitor).
  - When a process calls a procedure inside a monitor:
    1. Check whether any process is active within the monitor.
    2. If so, the calling process will be suspended until the other process has left the monitor.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Implementation of Monitor
- Since the monitor is a construct for a programming language, monitor implementation is based on the compiler.
- The compiler knows the monitor is a special kind of module; it uses mutex or binary semaphore for mutual exclusion.
- The monitor provides an easy way to achieve mutual exclusion. However, we need to consider how a process can be blocked and how a blocked process can be woken up.
  - Introduction of Condition variables

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Implementation of Monitor
- Conditional variables are used in the monitor.
- There are two operations on the conditional variables (wait, signal).
- When a monitor procedure discovers that it cannot continue, it waits on some condition variable (e.g., full). This action causes the calling process to block, allowing other processes to enter the monitor.
- Other processes (e.g., consumer) can wake up their sleeping partner by signaling the condition variable that their partner is waiting on.
- If there is more than one process waiting on a condition variable, the system scheduler chooses one of them.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Implementation of Monitor
Once a process does a signal, what is the next step to avoid having two active processes in the monitor at the same time?
Solution 1: by Hoare
- Letting the newly awakened process run, suspending the one that issued the signal.
Solution 2: by Brinch Hansen
- A signal statement may appear only as the final statement in a monitor procedure.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Producer-Consumer with Monitor
monitor ProducerConsumer
    condition full, empty;
    integer count;
    procedure insert(item: integer);
    begin
        if count = N then
            wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then
            signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then
            wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N - 1 then
            signal(full);
    end;

count := 0;
end monitor

procedure producer;
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end;
end;

procedure consumer;
begin
    while true do
    begin
        item = ProducerConsumer.remove;
        consume_item(item);
    end;
end;

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park9/26/2024

Message Passing
- Message Passing is a method of interprocess communication using two primitive system calls:
  - send(destination, &message);
  - receive(source, &message);
- Usually, Message Passing is used between processes located in different systems since it is slower than using semaphore or monitor in the same system.
- If there is no message available, the receiver will be blocked by the system until one arrives.
- If there is no message to send, the sender will be blocked by the system until one becomes available.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Message Passing (Design Issues for Message Passing System)
- Messages can be lost.
  - Solution:
    - When a message is received, the receiver sends an acknowledgement message.
    - If the sender has not received the acknowledgement message within a certain time interval, it retransmits the message.
  - This solution causes a new design issue:
    - If the receiver receives a message from the sender and sends an acknowledgement message, but if the acknowledgement message is lost, then the sender sends the same message again, resulting in the receiver receiving the same message twice.
  - Solution:
    - Each message is assigned a sequence number.
    - The receiver's system can recognize duplicated messages and discard one of them.

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park

Producer-Consumer Problem (with Message Passing)
#define N 100
/* number of slots in the buffer */

void producer() {
    int item;
    message m;
    /* message buffer */
    while (true) {
        item = produce_item();
        /* generate item to put in buffer */
        receive(consumer, &m);
        /* wait for an empty slot (ACK) */
        build_message(&m, item);
        /* construct a message to send */
        send(consumer, &m);
        /* send item to consumer */
    }
}

void consumer() {
    int item, i;
    message m;
    for (i = 0; i < N; i++)
        /* send N empty messages */
        send(producer, &m);
    while (true) {
        receive(producer, &m);
        /* receive a message from producer */
        item = extract_item(&m);
        /* extract a message */
        send(producer, &m);
        /* send an empty message to producer (ACK) */
        consume_item(item);
    }
}

COSC450 Operating System, Fall 2024
Dr. Sang-Eon Park
2024-12-18 09:28:20 - INFO - Processing pages: 0, full_response: Yes
2024-12-18 09:28:20 - INFO - Created 1 tasks for question generation
2024-12-18 09:28:20 - INFO - Starting question_generate_chain
2024-12-18 09:28:20 - INFO - Setting up question generation chain
2024-12-18 09:28:20 - INFO - Chain type: <class 'langchain_core.runnables.base.RunnableSequence'>
2024-12-18 09:28:20 - INFO - Question generation chain setup complete
2024-12-18 09:28:26 - INFO - HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
2024-12-18 09:28:26 - INFO - Generated 5 questions for OS with the following questions: [QAPair(question='Which scheduling algorithm guarantees soft real-time functionality?', answer='Preemptive Priority-Based Scheduling', q_type='multiple_choice', choices=['Earliest-Deadline-First Scheduling', 'Rate-Monotonic Scheduling', 'Preemptive Priority-Based Scheduling', 'Proportional Share Scheduling']), QAPair(question='In hard real-time systems, missing a deadline is considered a system failure.', answer='True', q_type='TF', choices=['True', 'False']), QAPair(question='Explain the difference between interrupt latency and dispatch latency in real-time systems.', answer='Interrupt latency is the time from when an interrupt occurs until the system begins executing the interrupt service routine, while dispatch latency is the time taken by the scheduler to stop one process and start another.', q_type='written', choices=[]), QAPair(question='Rate-Monotonic Scheduling assigns priorities based on what characteristic of a process?', answer='True', q_type='TF', choices=['True', 'False']), QAPair(question='What is the primary purpose of admission-control algorithms in real-time CPU scheduling?', answer='Admission-control algorithms are used to determine whether a new process can be admitted to the system based on its deadline and resource requirements, ensuring that existing processes can still meet their deadlines.', q_type='written', choices=[])]
2024-12-18 09:28:26 - INFO - Finished question_generate_chain
2024-12-18 09:28:26 - INFO - Completed question generation. Number of results: 1
2024-12-18 09:28:26 - INFO - Generated test list with 1 tests
2024-12-18 09:28:26 - INFO - Preparing judge_kwargs with 9 parameters
2024-12-18 09:28:26 - INFO - FINAL TEST:
{
    "questions": [
        {
            "question": "Which scheduling algorithm guarantees soft real-time functionality?",
            "answer": "Preemptive Priority-Based Scheduling",
            "q_type": "multiple_choice",
            "choices": [
                "Earliest-Deadline-First Scheduling",
                "Rate-Monotonic Scheduling",
                "Preemptive Priority-Based Scheduling",
                "Proportional Share Scheduling"
            ]
        },
        {
            "question": "In hard real-time systems, missing a deadline is considered a system failure.",
            "answer": "True",
            "q_type": "TF",
            "choices": [
                "True",
                "False"
            ]
        },
        {
            "question": "Explain the difference between interrupt latency and dispatch latency in real-time systems.",
            "answer": "Interrupt latency is the time from when an interrupt occurs until the system begins executing the interrupt service routine, while dispatch latency is the time taken by the scheduler to stop one process and start another.",
            "q_type": "written",
            "choices": []
        },
        {
            "question": "Rate-Monotonic Scheduling assigns priorities based on what characteristic of a process?",
            "answer": "True",
            "q_type": "TF",
            "choices": [
                "True",
                "False"
            ]
        },
        {
            "question": "What is the primary purpose of admission-control algorithms in real-time CPU scheduling?",
            "answer": "Admission-control algorithms are used to determine whether a new process can be admitted to the system based on its deadline and resource requirements, ensuring that existing processes can still meet their deadlines.",
            "q_type": "written",
            "choices": []
        }
    ]
}
2024-12-18 09:28:26 - INFO - All tasks completed. Number of results: 3
2024-12-18 09:28:26 - INFO - Generated 1 tests
2024-12-18 09:28:26 - INFO - Cleaning up temp files
2024-12-18 09:28:26 - INFO - Deleted temp file: /tmp/tmp20n96_gc
2024-12-18 09:28:26 - INFO - Deleted temp file: /tmp/tmpy8ecv6xy
2024-12-18 09:28:26 - INFO - Deleted temp file: /tmp/tmpjdeb42g0
2024-12-18 09:28:26 - INFO - Temp files cleaned
2024-12-18 09:28:26 - INFO - Run function completed
2024-12-18 09:28:26 - INFO - Test generated successfully
