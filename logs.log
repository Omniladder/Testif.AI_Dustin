2024-09-29 09:31:38,030 - INFO - File: cosc350_7.pdf loaded at path: c:\Users\jairi\OneDrive\Desktop\Repos\hackthon UMBC\UMBC-2024-Hackathon\pythonBackend\files\cosc350_7.pdf
2024-09-29 09:31:38,217 - INFO - Loader set for type .PDF
2024-09-29 09:31:38,318 - INFO - Docs loaded using .load_and_split()
2024-09-29 09:31:38,318 - INFO - Docs joined together in one string
2024-09-29 09:31:38,318 - INFO - Doc string inserted into dictionary.
2024-09-29 09:31:38,319 - INFO - Dictionary dumped to json: <_io.TextIOWrapper name='data.json' mode='w' encoding='cp1252'>
2024-09-29 09:31:38,347 - INFO - Pages, and metadata added.
2024-09-29 09:31:38,347 - INFO - Pages: ["9/10/2024 1 Preview \uf070System Calls vs. Library Functions \uf070File Descriptors for a process \uf070System Call for Managing Files \uf06ewrite() \uf06eread() \uf06eopen() \uf06eclose() \uf06elseek() \uf06epwrite(), pread(); COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 1 System Calls vs. Library Functions \uf070A system call is a request for the operating system to do something on behalf of the user's program. \uf070The system calls are functions used in the kernel itself. \uf070To the programmer, the system call appears as a normal C function call. \uf070When a system call, control change from user’s mode to kernel’s mode. COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 2 System Calls vs. Library Functions COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 3 Hardware Kernel System Calls Library Functions Shell Application Software System Calls vs. Library Functions \uf070System calls is the layer of software interface to the kernel. \uf070It is controlled by kernel (unbuffered I/O) \uf070Library functions are built on top of system call (Buffered I/O). It is called and controlled by a process. \uf070Linux system calls are used to process management, file system management, and inter-process communication. \uf070The Linux system interface consist of about 80 system calls. \uf070To access and control file, need system call to open, read, write, close file. COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 4 System Calls vs. Library Functions \uf070A system call is very expensive routine \uf06eChange a mode from user’s mode to kernel’s mode. \uf06eSave all parameters for user’s program for later execution (save snapshot of CPU) \uf06eLoad all necessary parameters for system call routine to CPU . \uf06eExecute the system call routine. \uf06eAfter system call routine, load all saved parameters for user’s program to CPU. \uf06eChange mode from kernel’s mode to user’s mode. \uf06eContinue execution of user’s program. COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 5 System Calls vs. Library Functions \uf070To reduce the overhead of system calls, system such as Unix or Linux provide library functions use buffers. \uf070For example, I/O function library that provide buffered output. \uf070With these library functions, system call routine need execute when size of buffer becomes full. \uf070This dramatically reduce the system call overhead. COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 6", '9/10/2024 2 System Calls vs. Library Functions COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 7 User Program Libraries System Calls Kernel Device Drivers User’s space Kernel’s space File Descriptors for a Process \uf070To the kernel, all open files are referred to by file descriptors. \uf070A file descriptor is a non-negative integer. \uf070When we open an existing file or create a new file, the kernel returns a file descriptor to the process. \uf070We can read or write a file with the file descriptor which was return by system calls open() or create(). COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 8 File Descriptors for a Process \uf070A process has a number of the descriptors associated it. \uf070When a process is created, it has three descriptors which can be used for input, output and error. \uf06e0: Standard input (from keyboard by default) \uf06e1: Standard output (to screen by default) \uf06e2: Standard error (to screen by default) COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 9 System Calls for Managing Files (write()) \uf070The write() system call attempts to write nbyte bytes from the buffer pointed to by buf to the file associated with the open file descriptor, fildes. \uf070It returns the number of bytes actually write. COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 10 #include <unistd.h> ssize_t write(int fildes, const void *buf, size_t nbyte); Returns: number of bytes written, or -1 on error System Calls for Managing Files (write()) COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 11 //write.c #include <unistd.h> #include <stdlib.h> int main() { if ((write (1, "Hear is some data\\n", 18)) != 18) write (2, "error on file descriptor 1\\n", 46); exit (0); } System Calls for Managing Files (write()) COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 12 #include <unistd.h> #include <stdlib.h> int main() { char Buffer[]="Hear is some data\\n"; if ((write (1, Buffer, 18)) != 18) write (2, "error on file descriptor 1\\n", 46); exit (0); }', '9/10/2024 3 System Calls for Managing Files (read()) \uf070The read() system call function attempts to read nbyte bytes from the buffer pointed to by buf to the file associated with the open file descriptor, fildes. \uf070It returns the number of bytes actually read. COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 13 #include <unistd.h> ssize_t read(int fildes, const void *buf, size_t nbyte); Returns: size of byte read, 0 if end of file, -1 on error /* read_buffer.c /* prepare 128 bytes buffer and read a string upto 128 bytes*/ #include <stdio.h> #include <unistd.h> #include <stdlib.h> int main() { char buffer[128]; int nread; /* can read up to 128 character from stdin */ nread = read(0, buffer, 128); if (nread ==-1) write (2, "A read error\\n", 12); /* write content of buffer to stdout */ if ((write (1, buffer, nread))!= nread) write (2, "A write Error!\\n", 14); exit (0); } System Calls for Managing Files (read()) COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 14 /* read_buffer1.c */ /* read and write byte by byte until empty (Ctr-D)*/ #include <stdio.h> #include <unistd.h> int main() { char b[1]; int nread; /* read character by character from stdin */ while ((nread =read(0, b, 1) > 0)) write (1, b, nread); /* write char by char to stdout */ return 0; } System Calls for Managing Files (read()) COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 15 System Calls for Managing Files \uf070Only using read and write system call, we can copy standard input to standard output. \uf070This assume that these have been set up by the shell before this program is executed. COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 16 System Calls for Managing Files COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 17 /* copystdio.c copy standard input to standard output */ #include <stdio.h> #include <stdlib.h> #include <unistd.h> /*STDIN_FILENO, STDOUT_FILENO*/ /* buffer size effect the efficiency of the program */ #define BUFFER_SIZE 2 void err_sys(char *str) { printf ("%s",str); exit (1); } int main() { int nbyte; char buffer[BUFFER_SIZE]; while ((nbyte = read(STDIN_FILENO, buffer, BUFFER_SIZE)) >0) if (write (STDOUT_FILENO, buffer, nbyte) != nbyte) err_sys ("Write Error"); if (nbyte <0) err_sys("read Error"); exit (0); } System Calls for Managing Files (open()) \uf070open() lets you open a file for reading, writing, or reading and writing. \uf070It returns a file descriptor. \uf070The prototype for the open() system call is: \uf070The third argument mode is used only when a new file is being created. COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 18 #include <fcntl.h> int open(const char *fname, int flags ) int open (const char *fname, int flags, mode_t mode); Returns: file descriptor or -1 on error', '9/10/2024 4 System Calls for Managing Files (open()) \uf070 The allowable flags as defined in "/usr/include/fcntl.h" are: \uf070 #define O_RDONLY 0 /* Open the file for reading only */ \uf070 #define O_WRONLY 1 /* Open the file for writing only */ \uf070 #define O_RDWR 2 /* Open the file for both reading and writing*/ \uf070 #define O_NDELAY 04 /* Non-blocking I/O */ \uf070 #define O_APPEND 010 /* append (writes guaranteed at the end) */ \uf070 #define O_CREAT 00400 /*open with file create (uses third open arg) */ \uf070 #define O_TRUNC 01000 /* open with truncation */ \uf070 #define O_EXCL 02000 /* exclusive open */ COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 19 System Calls for Managing Files (open()) \uf070 The allowable mode_type as defined in a header sys/stat.h" are: \uf06eS_IRUSR Read permission, owner. \uf06eS_IWUSR Write permission, owner. \uf06eS_IXUSR Execute/search permission, owner. \uf06eS_IRGRP Read permission, group. \uf06eS_IWGRP Write permission, group. \uf06eS_IXGRP Execute/search permission, group. \uf06eS_IROTH Read permission, others. \uf06eS_IWOTH Write permission, others. \uf06eS_IXOTH Execute/search permission, others. \uf070Or we can use octal number numerical form \uf06e0777, 0755, 0555, …. COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 20 COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 21 /* open.c demonstrate open file */ #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <fcntl.h> /* defines options flags */ static char message[] = "Hello, world"; #define FILE_MODE (S_IRUSR | S_IWUSR | S_IRGRP| S_IWGRP| S_IROTH| S_IWOTH) int main() { int fd; char buffer[80]; /* open for rw and create exclusive open, ceate as rw-rw-rw */ umask(0); /* clear the mask to be able to creat a file with a mode */ fd = open("datafile.dat",O_RDWR | O_CREAT | O_EXCL, FILE_MODE); printf ("fd = %d\\n",fd); if (fd != -1) { printf("datafile.dat opened for read/write access\\n"); write(fd, message, sizeof(message)); lseek(fd, 0, SEEK_SET);/* go back to the beginning of the file */ if (read(fd, buffer, sizeof(message)) == sizeof(message)) printf("\\"%s\\" was written to datafile.dat\\n", buffer); else printf("*** error reading datafile.dat ***\\n"); close (fd); } else printf("*** datafile.dat already exists ***\\n"); return 0; } COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 22 /* open1.c demonstrate open file */ #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <fcntl.h> /* defines options flags */ static char message[] = "Hello, world"; int main() { int fd; char buffer[80]; umask(0); /* clear the mask to be able to creat a file with a mode */ /* open for rw and create exclusive open, ceate as rw-rw-rw */ fd = open("datafile.dat",O_RDWR | O_CREAT | O_EXCL, 0666); printf ("fd = %d\\n",fd); if (fd != -1) { printf("datafile.dat opened for read/write access\\n"); write(fd, message, sizeof(message)); lseek(fd, 0, SEEK_SET);/* go back to the beginning of the file */ if (read(fd, buffer, sizeof(message)) == sizeof(message)) printf("\\"%s\\" was written to datafile.dat\\n", buffer); else printf("*** error reading datafile.dat ***\\n"); close (fd); } else printf("*** datafile.dat already exists ***\\n"); return 0; } System Calls for Managing Files (creat()) \uf070A new file can also be created by calling the create system call. \uf070One deficiency with creat() is that the file is opened only for writing. COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 23 #include <fcntl.h> int creat(const char *fname, mode_t mode); Return: file descriptor, or -1 on error System Calls for Managing Files (close()) \uf070Any opened file is closed by a system call close. \uf070Closing a file releases any record that the process may have on the file', 'System Calls for Managing Files (close()) \uf070Any opened file is closed by a system call close. \uf070Closing a file releases any record that the process may have on the file COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 24 #include <fcntl.h> int close (int filedes); Returns: 0 if OK, -1 on error', '9/10/2024 5 System Calls for Managing Files (lseek()) \uf070Every open file has an associated with current file offset. \uf070It is non negative integer that measures the number of bytes from the beginning of the file. \uf070When a file is opened, offset is set to 0. \uf070Read/write operation start at current file offset and cause the offset to be incremented by the number of bytes read or write. COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 25 System Calls for Managing Files (lseek()) \uf070An open file offset can be explicitly positioned by calling lseek system call. COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 26 #include <unistd.h> off_t lseek(int filedes, off_t offset int whence); Returns: new file offset or -1 on error System Calls for Managing Files (lseek()) \uf070The interpretation of the offset depends on the value of the whence argument. \uf06eSEEK_SET: offset is set to offset bytes from the beginning of the file \uf06eSEEK_CUR: offset is set to its current value plus the offset. \uf06eSEEK_END: set to the size of the file plus the offset COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 27 System Calls for Managing Files (lseek()) COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 28 /* program testlseek.c */ #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <fcntl.h> #include <sys/stat.h> #define FILE_MODE (S_IRUSR | S_IWUSR|S_IRGRP|S_IROTH) /* err_sys display error message and exit */ void err_sys(char *); int main() { int filedes, offset; if ((filedes = open("testlseek.txt", FILE_MODE)) <0) err_sys("Creat File Open Error"); if ((offset = lseek (filedes, 0, SEEK_END))== -1) err_sys("Creat seekl Error"); printf("offset = %d", offset); return 0; } void err_sys(char *str) { printf ("%s",str); exit (1); } System Calls for Managing Files (lseek()) COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 29 /* lseek.c this program test its standard input to see whether it is capable of seeking or not */ #include <sys/types.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> int main() { int offset; if (offset =lseek(STDIN_FILENO, 0, SEEK_END))== -1) printf("cannot seek.\\n"); else printf("Seek OK. \\n"); exit (0); } System Calls for Managing Files (lseek()) COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 30 /* lseek1.c this program display size of input file with input redirection */ #include <sys/types.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> int main() { int offset; if (offset =lseek(STDIN_FILENO, 0, SEEK_END))== -1) printf("cannot seek.\\n"); else printf("file size is %d bytes.\\n", offset); exit (0); }', '9/10/2024 6 COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 31 /* program creathole.c creat a file with a hole in it */ #include <stdio.h> #include <unistd.h> #include <fcntl.h> #include <stdlib.h> #include <sys/stat.h> char buf1[]="abcdefghij"; char buf2[]="ABCDEFGHIJ"; void err_sys(char *str) #define FILE_MODE (S_IRUSR | S_IWUSR|S_IRGRP|S_IROTH) int main() { int filedes; if ((filedes = open("filehole.txt", FILE_MODE)) <0) err_sys("Creat File Open Error"); if (write (filedes, buf1, 10) != 10) err_sys("Creat Write Error"); /*now offset = 10*/ if (lseek (filedes, 40, SEEK_SET)== -1) err_sys("Creat seekl Error");/*now offset =40 */ if (write(filedes, buf2, 10) != 10) err_sys("Creat write Error"); /*now offset = 50 */ return 0; } /* err_sys display error message and exit */ void err_sys(char *str) { printf ("%s",str); exit (1); } pread() and pwrite() system call \uf070Calling pread() (pwrite()) is equivalent to calling lseek() followed by a call to read() (write()) with following exceptions. \uf06e There is no way to interrupt the two operations that occur when we call pread() (pwrite()) \uf06e The current file offset is not updated COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 32 #include <unistd.h> ssize_t pread(int fildes, void *buf, size_t nbyte, off_t offset); Returns: size of byte read, 0 if end of file, -1 on error ssize_t pwriteint fildes, void *buf, size_t nbyte, off_t offset); Returns: size of byte write 0 if end of file, -1 on error pread() and pwrite() system call //pwrite.c shows example for pread() and pwrite() #include <fcntl.h> #include <stdio.h> #include <string.h> #include <unistd.h> #include <sys/stat.h> #include <sys/types.h> int main() { int fd, nr, nr2, nw, nw2; char buf_wr[]={"This is First message to write"}; char buf_wr2[]={"This is second message to write"}; char buf_rd[120]; //open file fd = open("out.txt", O_RDWR|O_CREAT, 0666); // write first message to the file nw = pwrite(fd, &buf_wr, strlen(buf_wr), 0); // write the second message just after the first message to the file nw2= pwrite(fd, &buf_wr2, strlen(buf_wr2), strlen(buf_wr)+1); // read the second message from the file nr = pread(fd, &buf_rd, sizeof(buf_rd), strlen(buf_wr)+1); printf("read from file: %s",buf_rd); close(fd); return 0; } COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 33 sync(), fsync() and fdatasync() System calls \uf070Traditional Unix system maintains a buffer cache (or page cache) in the kernel’s space. \uf070When we write data to a file, the data is normally copied into the buffer cache and queued for writing to disk at some later time. (delayed write). The kernel eventually writes all the delayed-write blocks to disk, normally when it needs to reuse the buffer for some other disk block. \uf070sync(), fsync(), and fdatasync() system calls are provided to ensure consistence of file system on disk with the contents of buffer cache. \uf070The function sync()is normally called periodically (usually every 30 seconds) from a system daemon, often called update. This guarantees regular flushing of the kernel’s block buffers. COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 34 sync(), fsync() and fdatasync() System calls \uf070The fsync() refers only to a single file, specified by the file descriptor filedes, and waits for the disk writes to complete before returning. \uf070This function is used when an application, such as a database, needs to be sure that the modified blocks have been written to the disk. \uf070The fdatasync() is similar to fsync(), but it affects only the data portions of a file. With fsync(), the file’s attributes are also updated synchronously COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 35 #include <unistd.h> int fsync(int fildes); int fdatasync (int filedes); void sync (void); Returns: 0 if ok, -1 on error sync(), fsync() and fdatasync() System calls', 'Dr. Sang-Eon Park 35 #include <unistd.h> int fsync(int fildes); int fdatasync (int filedes); void sync (void); Returns: 0 if ok, -1 on error sync(), fsync() and fdatasync() System calls #include <stdio.h> #include <fcntl.h> int main() { char wbuffer[] = "1234567890"; char rbuffer[100]; int fd; /* Open the file */ fd = open ("test.txt", O_RDWR | O_CREAT | O_TRUNC); /* Write 10 bytes of data */ write (fd, (void *) wbuffer, 10); /* and make sure it\'s written */ fsync (fd); /* Seek the beginning of the file */ lseek (fd, 0, SEEK_SET); /* Read 10 bytes of data */ read (fd, (void *) rbuffer, 10); /* Terminate the data we\'ve read with a null character */ rbuffer[10] = \'\\0\'; printf ("String read = %s.\\n", rbuffer); close (fd); return 0; } COSC350 System Software, Fall 2024 Dr. Sang-Eon Park 36']
2024-09-29 09:31:38,348 - INFO - Metadata: [{'source': 'c:\\Users\\jairi\\OneDrive\\Desktop\\Repos\\hackthon UMBC\\UMBC-2024-Hackathon\\pythonBackend\\files\\cosc350_7.pdf', 'file_path': 'c:\\Users\\jairi\\OneDrive\\Desktop\\Repos\\hackthon UMBC\\UMBC-2024-Hackathon\\pythonBackend\\files\\cosc350_7.pdf', 'page': 0, 'total_pages': 6, 'format': 'PDF 1.7', 'title': 'System Call', 'author': 'Blah', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240910130157-04'00'", 'modDate': "D:20240910130157-04'00'", 'trapped': ''}, {'source': 'c:\\Users\\jairi\\OneDrive\\Desktop\\Repos\\hackthon UMBC\\UMBC-2024-Hackathon\\pythonBackend\\files\\cosc350_7.pdf', 'file_path': 'c:\\Users\\jairi\\OneDrive\\Desktop\\Repos\\hackthon UMBC\\UMBC-2024-Hackathon\\pythonBackend\\files\\cosc350_7.pdf', 'page': 1, 'total_pages': 6, 'format': 'PDF 1.7', 'title': 'System Call', 'author': 'Blah', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240910130157-04'00'", 'modDate': "D:20240910130157-04'00'", 'trapped': ''}, {'source': 'c:\\Users\\jairi\\OneDrive\\Desktop\\Repos\\hackthon UMBC\\UMBC-2024-Hackathon\\pythonBackend\\files\\cosc350_7.pdf', 'file_path': 'c:\\Users\\jairi\\OneDrive\\Desktop\\Repos\\hackthon UMBC\\UMBC-2024-Hackathon\\pythonBackend\\files\\cosc350_7.pdf', 'page': 2, 'total_pages': 6, 'format': 'PDF 1.7', 'title': 'System Call', 'author': 'Blah', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240910130157-04'00'", 'modDate': "D:20240910130157-04'00'", 'trapped': ''}, {'source': 'c:\\Users\\jairi\\OneDrive\\Desktop\\Repos\\hackthon UMBC\\UMBC-2024-Hackathon\\pythonBackend\\files\\cosc350_7.pdf', 'file_path': 'c:\\Users\\jairi\\OneDrive\\Desktop\\Repos\\hackthon UMBC\\UMBC-2024-Hackathon\\pythonBackend\\files\\cosc350_7.pdf', 'page': 3, 'total_pages': 6, 'format': 'PDF 1.7', 'title': 'System Call', 'author': 'Blah', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240910130157-04'00'", 'modDate': "D:20240910130157-04'00'", 'trapped': ''}, {'source': 'c:\\Users\\jairi\\OneDrive\\Desktop\\Repos\\hackthon UMBC\\UMBC-2024-Hackathon\\pythonBackend\\files\\cosc350_7.pdf', 'file_path': 'c:\\Users\\jairi\\OneDrive\\Desktop\\Repos\\hackthon UMBC\\UMBC-2024-Hackathon\\pythonBackend\\files\\cosc350_7.pdf', 'page': 3, 'total_pages': 6, 'format': 'PDF 1.7', 'title': 'System Call', 'author': 'Blah', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240910130157-04'00'", 'modDate': "D:20240910130157-04'00'", 'trapped': ''}, {'source': 'c:\\Users\\jairi\\OneDrive\\Desktop\\Repos\\hackthon UMBC\\UMBC-2024-Hackathon\\pythonBackend\\files\\cosc350_7.pdf', 'file_path': 'c:\\Users\\jairi\\OneDrive\\Desktop\\Repos\\hackthon UMBC\\UMBC-2024-Hackathon\\pythonBackend\\files\\cosc350_7.pdf', 'page': 4, 'total_pages': 6, 'format': 'PDF 1.7', 'title': 'System Call', 'author': 'Blah', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240910130157-04'00'", 'modDate': "D:20240910130157-04'00'", 'trapped': ''}, {'source': 'c:\\Users\\jairi\\OneDrive\\Desktop\\Repos\\hackthon UMBC\\UMBC-2024-Hackathon\\pythonBackend\\files\\cosc350_7.pdf', 'file_path': 'c:\\Users\\jairi\\OneDrive\\Desktop\\Repos\\hackthon UMBC\\UMBC-2024-Hackathon\\pythonBackend\\files\\cosc350_7.pdf', 'page': 5, 'total_pages': 6, 'format': 'PDF 1.7', 'title': 'System Call', 'author': 'Blah', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240910130157-04'00'", 'modDate': "D:20240910130157-04'00'", 'trapped': ''}, {'source': 'c:\\Users\\jairi\\OneDrive\\Desktop\\Repos\\hackthon UMBC\\UMBC-2024-Hackathon\\pythonBackend\\files\\cosc350_7.pdf', 'file_path': 'c:\\Users\\jairi\\OneDrive\\Desktop\\Repos\\hackthon UMBC\\UMBC-2024-Hackathon\\pythonBackend\\files\\cosc350_7.pdf', 'page': 5, 'total_pages': 6, 'format': 'PDF 1.7', 'title': 'System Call', 'author': 'Blah', 'subject': '', 'keywords': '', 'creator': 'Microsoft® PowerPoint® LTSC', 'producer': 'Microsoft® PowerPoint® LTSC', 'creationDate': "D:20240910130157-04'00'", 'modDate': "D:20240910130157-04'00'", 'trapped': ''}]
2024-09-29 09:31:38,348 - INFO - Pages and metadata inserted into dictionary.
2024-09-29 09:31:38,350 - INFO - Content dictionary dumped to json file: <_io.TextIOWrapper name='content.json' mode='w' encoding='cp1252'>
