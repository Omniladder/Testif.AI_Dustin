"Nondeterministic Finite Automata\n\nNondeterminism gives a machine multiple options for its moves.Nondeterministic Finite Automata\n\nIn a nondeterministic finite automaton (NFA), for each state there can be zero, one, two, or more transitions corresponding to a particular symbol.\n\nIf the NFA reaches a state with more than one possible transition corresponding to the input symbol, we say it branches.\n\nIf the NFA reaches a state where there is no valid transition, then that branch dies.NFA Acceptance\n\nAn NFA (Non-deterministic Finite Automaton) accepts the input string if there exists some choice of transitions that leads to ending in an accept state. Thus, one accepting branch is enough for the overall NFA to accept, but every branch must reject for the overall NFA to reject.\n\nThis is a model of computation. We write DFA to specify a deterministic finite automaton (the one defined earlier). If the type doesn\u2019t matter, we now just write FA (Finite Automaton).Example\nWhat does this NFA accept?\nAB\nD\nC0,10\n10\n10,1\nGoddard 3a: 4Example: Doubles\n\nWhat does this NFA accept?\n\nAB\nD\nC0,10\n10\n10,1\n\nIt accepts any binary string that contains 00 or 11 as a substring.Example: Ending of Strings\nAn NFA that accepts all binary strings that end with 101.Example: Ending of Strings\n\nAn NFA that accepts all binary strings that end with 101.\n\nStates: A, B, C, D\n\nInput Symbols: 0, 1\n\nTransitions:\n- From State A: \n  - Input 1: Go to State B\n- From State B:\n  - Input 0: Go to State C\n- From State C:\n  - Input 1: Go to State D\n- From State D:\n  - Input 0: Stay in State D\n  - Input 1: Go to State B\n\nAccepting State: D\n\nGoddard 3a: 7Example: Simultaneous Patterns\nAn NFA for the expression a* + (ab)*\nGoddard 3a: 8Example: Simultaneous Patterns\n\nAn NFA for the expression a* + (ab)*:\n\nState Transitions:\n- From the initial state, it can transition to states representing 'a' (including zero or more 'a's) or the state representing the pattern 'ab' (including zero or more repetitions of 'ab').\n\nVisual representation:\n1. Input 'a' leads to state 'a' or continues to the same state for more 'a's.\n2. Input 'b' transitions to state 'b' if preceded by 'a' in the pattern 'ab'.\n\nThis example illustrates how to construct an NFA for the given regular expression.Nondeterminism as 'Guess and Verify'\n\nThere are many ways to view nondeterminism. One way is the 'guess and verify' idea: We assume the Nondeterministic Finite Automaton (NFA) is clairvoyant and always guesses correctly the next state to go to. However, the NFA must 'check' its guesses.Nondeterminism via Computation Tree\n\nWe can think of nondeterminism as a tree growing downwards, with the children of a node representing its possible successors. The input is accepted exactly when at least one of the branches ends in an accept state.\n\nAccept\nReject\n\nGoddard 3a: 11More Nondeterminism: \u03b5-transitions\n\nWe also allow \u03b5-transitions: arrows labeled with the empty string. These allow the NFA to change state without consuming an input symbol.Example\n\nA  B  C  D\n1  \u03b5  \u03b5\n0.10\n\nGoddard 3a: 13Example\n\nA   B   C   D\n1\u03b5   \u03b5\n0,10\n\nAccepts all binary strings where the last symbol is 0 or that contain only 1\u2019s.\n\nGoddard 3a: 14Another Example\n\nHere is another NFA for the expression a* + (ab)*:\n\nStates:\n- \u03b5a\n- \u03b5ab\n- \u03b5\n\nGoddard 3a: 15Formal Definition\n\nFormally, a Non-deterministic Finite Automaton (NFA) is defined as a 5-tuple (Q, \u03a3, q0, T, \u03b4) where:\n\n- Q is a finite set of states;\n- \u03a3 is the alphabet of input symbols;\n- q0 is the start state;\n- T is a subset of Q that gives the accept states;\n- \u03b4 is the transition function.\n\nThe transition function specifies a set of states rather than a single state: it maps the Cartesian product of Q and \u03a3 to subsets of Q.Practice\n\nGive an NFA for the set of all binary strings that have either the number of 0\u2019s odd, or the number of 1\u2019s not a multiple of 3, or both.\n\nGoddard 3a: 17Solution to Practice\n\nEpsilon: 10\nEpsilon 1: 11\nBinary representation: 000\nGoddard problem 3a: 18Summary\nA nondeterministic finite automaton (NFA) can have zero, one, or multiple transitions corresponding to a particular symbol. It is defined to accept the input if there exists some choice of transitions that cause the machine to end up in an accept state. Nondeterminism can also be viewed as a tree, or as a 'guess-and-verify' concept. You can also have epsilon (\u03b5) transitions, where the NFA can change state without consuming an input symbol.Closure Properties of Regular Languages\n\nWe show how to combine regular languages.Closure Properties\n\nA set is closed under an operation if applying that operation to any members of the set always yields a member of the set. For example, the positive integers are closed under addition and multiplication, but not under division.Closure under Kleene\n\nFact: The set of regular languages is closed under each Kleene operation. That is, if L1 and L2 are regular languages, then each of L1 \u222a L2, L1 L2, and L1* is regular.Proving Closure under Kleene\nThe easiest approach is to show that the regular expressions (REs) for L1 and L2 can be combined or adjusted to form the RE for the combination language. \nExample: The RE for the concatenation of L1 and L2 is obtained by writing down the RE for L1 followed by the RE for L2.Closure under Complementation\n\nFact: The set of regular languages is closed under complementation.\n\nThe complement of a language L, written as L', is the set of all strings not in L but with the same alphabet. The statement asserts that if L is a regular language, then its complement L' is also a regular language.\n\nTo demonstrate this fact, take a deterministic finite automaton (FA) for L and interchange the accept and reject states.Closure under Intersection\n\nFact: The set of regular languages is closed under intersection.\n\nOne approach: Use de Morgan\u2019s law:\nL1 \u2229 L2 = (L1 \u222a L2)'\n\nAdditionally, regular languages are closed under union and complementation.Product Construction for Intersection\n\nEach state in the product is a pair of states from the original machines. Formally, if L1 is accepted by DFA M1 with 5-tuple (Q1, \u03a3, q1, T1, \u03b41) and L2 is accepted by DFA M2 with 5-tuple (Q2, \u03a3, q2, T2, \u03b42), then L1 \u2229 L2 is accepted by the DFA (Q1 \u00d7 Q2, \u03a3, (q1, q2), T1 \u00d7 T2, \u03b4) where \u03b4((r, s), x) = (\u03b41(r, x), \u03b42(s, x)).Example: Even 0's and 1's\nSuppose L1 is the set of binary strings with an even number of 0's, and L2 is the set of binary strings with an even number of 1's. Then the finite automata (FAs) for these languages both have two states:\n\nState A:  \n- Input 0: Transition to State B  \n- Input 1: Stay in State A  \n\nState B:  \n- Input 0: Stay in State A  \n- Input 1: Transition to State B\n\nThus, the finite automata for the intersection L1 \u2229 L2 has four states.Product Construction for Even 0\u2019s and 1\u2019s\n\nA, X   A, Y\nB, Y   B, X1\n\n1\n1\n10\n00\n0\n\nGoddard 4a: 9Overview\n\nA regular language is one that can be represented by a finite automaton (FA) or a regular expression (RE). Regular languages are closed under the following operations: union, concatenation, star (Kleene star), and complementation.Languages that are Not Regular\nThere are severe limits to the recognition problems that a Finite Automaton (FA) can handle. But this requires proof.A Nonregular Language: 0^n 1^n\nThere is no finite automaton (FA) for the language B = {0^n 1^n : n \u2265 0} = {\u03b5, 01, 0011, 000111, ...}\n\nInformal Argument: Suppose the input is known to be a sequence of 0's followed by 1's. The FA has to count the number of 0's; that is, at the end of the 0's, it must be in a state unique to the number of 0's read. However, the FA has only fixed finite memory, while there can be arbitrarily many 0's. This makes it impossible.(In)Distinguishable Strings\n\nTwo strings x and y are indistinguishable with respect to language L if for every string z, it holds that xz is in L if and only if yz is in L. Otherwise, they are distinguishable.\n\nExample: Say A is the language of binary strings with an odd number of 1's. Then the strings 0 and 10001 are indistinguishable with respect to A.Distinguishable Strings and States\n\nTheorem: If M is a DFA (Deterministic Finite Automaton) accepting language L, and x and y are distinguishable strings with respect to L, then M must be in a different state after reading x than after reading y.\n\nSuppose strings x and y put M in the same state. Then, for any string z, the strings xz and yz put M in the same state. Therefore, either both xz and yz are in L or both are out of L. Hence, x and y are indistinguishable.Sets of Distinguishable Strings\n\nCorollary: If DL is a set of pairwise distinguishable strings with respect to L, then any DFA (Deterministic Finite Automaton) for L has at least |DL| states. In particular, if DL is infinite, then L is not regular.Example: 0n1n\nRecall B = {0n1n : n \u2265 0}.\nThe set D_B = {0^j : j \u2265 0} is pairwise distinguishable. Well, take any two strings in D_B: say 0^j and 0^j' with j \u2260 j'. Appending 1^j to the first produces a string in B, but appending 1^j to the second produces a string not in B. That is, 0^j and 0^j' are distinguishable.\nSince D_B is infinite, B is not regular.Example: Lower Bound on Number of States\nConsider the language of all binary strings with an even number of both 0's and 1's. The set {\u03b5, 0, 1, 01} is pairwise distinguishable. Therefore, the product construction DFA we built has the fewest states possible.\n(In general, there is a connection between the smallest number of states of a DFA and the largest set of pairwise distinguishable strings.)\nGoddard 4b: 7Practice\n\nDefine E as the language of all binary strings with an equal number of 0\u2019s and 1\u2019s. Show that E is not regular by finding an infinite set of pairwise distinguishable strings. \n\nGoddard 4b: 8Solution to Practice\nLet D_E be the set of all strings containing only 0\u2019s. Then for i \u2260 j the strings 0^i and 0^j are distinguishable with respect to E, since 0^i 1^i \u2208 E but 0^i 1^j \u2209 E.\nThe set D_E is infinite, and so E is non-regular.\nGoddard 4b: 9The Pumping Lemma\n\nThe infamous Pumping Lemma states that every regular language has a certain repetitive nature:\n\nPumping Lemma: Let A be a regular language accepted by a DFA (Deterministic Finite Automaton) with k states. Then, for any string z in A with at least k symbols, one can find an early internal subsegment that can be pumped. That is, z can be split as u v w where:\n\n- v is nonempty,\n- |u v| \u2264 k, and\n- u^i v w^i is in A for all i \u2265 0.Proof of Pumping Lemma\n\nFollow the sequence of states around the DFA for A on input z. Let q be the first of the k states to recur. Then split the string z as follows:\n\nz = p q r u v w\n\nIt follows that the DFA is in the same state r no matter whether it has read uw, uvw, or uv^2w. Hence, u v^i w is in A for all i \u2265 0.Using the Pumping Lemma\nThe Pumping Lemma is used to show that a language is non-regular by demonstrating that the lemma is contradicted. One needs to choose one string z that does not pump.Example: 0n1n\nConsider again the language B = {0^n 1^n : n \u2265 0}.\nSuppose B were regular.\nThen B would be accepted by a DFA with k states.\nConsider the specific string z = 0^k 1^k. This is in B.\nSplit z = uvw according to the Pumping Lemma.\nThen since |uv| \u2264 k, it follows that v is composed entirely of 0\u2019s. But then uw is not in B (since it has fewer 0\u2019s than 1\u2019s).\nThis contradicts the Pumping Lemma.Example: Palindromes\nA palindrome is a word that reads the same backwards as it does forwards (such as \"level\"). Let P be the set of all palindromes for the alphabet {a, b}. P is non-regular.\nSuppose P were regular. Then it would be accepted by a DFA with, say, k states. Consider the string z = a^k b a^k. Split z = uvw according to the Pumping Lemma. Then since |uv| \u2264 k, it follows that v consists only of a's. Thus uw is not in P, which is a contradiction of the Pumping Lemma.Practice\n\nDefine E as the language of all binary strings with an equal number of 0\u2019s and 1\u2019s. Show that E is not regular by demonstrating that it contradicts the Pumping Lemma.\n\nGoddard 4b: 15Practice Solution\nSuppose E were regular. Then it would be accepted by a DFA with say k states. Consider a specific string z = 0^k 1^k. Split z = uvw according to the Pumping Lemma. Because |uv| \u2264 k, v consists only of 0's. Thus, uw is not in E. This contradicts the Pumping Lemma.\nGoddard 4b: 16Overview\nTo show that a language is non-regular, you can demonstrate that there is an infinite set of pairwise distinguishable strings. Alternatively, you can use the Pumping Lemma to show that there exists a string that cannot be pumped.\nGoddard 4b: 17"